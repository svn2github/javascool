
{\Large{\blue Premiers principes des langages de programmation}}
\end{center}
\vfill~
\end{slide}

Les différents langages sont organisés autour d'un {\blue petit nombre} de 
fonctionnalités 

\begin{slide}
\begin{center}
{\blue Décrire la syntaxe}
\end{center}

\vfill
\vfill~
\end{slide}

\begin{slide}
{\red L'affectation} : constituée d'une variable {\red \tt x} et d'une 
expression {\red \tt t}\\
({\tt x = t}, {\tt x := t}, {\tt x = t;}, ...)

{\red La séquence} : constituée de deux instructions {\red \tt p} et 
{\red \tt q}\\
({\tt p q}, {\tt p;q}, ...)

{\red Le test} : constitué d'une expression {\red \tt t} et de deux 
instr. {\red \tt p} et {\red \tt q}\\
({\tt if (t) p else q}, {\tt if t then p else q}, ...)

{\red La boucle} : constituée d'une expression {\red \tt t} et d'une 
instruction {\red \tt p}\\
({\tt while (t) p}, {\tt while t do p}, ...)
\end{slide}

\begin{slide}
\begin{center}
{\blue Les instructions et les expressions}
\end{center}

\vfill

{\tt x + 3} : une expression 


{\tt y = x + 3} : une instruction (en l'occurrence une affectation)

\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Décrire la sémantique}
\end{center}

Ce que fait un programme : transformer un {\red état}

Un {\red état} indique la valeur de chaque variable à un instant donné 

(une fonction d'un ens. fini de variables dans l'ens. des valeurs)

\begin{center}
\epsfig{file=etat.eps,height=2cm}
\end{center}

valeur $\neq$ expression ({\tt 3} valeur, mais pas {\tt x + 3})
\end{slide}

\begin{slide}
~\vfill

La valeur d'une expression dépend de l'état

{\tt $\Theta$(x + 3, [x = 5]) = 8}

\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Une question difficile}
\end{center}

\vfill

Est-ce que c'est {\red réellement} comme cela à l'intérieur de la machine ?

Plus ou moins, mais de moins en moins 

On ne parle pas de la {\red machine} mais du {\red langage}
\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Une instruction transforme un état en un autre état}
\end{center}

\vfill

{\tt $\Sigma$(p,s) = s'}

Si on exécute l'instruction {\tt p} dans l'état {\tt s}, cela produit l'état 
{\tt s'}

\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue L'affectation}
\end{center}

\vfill

Une opération sur les états : {\tt s + (x = v)}

même état que {\tt s} sauf pour la case {\tt x} qui prend la valeur {\tt v}

Exemple : 

{\tt s = [x = 4, y = 5, z = 6]}

{\tt s + (y = 7) = [x = 4, y = 7, z = 6]}

{\red \tt $\Sigma$(x = t;,s) = s + (x = $\Theta$(t,s))}

\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue La séquence}
\end{center}

\vfill

{\red \tt $\Sigma$(\{p1 p2\},s) = $\Sigma$(p2,$\Sigma$(p1,s))}

\vfill~
\end{slide}


\begin{slide}
\begin{center}
{\blue Le test}
\end{center}

\vfill

si {\tt $\Theta$(t,s) = true}

{\red \tt $\Sigma$(if (t) p1 else p2,s) = $\Sigma$(p1,s)}


si {\tt $\Theta$(t,s) = false}

{\red \tt $\Sigma$(if (t) p1 else p2,s) = $\Sigma$(p2,s)}

\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Avant de voir la boucle ...}
\end{center}

\vfill

{\blue Les points importants :}

\vfill

1. {\tt x} rien à voir avec une variable mathématique

\vfill

2. La valeur de {\tt x + 3} ne change pas miraculeusement au cours du temps

Une expression n'a une valeur que dans un certain état {\tt $\Theta$(t,s)}
\end{slide}

\begin{slide}
3. Dans une affectation, on évalue l'expression dans l'état courant
puis on oublie l'expression

{\tt x = 4; y = x + 1; x = 10;}

{\tt y} prend pas la valeur {\tt 5} et {\red non {\tt 11}}

Pas absurde mais une autre sémantique 

\begin{center}
\epsfig{file=tardif.eps,height=2cm}
\end{center}
\end{slide}

\begin{slide}
\begin{center}
{\blue La boucle}
\end{center}

\begin{center}
{\red { \tt while (t) q}}

{\blue { \tt while (x $<$ 1000) x = x * 2;}}

\end{center}
Quand on exécute cette instruction : 
on calcule la valeur de {\tt t}, si c'est {\tt false} on a terminé, 
si c'est {\tt true}, on exécute {\tt q}, puis on
\end{slide}

\begin{slide}
\begin{center}
{\blue La boucle}
\end{center}

\begin{center}
{\red { \tt while (t) q}}

{\blue { \tt while (x $<$ 1000) x = x * 2;}}
\end{center}

Quand on exécute cette instruction : 
on calcule la valeur de {\tt t}, si c'est {\tt false} on a terminé, 
si c'est {\tt true}, on exécute {\tt q}, puis on
{ calcule la valeur de {\tt t}, si c'est {\tt false} on a terminé, 
si c'est {\tt true}, on exécute {\tt q}, puis}
{\footnotesize 
on calcule la valeur de {\tt t}, si c'est {\tt false} on a terminé, 
si c'est {\tt true}, on exécute {\tt q}, puis}
{\scriptsize on calcule la valeur de {\tt t}, si c'est {\tt false} 
on
  a terminé, si c'est {\tt true}, on exécute {\tt q}, puis}
{\tiny on calcule la valeur de {\tt t}, si c'est {\tt false}
on
  a terminé, si c'est}
\end{slide}

\begin{slide}
~\vfill
{ \tt while (t) q} : notation finie pour une instruction infinie 

\vfill

{\blue \begin{verbatim}
if (t) {q if (t) {q if (t) ...
                           else skip;}
                 else skip;}
       else skip;
\end{verbatim}}

\vfill
         
avec une instruction fictive { \tt \red skip;} qui ne fait rien
({\tt $\Sigma$(skip;,s) = s})
\vfill~
\end{slide}

\begin{slide}
~\vfill

{\blue \begin{verbatim}
{int x = 3; while (x <= 1000) x = 2;}
\end{verbatim}}

ne termine pas 

Instruction infinie : potentialité de non terminaison 

\vfill~
\end{slide}


\begin{slide}
~\vfill

{\blue \begin{verbatim}
{int x = 3; while (x <= 1000) x = 2;}
\end{verbatim}}

ne termine pas 

Instruction infinie : potentialité de non terminaison 

\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Comment modéliser la non terminaison}
\end{center}

\vfill

Si on exécute l'inst. {\tt p} dans l'état {\tt s}, cela ne 
produit aucun état

{\tt $\Sigma$} fonction partielle, non définie en {\tt (p,s)}

\vfill~
\end{slide}

\begin{slide}

Approximations finies : 

{\tt n} tours de boucle

si on n'a pas fini on abandonne 

{\blue \begin{verbatim}
if (t) {q if (t) {q if (t) giveup;
                           else skip;}
                 else skip;}
       else skip;
\end{verbatim}}

$\Sigma$ jamais définie en { \tt (giveup;,s)}

\end{slide}



\begin{slide}
{\blue \tt p$_{\tt 0}$ = if (t) giveup; else skip;}

{\blue  \tt p$_{\tt n+1}$ = if (t) \{q p$_{\tt n}$\} else skip;}

\vfill

Suite { \tt $\Sigma$(p$_{\tt n}$,s)} jamais définie ou définie à
partir d'un certain rang et  constante sur son domaine : {\blue limite} 

{\red  \tt $\Sigma$(while (t) q,s) = lim$_{\tt n}$ $\Sigma$(p$_{\tt n}$,s)} 
\end{slide}

\begin{slide}
\begin{center}
{\blue Un exemple}
\end{center}

{\blue \tt while (x $<$ 1000) x = x*2;}

{\blue \tt p$_{\tt 0}$ = if (x $<$ 1000) giveup; else skip;}

{\footnotesize \blue  \tt p$_{\tt n+1}$ = if (x $<$ 1000) \{x = x * 2; p$_{\tt n}$\} else skip;}

{\tt $\Sigma$(p0,[x=300])} pas définie\\
{\tt $\Sigma$(p1,[x=300]) = $\Sigma$(p0,[x=600])} pas définie\\
{\tt $\Sigma$(p2,[x=300]) = $\Sigma$(p1,[x=600]) = $\Sigma$(p0,[x=1200])
= [x=1200]}\\
...\\
{\footnotesize \red \tt $\Sigma$(while (x $<$ 1000) x = x*2;, [x=300]) = [x=1200]}
\end{slide}

\begin{slide}
\begin{center}
{\blue Un exemple}
\end{center}

\vfill

{\blue \tt while (x $<$ 1000) x = x * 2;} 

demande d'exécuter {\tt p} dans {\tt [x = 300]}

demande d'exécuter {\tt p} dans {\tt [x = 600]}

demande d'exécuter {\tt p} dans {\tt [x = 1200]}

donne {\tt [x = 1200]}
\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Les messages essentiels}
\end{center}

\vfill

Un programme fait quelque chose {\red à quelque chose} : un état

On peut {\red expliquer} pourquoi les programmes font ce qu'ils font

Ils pourraient faire {\red autre chose}

\hfill (exemple : {\tt x = 4; y = x + 1; x = 10;})

\vfill~
\end{slide}

\begin{slide}
~\vfill
\begin{center}
{\large \blue II. Les états et les transitions}
\end{center}
\vfill~
\end{slide}

\begin{slide}
\begin{center}
{\blue Décrire un processus comme une suite de transition entre états}
\end{center}

\vfill

Une partie d'échec : suite d'états de l'échiquier 

La transition d'un état à l'autre décrite par les règles du jeu

Ne rien oublier dans l'état (sinon attention aux hystérésis)

{\red Comment décrire un aéroport ?}

La notion d'automate

\vfill~
\end{slide}

\begin{slide}
~\vfill
\begin{center}
{\large \blue III. Le mot et la chose}
\end{center}
\vfill~
\end{slide}

\begin{slide}

~\vfill

Quelle est la température à Paris : $22^{\circ}C$

Quelle est la température à Rome : $22^{\circ}C$

Quelle est la température dans la capitale de l'Italie : $22^{\circ}C$

\vfill~

\end{slide}

\begin{slide}
\begin{center}
\epsfig{file=state.eps,height=4cm}
\end{center}
\end{slide}

\begin{slide}
\begin{center}
\epsfig{file=state2.eps,height=4cm}
\end{center}
\end{slide}

\begin{slide}
\begin{center}
{\blue Le partage}
\end{center}

\vfill

Devient essentiel quand on ajoute {\red d'autres fonctionnalités}
(fonctions, enregistrements), ...

Également essentiel pour comprendre le web (copier v.s. mettre un {\red lien})
\vfill~
\end{slide}
\end{document}



