stdout: 
{p title = "La «proglet» Smiley"
  {proglet mode = demo name = Smiley
    Cette proglet
    {footnote id = "1" }
    permet de manipuler une petite image de "résolution" "variable," dont les "coordonnées" se "définissent" "ainsi:"
    {p align = center
      {img src = "img/smiley.png" } }
    "c'est" "à" dire que "l'abscisse" "(la" position horizontale ou "largeur," width en "anglais)" va de {c
      "-width"
    }
    "à" {c
      "+width"
    }
    et "l'ordonnée" "(la" position verticale ou "hauteur," height en "anglais)" va de {c
      "-height"
    }
    "à" {c
      "+height"
    }
    "."
    {p
      La "fonction:"
      {code
        {p {r
            smileyReset
          }
          "(width," "height);"
        }
      }
      "où" {b
        width
      }
      et {b
        height
      }
      sont des {r
        int
      }
      permet "d'afficher" une nouvelle image de largeur et hauteur "données" tandis que la fonction
      {code
        {p {r
            smileyLoad
          }
          "(image);"
        }
      }
      "où" {b
        image
      }
      est le lien "«url»" de "l'image," permet "d'afficher" image disponible sur internet "(attention" sa taille doit rester modeste "inférieur" "à" "500"
      {sup
        "2"
      }
      ")" tandis que
      {code
        {p {r
            int
          }
          width "=" {r
            smileyWidth
          }
          "();"
        }
        {p {r
            int
          }
          height "=" {r
            smileyHeight
          }
          "();"
        }
      }
      renvoient la largeur "(width)" et hauteur "(height)" de "l'image" qui a "été" "chargée."
    }
    {p
      Pour "définir" un point de couleur dans cette image la fonction {r
        smileySet
      }
      ":"
      {code
        {p {r
            smileySet
          }
          "(x," "y," "color);"
        }
      }
      {ul
        {li
          "où" {b
            x
          }
          est un {r
            int
          }
          "," entre {b
            "[-width," "+width]"
          }
          "," abscisse du "point;"
        }
        {li
          "où" {b
            y
          }
          est un {r
            int
          }
          "," entre {b
            "[-height," "+height]"
          }
          "," "ordonnée" du "point;"
        }
        {li
          "où" {b
            color
          }
          est un {r
            String
          }
          qui donne la couleur du "point," ses valeurs "étant" {s
            black
          }
          "," {s
            blue
          }
          "," {s
            cyan
          }
          "," {s
            gray
          }
          "," {s
            green
          }
          "," {s
            magenta
          }
          "," {s
            orange
          }
          "," {s
            pink
          }
          "," {s
            red
          }
          "," {s
            white
          }
          "," {s
            yellow
          }
          "."
        }
      }
      permettre "d'écrire" un pixel couleur dans cette "image."
    }
    {p
      Pour "définir" "lire/écrire" un point monochrome les fonctions {r
        "smileySet/smileyGet"
      }
      ":"
      {code
        {p {r
            int
          }
          valeur "=" {r
            smileyGet
          }
          "(x," "y);"
        }
        {p {r
            smileySet
          }
          "(x," "y," "valeur);"
        }
      }
      {ul
        {li
          "où" {b
            x
          }
          est un {r
            int
          }
          "," entre {b
            "[-width," "+width]"
          }
          "," abscisse du "point;"
        }
        {li
          "où" {b
            y
          }
          est un {r
            int
          }
          "," entre {b
            "[-height," "+height]"
          }
          "," "ordonnée" du "point;"
        }
        {li
          "où" {b
            valeur
          }
          est un entier entre {c
            "0"
          }
          "(pour" le noir ")" et {c
            "255"
          }
          "(pour" le blanc ")," toutes les valeurs entre {c
            "0"
          }
          et {c
            "255"
          }
          "définissant" les valeurs de "gris,"
        }
      }
      permettre de "lire/écrire" un pixel monochrome dans cette "image."
    }
    {p
      Un exemple "d'utilisation:" en appuyant sur la touche "["
      {img src = "img/demo.png" } {b
        Demo
      }
      "]" le signe de la paix va "s'afficher:"
      {p align = center
        {img src = "img/smiley2.jpg" } }
      "ceci," "à" "différentes" "résolutions" "256," "128," "64," "32," "16," "8," "4," "2," "1." Avec une bonne "résolution" il sera "très" "lisible," puis petit "à" petit il se "réduira" "à" quelques  "pixels,"  selon  le  programme  "suivant:"
      {code
        {p {r
            for
          }
          "(" {r
            int
          }
          size "=" "256;" size "&gt;" "0;" size "/" "=" "2)" "org.javascool.Pml"
          {p
            t {r
              smileyReset
            }
            "(size," "size);"
          }
          {p
            t {r
              peace
            }
            "();"
          }
          {p
            t {r
              sleep
            }
            "(1000" "-" "size);"
          }
          p
        }
      }
      "où" la routine {r
        peace
      }
      trace le signe de la paix et correspond "à" une fonction "à" "définir."
    }
  }
  {footnotes
    {p
      Cette proglet est un {a href = "http://fr.wikipedia.org/wiki/Open_source"
        code source libre
      }
      "," "programmée" en Java et {a href = " ../api/proglet/Smiley.html"
        "documentée"
      }
      pour sa libre "redistribution," "l'accès" {a href = " ../api/proglet/Smiley.java"
        au code source
      }
      "," et permettre des "développements" "dérivés."
    }
  }
}
