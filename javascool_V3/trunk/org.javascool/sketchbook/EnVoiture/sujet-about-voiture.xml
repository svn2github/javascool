<div class="sujet" title="Un tutoriel sur les graphes (1ère partie)"> 
  <div class="objectif">
    Le but de s’approprier les différents éléments caractéristiques d’un graphe, 
    en vue de saisir les algorithmes qui en font usage, comme par exemple, l'algorithme du plus court chemin. 
    La première partie de ce tutoriel est introductive à la notion de graphe, 
	se limitant essentiellement à un cas concret de parcours d'une voiture entre des villes. 
	On veut faire passer l'idée ici que l'application se retrouve dans de nombreuses situations du quotidien.
    Il faut déja savoir <l link="../../ingredients/doc-files/sujet-hello-world.htm" text="utiliser l'interface"/>,
    se servir de <l link="../../ingredients/doc-files/sujet-about-variables.htm" text="variables"/> 
    et avoir découvert l'<l link="../../ingredients/doc-files/sujet-about-if.htm" text="instruction conditionnelle"/> et 
    les <l link="../../ingredients/doc-files/sujet-about-while.htm" text="boucles"/>, 
    ansi que les <l link="../../ingredients/doc-files/sujet-about-functions.htm" text="fonctions"/>..
  </div>
  <div class="intros">
  	<p>Un graphe est un ensemble de points dont certaines paires sont directement reliées par un lien. 
  	Ces liens peuvent être orientés, d'un point vers un autre ou vice versa. Dans le cas contraire, les liens sont symétriques, et le graphe est non-orienté. 
  	Généralement, les points sont appelés les sommets ou les nœuds. Les liens sont appelés arêtes dans les graphes non-orienté 
  	et arcs dans un graphe orienté.
  	Dans le cas concret d'une carte de villes, les noeuds ou sommets sont représentés par les villes, 
  	et les liens correspondent aux routes construites pour les relier.
    Lorsqu'un chemin existe entre deux noeuds ou sommets dans un graphe, on se pose rapidement la question non seulement de trouver un tel chemin, 
    mais également le plus court chemin possible entre ces deux sommets. 
    Notre oeil est d'ailleurs particulièrement efficace dans cette tâche, tant que le graphe est de taille raisonnable... 
    Mais dès que le graphe comporte plusieurs dizaines de sommets et d'arêtes, 
    trouver le plus court chemin entre deux points devient vite un casse-tête: 
    avez vous déjà eu l'expérience de trouver l'itinéraire le plus rusé entre 2 stations de métro de Paris passant par le minimum de stations??
    (sans demander au site de la RATP de calculer votre itinéraire, bien entendu!)
   </div>

  <div class="works">
    <div title="faire un truc">

	1.	Dans un premier temps, on peut laisser manipuler l'interface qui présente une voiture dans un environnement 3D. 
	Les 4 différentes flèches permettent la navigation. 
	Cette vue est complétée par une représentation 2D (type aérienne) de l'environnement et des mouvements du véhicule. 
	Dans cet environnement, peuvent être ajoutés des "stations" (spots), 
	soit par touche 'a' pour les générer toutes en une seule fois et de manière aléatoire, 
	soit par clic droit et la station apparaitra à la position courante de la voiture. Les stations apparaissent dans les deux représentations. 

	2.	On propose d'introduire à la notion de plus court chemin. 
	En fixant une station de départ et une station d'arrivée, l'objectif de la voiture est de minimiser la distance parcourue (et oui, l'impact carbone..). 
	En tapant 'p', il peut jouer à trouver le plus court chemin entre 2 villes tirées au hasard par notre algorithme (notées V_Dep et V_Arr), 
	en passant par une ville intermédiaire seulement (notée V_interm1).
	On propose que l'élève cherche le plus court chemin par déduction. Il ballade la voiture de station en station 
	et par un 'clic centre + relâche' somme la distance parcourue ('d' remet à zéro la distance parcourue). 
	Si sa distance parcourue égale celle calculée par notre algorithme, on lui indique sa réussite par un "BRAVO!!"
	
	Cette manipulation reposera sur le lemme de Koenig: Un plus court chemin entre 2 sommets est élémentaire, premier algorithme pour trouver le plus court chemin. 
    Le nombre de chemins élémentaires entre s et t étant finis, nous pouvons tous les énumérer en calculant leur longueur et retenir le plus court. 
    Cet algorithme est correct mais révèle un grave défaut : son temps d'exécution. 
    Si le nombre de chemins élémentaires est bien fini, il n'en demeure pas moins très grand, de l'ordre de n! sur un graphe d'ordre n. 
    Pour estimation: sur un graphe de seulement 20 sommets, en supposant que trouver un chemin et calculer sa longueur puissent se faire en une seule opération, 
    sur un ordinateur pouvant effectuer 1 milliard d'opérations par seconde, il nous faudra patienter 77 ans pour obtenir le meilleur trajet..
    
    Pour éviter d'explorer tous les chemins élémentaires du graphe, la manipulation de l'interface aboutira à la seconde propriété, fondamentale, la sous-optimalité. 
    Il s'agit simplement de remarquer qu'être un plus court chemin, ça s'hérite : le "bout" d'un plus court chemin est encore un plus court chemin entre ses extrémités. 
    Ou encore si le trajet le plus rapide entre s et t passe par 2 sommets x et y, ce trajet emprunte nécessairement le plus court chemin entre x et y. 
    Afin de dépeindre cette propriété, on propose de continuer l'exploration précédente, autrement dit on demande à l'élève 
    de rajouter une ville dans son parcours de telle manière à toujours limiter la distance parcourue entre la ville de départ et celle d'arrivée.
    Ainsi, la démarche sera: de chercher la ville intermédiaire (notée V_interm21) pour le parcours V_Dep/V_interm1, 
    puis la ville intermédiaire (notée V_interm22) pour le parcours V_interm1/V_Arr, puis de comparer les parcours:
    V_Dep - V_interm21 - V_interm1 - V_Arr		vs		V_Dep - V_interm1 - V_interm22 - V_Arr
    On gardera le parcours le plus court.
    
    3.	On propose de programmer l'algorithme du plus court chemin dans une seconde partie grâce à l'interface UnGrapheDesChemins.
    </div>
  </div>
</div>