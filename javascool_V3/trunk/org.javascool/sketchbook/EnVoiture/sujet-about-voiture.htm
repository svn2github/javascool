
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<div align="right"></div>
<div class="sujet">
   <h2>Un tutoriel sur les graphes (1&egrave;re partie).</h2> 
   
   <h2>Objectif.</h2>
   <div class="objectif">
      Le but de s&#8217;approprier les diff&eacute;rents &eacute;l&eacute;ments caract&eacute;ristiques d&#8217;un graphe, 
      en vue de saisir les algorithmes qui en font usage, comme par exemple, l'algorithme du plus court chemin. 
      La premi&egrave;re partie de ce tutoriel est introductive &agrave; la notion de graphe, 
      	se limitant essentiellement &agrave; un cas concret de parcours d'une voiture entre des villes. 
      	On veut faire passer l'id&eacute;e ici que l'application se retrouve dans de nombreuses situations du quotidien.
      Il faut d&eacute;ja savoir <a href="../../ingredients/doc-files/sujet-hello-world.htm">utiliser l'interface</a>,
          se servir de <a href="../../ingredients/doc-files/sujet-about-variables.htm">variables</a> 
          et avoir d&eacute;couvert l'<a href="../../ingredients/doc-files/sujet-about-if.htm">instruction conditionnelle</a> et 
          les <a href="../../ingredients/doc-files/sujet-about-while.htm">boucles</a>, 
          ansi que les <a href="../../ingredients/doc-files/sujet-about-functions.htm">fonctions</a>..
        
   </div>
     
   <h2>Introduction.</h2>
   <div id="intros">
      <ol>
         <li>
            <div>Un graphe est un ensemble de points dont certaines paires sont directement reli&eacute;es par un lien. 
                 	Ces liens peuvent &ecirc;tre orient&eacute;s, d'un point vers un autre ou vice versa. Dans le cas contraire, les liens sont sym&eacute;triques,
               et le graphe est non-orient&eacute;. 
                 	G&eacute;n&eacute;ralement, les points sont appel&eacute;s les sommets ou les n&#339;uds. Les liens sont appel&eacute;s ar&ecirc;tes dans les graphes non-orient&eacute;
               
                 	et arcs dans un graphe orient&eacute;.
                 	Dans le cas concret d'une carte de villes, les noeuds ou sommets sont repr&eacute;sent&eacute;s par les villes, 
                       et les liens correspondent aux routes construites pour les relier.
            </div>
         </li>
         <li>
            <div>Lorsqu'un chemin existe entre deux noeuds ou sommets dans un graphe, on se pose rapidement la question non seulement de trouver
               un tel chemin, 
                   mais &eacute;galement le plus court chemin possible entre ces deux sommets. 
                   Notre oeil est d'ailleurs particuli&egrave;rement efficace dans cette t&acirc;che, tant que le graphe est de taille raisonnable...
               
                   Mais d&egrave;s que le graphe comporte plusieurs dizaines de sommets et d'ar&ecirc;tes, 
                   trouver le plus court chemin entre deux points devient vite un casse-t&ecirc;te: 
                   avez vous d&eacute;j&agrave; eu l'exp&eacute;rience de trouver l'itin&eacute;raire le plus rus&eacute; entre 2 stations de m&eacute;tro de Paris passant par le
               minimum de stations??
                  (sans demander au site de la RATP de calculer votre itin&eacute;raire, bien entendu!)
            </div>
         </li>
      </ol>
   </div>
   
     
   <h2>Travail propos&eacute;.</h2>
   <div id="works">
      <ol>
         <li>
            <div>
               <h3>faire un truc.</h3>
               
               	1.	Dans un premier temps, on peut laisser manipuler l'interface qui pr&eacute;sente une voiture dans un environnement 3D. 
               	Les 4 diff&eacute;rentes fl&egrave;ches permettent la navigation. 
               	Cette vue est compl&eacute;t&eacute;e par une repr&eacute;sentation 2D (type a&eacute;rienne) de l'environnement et des mouvements du v&eacute;hicule. 
               	Dans cet environnement, peuvent &ecirc;tre ajout&eacute;s des "stations" (spots), 
               	soit par touche 'a' pour les g&eacute;n&eacute;rer toutes en une seule fois et de mani&egrave;re al&eacute;atoire, 
               	soit par clic droit et la station apparaitra &agrave; la position courante de la voiture. Les stations apparaissent dans les deux
               repr&eacute;sentations. 
               
               	2.	On propose d'introduire &agrave; la notion de plus court chemin. 
               	En fixant une station de d&eacute;part et une station d'arriv&eacute;e, l'objectif de la voiture est de minimiser la distance parcourue
               (et oui, l'impact carbone..). 
               	En tapant 'p', il peut jouer &agrave; trouver le plus court chemin entre 2 villes tir&eacute;es au hasard par notre algorithme (not&eacute;es
               V_Dep et V_Arr), 
               	en passant par une ville interm&eacute;diaire seulement (not&eacute;e V_interm1).
               	On propose que l'&eacute;l&egrave;ve cherche le plus court chemin par d&eacute;duction. Il ballade la voiture de station en station 
               	et par un 'clic centre + rel&acirc;che' somme la distance parcourue ('d' remet &agrave; z&eacute;ro la distance parcourue). 
               	Si sa distance parcourue &eacute;gale celle calcul&eacute;e par notre algorithme, on lui indique sa r&eacute;ussite par un "BRAVO!!"
               	
               	Cette manipulation reposera sur le lemme de Koenig: Un plus court chemin entre 2 sommets est &eacute;l&eacute;mentaire, premier algorithme
               pour trouver le plus court chemin. 
               Le nombre de chemins &eacute;l&eacute;mentaires entre s et t &eacute;tant finis, nous pouvons tous les &eacute;num&eacute;rer en calculant leur longueur et retenir
               le plus court. 
                   Cet algorithme est correct mais r&eacute;v&egrave;le un grave d&eacute;faut : son temps d'ex&eacute;cution. 
                   Si le nombre de chemins &eacute;l&eacute;mentaires est bien fini, il n'en demeure pas moins tr&egrave;s grand, de l'ordre de n! sur un graphe
               d'ordre n. 
                   Pour estimation: sur un graphe de seulement 20 sommets, en supposant que trouver un chemin et calculer sa longueur puissent
               se faire en une seule op&eacute;ration, 
                   sur un ordinateur pouvant effectuer 1 milliard d'op&eacute;rations par seconde, il nous faudra patienter 77 ans pour obtenir
               le meilleur trajet..
                   
                   Pour &eacute;viter d'explorer tous les chemins &eacute;l&eacute;mentaires du graphe, la manipulation de l'interface aboutira &agrave; la seconde propri&eacute;t&eacute;,
               fondamentale, la sous-optimalit&eacute;. 
                   Il s'agit simplement de remarquer qu'&ecirc;tre un plus court chemin, &ccedil;a s'h&eacute;rite : le "bout" d'un plus court chemin est encore
               un plus court chemin entre ses extr&eacute;mit&eacute;s. 
                   Ou encore si le trajet le plus rapide entre s et t passe par 2 sommets x et y, ce trajet emprunte n&eacute;cessairement le plus
               court chemin entre x et y. 
                   Afin de d&eacute;peindre cette propri&eacute;t&eacute;, on propose de continuer l'exploration pr&eacute;c&eacute;dente, autrement dit on demande &agrave; l'&eacute;l&egrave;ve
               
                   de rajouter une ville dans son parcours de telle mani&egrave;re &agrave; toujours limiter la distance parcourue entre la ville de d&eacute;part
               et celle d'arriv&eacute;e.
                   Ainsi, la d&eacute;marche sera: de chercher la ville interm&eacute;diaire (not&eacute;e V_interm21) pour le parcours V_Dep/V_interm1, 
                   puis la ville interm&eacute;diaire (not&eacute;e V_interm22) pour le parcours V_interm1/V_Arr, puis de comparer les parcours:
                   V_Dep - V_interm21 - V_interm1 - V_Arr		vs		V_Dep - V_interm1 - V_interm22 - V_Arr
                   On gardera le parcours le plus court.
                   
                   3.	On propose de programmer l'algorithme du plus court chemin dans une seconde partie gr&acirc;ce &agrave; l'interface UnGrapheDesChemins.
                   
            </div>
         </li>
      </ol>
   </div>
   
</div>