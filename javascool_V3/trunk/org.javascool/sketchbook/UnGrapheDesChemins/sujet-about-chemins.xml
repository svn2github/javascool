<div class="sujet" title="Un tutoriel sur les graphes (2nde partie)"> 
  <div class="objectif">
    Le but est de s’approprier les différents éléments caractéristiques d’un graphe, 
    en vue de saisir les algorithmes qui en font usage, comme par exemple, l'algorithme du plus court chemin. 
    Si la première partie de ce tutoriel visait uniquement à introduire la notion de graphe avec un cas concret de parcours d'une voiture,
    on s'intéresse ici aux notions clés et outils nécessaires pour la construction de l'algorithme du plus court chemin.
    Il faut déja savoir <l link="../../ingredients/doc-files/sujet-hello-world.htm" text="utiliser l'interface"/>,
    se servir de <l link="../../ingredients/doc-files/sujet-about-variables.htm" text="variables"/> 
    et avoir découvert l'<l link="../../ingredients/doc-files/sujet-about-if.htm" text="instruction conditionnelle"/> et 
    les <l link="../../ingredients/doc-files/sujet-about-while.htm" text="boucles"/>, 
    ansi que les <l link="../../ingredients/doc-files/sujet-about-functions.htm" text="fonctions"/>..
  </div>
  <div class="intros">
  	<p>Un graphe est un ensemble de points dont certaines paires sont directement reliées par un lien. 
  	Ces liens peuvent être orientés, d'un point vers un autre ou vice versa. Dans le cas contraire, les liens sont symétriques, et le graphe est non-orienté. 
  	Généralement, les points sont appelés les sommets ou les nœuds. Les liens sont appelés arêtes dans les graphes non-orienté 
        et arcs dans un graphe orienté.</p>
        <p>Un cas concret peut être un réseau d'amis où chaque sommet est une personne en particulier, 
  	et un lien entre deux personnes met en évidence leur familiarité.
    Ainsi, on peut se poser la question comment Alice peut entrer en relation avec Bob, et qui plus est de manière optimum,
        autrement dit an limitant le nombre de personnes intermédiaires.</p>
   </div>

  <div class="works">
    <div title="faire un truc">

	La première partie de ce tutoriel (interface EnVoiture) a été introductive à la notion de graphe, 
	partant d'un cas concret avec le parcours d'une voiture, de telle sorte à visiter des villes tout en limitant le chemin parcouru.
	Dans cette partie, on propose de programmer les concepts clés des graphes. 
	
	Pour avoir davantage d'informations pour la manipulation de l'interface, touche 'i'.
	Pour une manipulation rapide, 'a' génère tous les noeuds disponibles, 'r' génère quelques liens.
	Trouver le plus court chemin entre 2 noeuds: clic gauche + 'b' pour le noeud de départ, clic gauche + 'e' pour le noeud d'arrivée.
	
	1. Construire son propre réseau via:
	- l'ajout d'un noeud:
	<p><r>UnGrapheDesChemins.addNode</r>(<r>String</r> n, <r>int</r> x, <r>int</r> y)</p>
	- la destruction d'un noeud:
	<p><r>UnGrapheDesChemins.removeNode</r>(<r>String</r> n)</p>
	- l'ajout/modification d'un lien entre deux noeuds:
    <p><r>UnGrapheDesChemins.addLink</r>(<r>String</r> nA, <r>String</r> nB)</p>
    - la destruction d'un lien existant entre deux noeuds:
    <p><r>UnGrapheDesChemins.removeLink</r>(<r>String</r> nA, <r>String</r> nB)</p>
	
	2. Récupérer des informations du réseau via:
	- l'obtention d'un noeud à partir d'une position
	<p><r>UnGrapheDesChemins.getClosestNode</r>(<r>int</r> x, <r>int</r> y)</p>
	- questionner si deux noeuds sont liés:
    <p><r>UnGrapheDesChemins.isLink</r>(<r>String</r> nA, <r>String</r> nB)</p>
	- l'obtention de la liste des noeuds en lien avec un noeud spécifique:
    <p><r>UnGrapheDesChemins.getNodes</r>(<r>String</r> n)</p>
    - l'obtention du poids d'un lien entre deux noeud:
    <p><r>UnGrapheDesChemins.getLink</r>(<r>String</r> nA, <r>String</r> nB)</p>
    
    3. Comme prémisse d'un algorithme de plus court chemin, on propose à l'élève:
    Soit un graphe à 4 noeuds, avec une ville de départ et une ville d'arrivée. 
    Depuis la ville départ, si elle est en lien avec la ville d'arrivée, c'est fini; 
    sinon choisir la ville dont le lien a le poids le plus faible.
    Si la boucle n'est pas fini, repartir de la ville précédente, et refaire le raisonnement.
    Continuer jusqu'à aboutir à la ville d'arrivée.
    
    Objectif: prendre conscience que l'algorithme ainsi construit fait le travail, mais est non-optimisé.
    On imprimera le nom des villes parcourues et on se rendra compte de la redondance des chemins. 
    Deplus, en ajoutant un noeud au graphe, on prendra conscience du temps de calcul exponentiel.
    
    4. On propose à l'élève d'utiliser le graphe pour calculer le chemin entre deux villes 
    avec un nombre minimum de villes intermédiaires.
    
    </div>
  </div>
</div>
