
>>> ./src/org/javascool/tools/Invoke.java

6,7c6
< /**
<  * Invoque une méthode sur un objet Java.
---
> /** Invoque une méthode sur un objet Java.
10,21c9,12
<   /**
<    * Invoke une méthode sans argument sur un objet.
<    *
<    * @param object
<    *            L'objet sur lequel on invoque la méthode.
<    * @param method
<    *            La méthode sans argument à invoquer, souvent : <tt>init</tt>,
<    *            <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> ou
<    *            <tt>run</tt>.
<    * @param run
<    *            Si true (par défaut) appelle la méthode, si false teste
<    *            simplement son existence.
---
>   /** Invoke une méthode sans argument sur un objet.
>    * @param object L'objet sur lequel on invoque la méthode.
>    * @param method La méthode sans argument à invoquer, souvent : <tt>init</tt>, <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> ou <tt>run</tt>.
>    * @param run Si true (par défaut) appelle la méthode, si false teste simplement son existence.
23,24c14
<    * @throws RuntimeException
<    *             si la méthode génère une exception lors de son appel.
---
>    * @throws RuntimeException si la méthode génère une exception lors de son appel.
42c32
<     return Invoke.run(object, method, true);
---
>     return run(object, method, true);

>>> ./src/org/javascool/tools/Pml.java

6d5
< import java.util.ArrayList;
9d7
< import java.util.Properties;
12,14c10,13
< /**
<  * Définit la syntaxe PML (Programmatic Markup Language) et son DOM (Data Object
<  * Model) Java.
---
> import java.util.ArrayList;
> import java.util.Properties;
> 
> /** Définit la syntaxe PML (Programmatic Markup Language) et son DOM (Data Object Model) Java.
16,22c15,17
<  * <p>
<  * Un contenu PML (pour «Programmatic Métadata Logicalstructure») et une
<  * structure-logique minimale (Parametric Minimal Logical-structure) qui permet
<  * de définir les paramètres d'un objet numérique (algorithme, web-service) ou
<  * d'interfacer entre des applications. C'est une forme minimale de structure
<  * à-la XML.
<  * </p>
---
>  * <p> Un contenu PML (pour «Programmatic Métadata Logicalstructure») et une structure-logique minimale (Parametric Minimal Logical-structure)
>  * qui permet de définir les paramètres d'un objet numérique (algorithme, web-service) ou d'interfacer entre des applications.
>  * C'est une forme minimale de structure à-la XML.</p>
24,34c19,23
<  * <p>
<  * Ses paramètres sont
<  * <ul>
<  * <li>Son <i>tag</i>, c'est à dire le nom qui définit son type.</li>
<  * <li>Des <i>attributs</i> c'est à dire des valeurs indexes par un nom.</li>
<  * <li>Des <i>éléments</i> c'est à dire des valeurs indexees par un entier
<  * non-négatif <tt>>= 0</tt>.</li>
<  * </ul>
<  * Chaque valeur étant elle même un PML ou une chaîne de caractères. Rien de
<  * plus.
<  * </p>
---
>  * <p> Ses paramètres sont <ul>
>  *   <li>Son <i>tag</i>, c'est à dire le nom qui définit son type.</li>
>  *   <li>Des <i>attributs</i> c'est à dire des valeurs indexes par un nom.</li>
>  *   <li>Des <i>éléments</i> c'est à dire des valeurs indexees par un entier non-négatif <tt>>= 0</tt>.</li>
>  * </ul> Chaque valeur étant elle même un PML ou une chaîne de caractères. Rien de plus.</p>
36,39c25,26
<  * <p>
<  * La syntaxe est de la forme: <div style="margin-left: 40px">
<  * <tt>"{tag name = value .. element .. }"</tt></div> où
<  * <ul>
---
>  * <p>La syntaxe est de la forme:
>  * <div style="margin-left: 40px"><tt>"{tag name = value .. element .. }"</tt></div> où <ul>
41,48c28,29
<  * <li>Les String avec des espaces, <tt>{</tt> ou <tt>}</tt> sont encapsulés
<  * avec des double quotes <tt>'"'</tt> (en utilisant <tt>'\"'</tt> pour y
<  * échapper).</li>
<  * </ul>
<  * Cette syntaxe est minimale, proche des langages à accolades (
<  * <tt>C/C++, PHP, Java</tt>), facile à lire ou éditer et surtout complètement
<  * standar.
<  * </p>
---
>  * <li>Les String avec des espaces, <tt>{</tt> ou <tt>}</tt> sont encapsulés avec des double quotes <tt>'"'</tt> (en utilisant <tt>'\"'</tt> pour y échapper).</li>
>  * </ul>Cette syntaxe est minimale, proche des langages à accolades (<tt>C/C++, PHP, Java</tt>), facile à lire ou éditer et surtout complètement standar.</p>
50,60c31,35
<  * <p>
<  * L'analyse syntaxique de PML est <i>tolérante</i> au sens où une valeur est
<  * toujours obtenue sans générer d'erreur de syntaxe, en utilisant des valeurs
<  * par défaut:
<  * <ul>
<  * <li>La construction <tt>"name = value .. "</tt> sans accolade sera vue comme
<  * une liste de valeur de tag <tt>null</tt>,</li>
<  * <li>Un attribut sans valeur recevra la valeur <tt>true</tt>,</li>
<  * </ul>
<  * etc..
<  * </p>
---
>  * <p>L'analyse syntaxique de PML est <i>tolérante</i> au sens où une valeur est toujours obtenue sans générer d'erreur de syntaxe,
>  * en utilisant des valeurs par défaut: <ul>
>  *  <li> La construction <tt>"name = value .. "</tt> sans accolade sera vue comme une liste de valeur de tag <tt>null</tt>,</li>
>  *  <li> Un attribut sans valeur recevra la valeur <tt>true</tt>,</li>
>  * </ul> etc..</p>
65a41
>   private static final long serialVersionUID = 1L;
67a44
> 
70,77c47,49
<   /**
<    * Initialise la PML en la lisant dans une chaîne de caractères.
<    *
<    * @param value
<    *            La chaîne de syntaxe
<    *            <tt>"{tag name = value .. element .. }"</tt>.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().reset(..)</tt>.
---
>   /** Initialise la PML en la lisant dans une chaîne de caractères.
>    * @param value La chaîne de syntaxe <tt>"{tag name = value .. element .. }"</tt>.
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
89,106c61,68
<   /**
<    * Initialise la PML en la lisant dans une chaîne de caractères dans un
<    * format donné.
<    *
<    * @param value
<    *            La chaîne de syntaxe
<    *            <tt>"{tag name = value .. element .. }"</tt>.
<    * @param format
<    *            Les formats possible sont: <div id="input-format">
<    *            <ul>
<    *            <li>"PML" (valeur par défaut).</li>
<    *            <li>"XML" pour utiliser les structure-logiques XML de la forme
<    *            <tt>&lt;tag name = value .. > &lt;element .. &lt;/tag></tt>
<    *            <li>"HTM" pour utiliser les structure-logiques HTML.</li>
<    *            </ul>
<    *            </div>
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().reset(..)</tt>.
---
>   /** Initialise la PML en la lisant dans une chaîne de caractères dans un format donné.
>    * @param value La chaîne de syntaxe <tt>"{tag name = value .. element .. }"</tt>.
>    * @param format Les formats possible sont: <div id="input-format"><ul>
>    * <li>"PML" (valeur par défaut).</li>
>    * <li>"XML" pour utiliser les structure-logiques XML de la forme <tt>&lt;tag name = value .. > &lt;element .. &lt;/tag></tt>
>    * <li>"HTM" pour utiliser les structure-logiques HTML.</li>
>    * </ul></div>
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
111,113c73
<       return reset(
<                Xml2Xml.run(value, Pml.xml2pml).replaceAll("¨", "\\\\\"")
<                .replaceAll("«", "\\{"), "pml");
---
>       return reset(Xml2Xml.run(value, xml2pml).replaceAll("¨", "\\\\\"").replaceAll("«", "\\{"), "pml");
115,116c75
<       return reset(Xml2Xml.run(Xml2Xml.html2xhtml(value), Pml.xml2pml),
<                    "pml");
---
>       return reset(Xml2Xml.run(Xml2Xml.html2xhtml(value), xml2pml), "pml");
122,128c81,83
<   /**
<    * Initialise la PML en en recopiant la PML en entrée.
<    *
<    * @param pml
<    *            Le PML à copier.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().reset(..)</tt>.
---
>   /** Initialise la PML en en recopiant la PML en entrée.
>    * @param pml Le PML à copier.
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
145,150c100,101
<   /**
<    * Initialise la PML à partir des arguments d'une ligne de commande.
<    * <p>
<    * La méthode s'utilise dans la construction:
<    *
<    * <pre>
---
>   /** Initialise la PML à partir des arguments d'une ligne de commande.
>    * <p>La méthode s'utilise dans la construction: <pre>
153,161c104,106
<    * ../..
<    *
<    * <pre>
<    * </p>
<    * <p>
<    * Il respecte les conventions suivantes:
<    * <ul>
<    * <li><tt>-name</tt> définit un paramètre à la valeur true (la syntaxe
<    * <tt>--name</tt> est aussi acceptée),</li>
---
>    * ../..<pre></p>
>    * <p>Il respecte les conventions suivantes: <ul>
>    * <li><tt>-name</tt> définit un paramètre à la valeur true (la syntaxe <tt>--name</tt> est aussi acceptée),</li>
164,174c109,112
<    * <li><tt>- file</tt> ajoute un élément de type string qui commence par un
<    * <tt>-</tt>.</li>
<    * </ul>
<    * Par exemple: <tt>command -quiet -level 123 input1 input2</tt> definit la
<    * PML <tt>{usage quiet=true level=123 input1 inpu2}</tt>.
<    * </p>
<    *
<    * @param usage
<    *            Les éléments de la ligne de commande.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().reset(..)</tt>.
---
>    * <li><tt>- file</tt> ajoute un élément de type string qui commence par un <tt>-</tt>.</li>
>    ***</ul> Par exemple: <tt>command -quiet -level 123 input1 input2</tt> definit la PML <tt>{usage quiet=true level=123 input1 inpu2}</tt>.</p>
>    * @param usage Les éléments de la ligne de commande.
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().reset(..)</tt>.
180,182c118
<         if(usage[i].startsWith("-")
<            && ((i == 0) || !"-".equals(usage[i - 1])))
<         {
---
>         if(usage[i].startsWith("-") && ((i == 0) || !"-".equals(usage[i - 1]))) {
195,215c131,139
<   /**
<    * Retourne la PML sous forme de chaîne de caractères.
<    *
<    * @param format
<    *            de sortie <div id="output-format">
<    *            <ul>
<    *            <li>"RAW" Retourne une chaîne 1D de longueur minimale (par
<    *            défault).</li>
<    *            <li>"TXT" Retourne une chaîne 2D formattée.</li>
<    *            <li>"XML" Retourne une structure logique XML, en réduisant les
<    *            tag et attributs à des nom XML valides et en considérant les
<    *            PML sans attribut ni élément comme des chaînes.
<    *            <li>
<    *            <li>"PHP" Retourne un élément de code PHP de la forme:
<    *            <tt>&lt;php $tag = array("_tag" = getTag(), . . "name" => "value", . . , "element");?></tt>
<    *            .</li>
<    *            <li>"JMF" Retourne un format de fichier de manifeste de JAR de
<    *            la forme: <tt> name : value \n .. </tt> en omettant le tag et
<    *            les éléments.</li>
<    *            </ul>
<    *            </div>
---
>   /** Retourne la PML sous forme de chaîne de caractères.
>    * @param format de sortie <div id="output-format"><ul>
>    * <li>"RAW" Retourne une chaîne 1D de longueur minimale (par défault).</li>
>    * <li>"TXT" Retourne une chaîne 2D formattée.</li>
>    * <li>"XML" Retourne une structure logique XML,
>    * en réduisant les tag et attributs à des nom XML valides et en considérant les PML sans attribut ni élément comme des chaînes.<li>
>    * <li>"PHP" Retourne un élément de code PHP de la forme:<tt>&lt;php $tag = array("_tag" = getTag(), . . "name" => "value", . . , "element");?></tt>.</li>
>    * <li>"JMF" Retourne un format de fichier de manifeste de JAR de la forme: <tt> name : value \n .. </tt> en omettant le tag et les éléments.</li>
>    * </ul></div>
220,223c144,147
<     return "xml".equals(format) ? new XmlWriter().toString(this) : "raw"
<            .equals(format) ? new PlainWriter().toString(this, 0) : "php"
<            .equals(format) ? new PhpWriter().toString(this) : "jmf"
<            .equals(format) ? new JmfWriter().toString(this)
---
>     return "xml".equals(format) ? new XmlWriter().toString(this)
>            : "raw".equals(format) ? new PlainWriter().toString(this, 0)
>            : "php".equals(format) ? new PhpWriter().toString(this)
>            : "jmf".equals(format) ? new JmfWriter().toString(this)
230,243c154,158
<   /**
<    * Initialise la PML en la lisant dans un fichier donné.
<    *
<    * @param location
<    *            L'URL (Universal Resource Location) de chargement de <a
<    *            href="FileManager.html#load-format">format standard</a>.
<    * @param format
<    *            Le format de lecture parmi les <a href="#input-format">formats
<    *            supportés</a>, par défaut donné par l'extension du fichier.
<    * @param utf8
<    *            Si la valeur est vraie, force l'encodage en UTF-8 à la
<    *            lecture. Par défaut (false) utilise l'encodage local.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().load(..)</tt>.
---
>   /** Initialise la PML en la lisant dans un fichier donné.
>    * @param location  L'URL (Universal Resource Location) de chargement de <a href="FileManager.html#load-format">format standard</a>.
>    * @param format Le format de lecture parmi les <a href="#input-format">formats supportés</a>, par défaut donné par l'extension du fichier.
>    * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().load(..)</tt>.
269,280c184,187
<   /**
<    * Sauve la PML dans un fichier donné.
<    *
<    * @param location
<    *            L'URL (Universal Resource Location) d'écriture de <a
<    *            href="FileManager.html#save-format">format standard</a>.
<    * @param format
<    *            Le format d'écriture parmi les <a
<    *            href="#output-format">formats supportés</a>, par défaut donné
<    *            par l'extension du fichier.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().save(..)</tt>.
---
>   /** Sauve la PML dans un fichier donné.
>    * @param location  L'URL (Universal Resource Location) d'écriture de <a href="FileManager.html#save-format">format standard</a>.
>    * @param format Le format d'écriture parmi les <a href="#output-format">formats supportés</a>, par défaut donné par l'extension du fichier.
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().save(..)</tt>.
292,295c199
<   /**
<    * Definit l'analyseur lexical qui lit la chaîne mot à mot en normlisant les
<    * espaces et en titant le caractère '"'.
<    */
---
>   /** Definit l'analyseur lexical qui lit la chaîne mot à mot en normlisant les espaces et en titant le caractère '"'. */
311d214
< 
325,327c228
<           while(ichar < chars.length
<                 && Character.isWhitespace(chars[ichar]))
<           {
---
>           while(ichar < chars.length && Character.isWhitespace(chars[ichar])) {
335,336c236
<             // Detects a quoted string taking "{" "}" and \"
<             // constructs into account
---
>             // Detects a quoted string taking "{" "}" and \" constructs into account
338,340c238
<               while(ichar < chars.length
<                     && (ichar == ichar0 || chars[ichar] != '"' || chars[ichar - 1] == '\\'))
<               {
---
>               while(ichar < chars.length && (ichar == ichar0 || chars[ichar] != '"' || chars[ichar - 1] == '\\')) {
348,350c246
<               if((ichar == ichar0 + 3)
<                  && ((chars[ichar0 + 1] == '{') || (chars[ichar0 + 1] == '}')))
<               {
---
>               if((ichar == ichar0 + 3) && ((chars[ichar0 + 1] == '{') || (chars[ichar0 + 1] == '}'))) {
358,363c254,255
<             } else if(Character.isLetter(chars[ichar0])
<                       || (chars[ichar0] == '_'))
<             {
<               while(ichar < chars.length
<                     && (Character.isLetterOrDigit(chars[ichar]) || chars[ichar0] == '_'))
<               {
---
>             } else if(Character.isLetter(chars[ichar0]) || (chars[ichar0] == '_')) {
>               while(ichar < chars.length && (Character.isLetterOrDigit(chars[ichar]) || chars[ichar0] == '_')) {
368,373c260,261
<             } else if(Character.isDigit(chars[ichar0])
<                       || (chars[ichar0] == '.'))
<             {
<               while(ichar < chars.length
<                     && Character.isDigit(chars[ichar]))
<               {
---
>             } else if(Character.isDigit(chars[ichar0]) || (chars[ichar0] == '.')) {
>               while(ichar < chars.length && Character.isDigit(chars[ichar])) {
378,380c266
<                 while(ichar < chars.length
<                       && Character.isDigit(chars[ichar]))
<                 {
---
>                 while(ichar < chars.length && Character.isDigit(chars[ichar])) {
384,386c270
<               if((ichar < chars.length)
<                  && ((chars[ichar] == 'E') || (chars[ichar] == 'e')))
<               {
---
>               if((ichar < chars.length) && ((chars[ichar] == 'E') || (chars[ichar] == 'e'))) {
388,390c272
<                 if((ichar < chars.length)
<                    && ((chars[ichar] == '+') || (chars[ichar] == '-')))
<                 {
---
>                 if((ichar < chars.length) && ((chars[ichar] == '+') || (chars[ichar] == '-'))) {
393,395c275
<                 while(ichar < chars.length
<                       && Character.isDigit(chars[ichar]))
<                 {
---
>                 while(ichar < chars.length && Character.isDigit(chars[ichar])) {
401,404c281,282
<             } else if(TokenReader.isOperator(chars[ichar0])) {
<               while(ichar < chars.length
<                     && TokenReader.isOperator(chars[ichar]))
<               {
---
>             } else if(isOperator(chars[ichar0])) {
>               while(ichar < chars.length && isOperator(chars[ichar])) {
438,443c316,317
<     /**
<      * Renvoie un des éléments.
<      *
<      * @param next
<      *            Si 0 renvoie l'élément courant. Si 1 renvoie l'élément à
<      *            suivre, etc..
---
>     /** Renvoie un des éléments.
>      * @param next Si 0 renvoie l'élément courant. Si 1 renvoie l'élément à suivre, etc..
447,448c321
<       String current = itoken + next < tokens.size() ? tokens.get(itoken
<                                                                   + next).string : "}";
---
>       String current = itoken + next < tokens.size() ? tokens.get(itoken + next).string : "}";
455,459c328,329
<     /**
<      * Avance à un élément suivant.
<      *
<      * @param next
<      *            Si 1 avance d'un élément, etc..
---
>     /** Avance à un élément suivant.
>      * @param next Si 1 avance d'un élément, etc..
475,480c345
<         System.out.println("Erreur de syntaxe \""
<                            + message
<                            + "\", ligne "
<                            + (itoken < tokens.size() ? ""
<                               + tokens.get(itoken).line + " vers \""
<                               + getToken(0) + "\"" : "finale"));
---
>         System.out.println("Erreur de syntaxe \"" + message + "\", ligne " + (itoken < tokens.size() ? "" + tokens.get(itoken).line + " vers \"" + getToken(0) + "\"" : "finale"));
487,488c352
<         s += (i == itoken ? " ! " : " ") + "\"" + tokens.get(i).string
<              + "\"#" + tokens.get(i).line;
---
>         s += (i == itoken ? " ! " : " ") + "\"" + tokens.get(i).string + "\"#" + tokens.get(i).line;
568,579c432,445
<   private static String xml2pml = "<?xml version='1.0' encoding='utf-8'?>\n"
<                                   + "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n"
<                                   + "  <xsl:output method='text' encoding='utf-8' omit-xml-declaration='yes'/>\n"
<                                   + "  <xsl:template match='*'>\n"
<                                   + "  {<xsl:value-of select='name(.)'/><xsl:text> </xsl:text>\n"
<                                   + "    <xsl:for-each select='@*'><xsl:value-of select='name(.)'/>=\"<xsl:value-of select=\"translate(., '&quot;','¨')\"/>\"<xsl:text> </xsl:text></xsl:for-each>\n"
<                                   + "    <xsl:if test='count(*) = 0'>\n"
<                                   + "      <xsl:apply-templates select='*'/>\n"
<                                   + "      <xsl:value-of select=\"concat('&quot;', translate(translate(text(), '&quot;','¨'), '{', '«'), '&quot;')\"/>\n"
<                                   + "    </xsl:if>\n"
<                                   + "    <xsl:if test='count(*) > 0'><xsl:apply-templates/></xsl:if>\n"
<                                   + "  }</xsl:template>\n" + "</xsl:stylesheet>";
---
>   private static String xml2pml =
>     "<?xml version='1.0' encoding='utf-8'?>\n"
>     + "<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>\n"
>     + "  <xsl:output method='text' encoding='utf-8' omit-xml-declaration='yes'/>\n"
>     + "  <xsl:template match='*'>\n"
>     + "  {<xsl:value-of select='name(.)'/><xsl:text> </xsl:text>\n"
>     + "    <xsl:for-each select='@*'><xsl:value-of select='name(.)'/>=\"<xsl:value-of select=\"translate(., '&quot;','¨')\"/>\"<xsl:text> </xsl:text></xsl:for-each>\n"
>     + "    <xsl:if test='count(*) = 0'>\n"
>     + "      <xsl:apply-templates select='*'/>\n"
>     + "      <xsl:value-of select=\"concat('&quot;', translate(translate(text(), '&quot;','¨'), '{', '«'), '&quot;')\"/>\n"
>     + "    </xsl:if>\n"
>     + "    <xsl:if test='count(*) > 0'><xsl:apply-templates/></xsl:if>\n"
>     + "  }</xsl:template>\n"
>     + "</xsl:stylesheet>";
586,593c452,454
<     /**
<      * Convertit la PML en chaîne.
<      *
<      * @param pml
<      *            Le PML à convertir.
<      * @param width
<      *            si width == 0 retourne une chaîne 1D de longueur minimale,
<      *            sinon retourne une chaîne 2D de la largeur donnée.
---
>     /** Convertit la PML en chaîne.
>      * @param pml Le PML à convertir.
>      * @param width si width == 0 retourne une chaîne 1D de longueur minimale, sinon retourne une chaîne 2D de la largeur donnée.
616c477
<       string.append("{").append(PlainWriter.quote(pml.getTag()));
---
>       string.append("{").append(quote(pml.getTag()));
618c479
<         string.append(" ").append(PlainWriter.quote(name)).append("=");
---
>         string.append(" ").append(quote(name)).append("=");
633,636c494
<         boolean ln = n >= 0
<                      && (n == 0 || (pml.getParent() != null
<                                     && pml.getParent().getChild(n - 1) != null&& pml
<                                     .getParent().getChild(n - 1).getSize() > 0));
---
>         boolean ln = n >= 0 && (n == 0 || (pml.getParent() != null&& pml.getParent().getChild(n - 1) != null&& pml.getParent().getChild(n - 1).getSize() > 0));
638c496
<         write(PlainWriter.quote(pml.getTag()), tab);
---
>         write(quote(pml.getTag()), tab);
641,642c499
<         boolean ln = pml.getTag().length() > 1
<                      || "p".equals(pml.getTag());
---
>         boolean ln = pml.getTag().length() > 1 || "p".equals(pml.getTag());
644c501
<         write("{" + PlainWriter.quote(pml.getTag()), tab);
---
>         write("{" + quote(pml.getTag()), tab);
647c504
<           write(" " + PlainWriter.quote(name) + " =", tab);
---
>           write(" " + quote(name) + " =", tab);
676,681c533,535
<       return string == null ? "null"
<              : string.matches("[a-zA-Z_][a-zA-Z0-9_]*")
<              || "\"{\"".equals(string) || "\"}\"".equals(string) ? string
<              : "\""
<              + string.replaceAll("\\\\", "\\\\\\\\")
<              .replaceAll("\"", "\\\\\"") + "\"";
---
>       return string == null ? "null" :
>              string.matches("[a-zA-Z_][a-zA-Z0-9_]*") || "\"{\"".equals(string) || "\"}\"".equals(string) ? string :
>              "\"" + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\\\"") + "\"";
700,703c554
<         string.append(" ").append(
<           pml.getTag().replaceFirst("^\"([{}])\"$", "$1")
<           .replaceAll("&", "&amp;")
<           .replaceAll("<", "&lt;"));
---
>         string.append(" ").append(pml.getTag().replaceFirst("^\"([{}])\"$", "$1").replaceAll("&", "&amp;").replaceAll("<", "&lt;"));
705c556
<         string.append(" <").append(Pml.toName(pml.getTag()));
---
>         string.append(" <").append(toName(pml.getTag()));
707,715c558,559
<           string.append(" ")
<           .append(Pml.toName(name))
<           .append("=\"")
<           .append(pml.getChild(name).toString()
<                   .replaceFirst("^\\{(.*)\\}$", "$1")
<                   .replaceFirst("^\"(.*)\"$", "$1")
<                   .replaceAll("&", "&amp;")
<                   .replaceAll("<", "&lt;")
<                   .replaceAll("\"", "&quot;")).append("\"");
---
>           string.append(" ").append(toName(name)).append("=\"").append(pml.getChild(name).toString().replaceFirst("^\\{(.*)\\}$", "$1").replaceFirst("^\"(.*)\"$", "$1").
>                                                                        replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll("\"", "&quot;")).append("\"");
720,721c564
<           string.append("</").append(Pml.toName(pml.getTag()))
<           .append(">");
---
>           string.append("</").append(toName(pml.getTag())).append(">");
729c572
<   /** Définit le convertisseur de PML en PHP. */
---
>   /**  Définit le convertisseur de PML en PHP. */
739c582
<         String tag = Pml.toName(pml.getTag());
---
>         String tag = toName(pml.getTag());
743,745c586
<         string.append("<?php $").append(tag)
<         .append(" = array(\"_tag\" => ")
<         .append(PhpWriter.quote(pml.getTag()));
---
>         string.append("<?php $").append(tag).append(" = array(\"_tag\" => ").append(quote(pml.getTag()));
747,749c588
<           string.append(", ").append(PhpWriter.quote(name))
<           .append(" => ")
<           .append(PhpWriter.quote(pml.getChild(name)));
---
>           string.append(", ").append(quote(name)).append(" => ").append(quote(pml.getChild(name)));
751,752c590
<           string.append(", ")
<           .append(PhpWriter.quote(pml.getChild(n)));
---
>           string.append(", ").append(quote(pml.getChild(n)));
759,761c597
<       return "\""
<              + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"",
<                                                                 "\\\\\"") + "\"";
---
>       return "\"" + string.replaceAll("\\\\", "\\\\\\\\").replaceAll("\"", "\\\\\"") + "\"";
764,765c600
<       return PhpWriter.quote(pml.getSize() == 0 ? pml.getTag() : pml
<                              .toString());
---
>       return quote(pml.getSize() == 0 ? pml.getTag() : pml.toString());
769c604
<   /** Définit le convertisseur de PML en JMF. */
---
>   /**  Définit le convertisseur de PML en JMF. */
780,782c615
<           string.append(name).append(": ")
<           .append(JmfWriter.quote(pml.getChild(name)))
<           .append("\n");
---
>           string.append(name).append(": ").append(quote(pml.getChild(name))).append("\n");
791,792c624
<       return JmfWriter.quote(pml.getSize() == 0 ? pml.getTag() : pml
<                              .toString());
---
>       return quote(pml.getSize() == 0 ? pml.getTag() : pml.toString());
799,800c631
<       String name = c_0.matches("[_-]")
<                     || Character.isLetter(c_0.charAt(0)) ? "" : "_";
---
>       String name = c_0.matches("[_-]") || Character.isLetter(c_0.charAt(0)) ? "" : "_";
803,804c634
<         name += c_i.matches("_-")
<                 || Character.isLetterOrDigit(c_i.charAt(0)) ? c_i : "_";
---
>         name += c_i.matches("_-") || Character.isLetterOrDigit(c_i.charAt(0)) ? c_i : "_";
811,815c641,642
<   /**
<    * Renvoie le type de ce PML.
<    *
<    * @return The tag définit lors de l'initialisation, sinon le nom de la
<    *         classe du PML.
---
>   /** Renvoie le type de ce PML.
>    * @return The tag définit lors de l'initialisation, sinon le nom de la classe du PML.
826,830c653,654
<   /**
<    * Renvoie le parent du PML si défini.
<    *
<    * @return Si ce PML est un sous-partie d'un PML renvoie son parent, sinon
<    *         renvoie null.
---
>   /** Renvoie le parent du PML si défini.
>    * @return Si ce PML est un sous-partie d'un PML renvoie son parent, sinon renvoie null.
842,850c666,668
<   /**
<    * Teste si un paramètre de ce PML est défini.
<    * <p>
<    * Cet appel est formellement équivalent à <tt>getChild(name) != null</tt>
<    * </p>
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
---
>   /** Teste si un paramètre de ce PML est défini.
>    * <p>Cet appel est formellement équivalent à <tt>getChild(name) != null</tt></p>
>    * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
862,867c680,681
<   /**
<    * Renvoie la valeur d'un paramètre de ce PML.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
---
>   /** Renvoie la valeur d'un paramètre de ce PML.
>    * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
872,873c686
<     return o == null ? null : o instanceof Pml ? (Pml) o : new Pml()
<            .reset("{\"" + o.toString() + "\"}");
---
>     return o == null ? null : o instanceof Pml ? (Pml) o : new Pml().reset("{\"" + o.toString() + "\"}");
881,888c694,696
<   /**
<    * Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @return La valeur du paramètre, ou null si indéfini en tant que
<    *         paramètre.
---
>   /** Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
>    * @param name Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @return La valeur du paramètre, ou null si indéfini en tant que paramètre.
899,900c707
<   /**
<    * Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
---
>   /** Renvoie la d'un paramètre de ce PML en tant qu'objet Java.
902,908c709,711
<    * /** Renvoie la valeur d'un paramètre de ce PML en tant que chaîne.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @param value
<    *            La valeur par défaut, sinon "".
---
>    *  /** Renvoie la valeur d'un paramètre de ce PML en tant que chaîne.
>    * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @param value La valeur par défaut, sinon "".
942,949c745,747
<   /**
<    * Renvoie la valeur d'un paramètre de ce PML en tant que décimal.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @param value
<    *            La valeur par défaut, sinon "0".
---
>   /** Renvoie la valeur d'un paramètre de ce PML en tant que décimal.
>    * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @param value La valeur par défaut, sinon "0".
977,984c775,777
<   /**
<    * Renvoie la valeur d'un paramètre de ce PML en tant qu'entier.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @param value
<    *            La valeur par défaut, sinon "0".
---
>   /** Renvoie la valeur d'un paramètre de ce PML en tant qu'entier.
>    * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @param value La valeur par défaut, sinon "0".
1012,1022c805,808
<   /**
<    * Renvoie la valeur d'un paramètre de ce PML en tant que boolean.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @param value
<    *            La valeur par défaut, sinon false.
<    * @return La valeur true ou false si le paramètre est égal à "true" ou
<    *         "false" indépendamment de la casse, la valeur par défaut
<    *         sinon.int
---
>   /** Renvoie la valeur d'un paramètre de ce PML en tant que boolean.
>    * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @param value La valeur par défaut, sinon false.
>    * @return La valeur true ou false si le paramètre est égal à "true" ou "false" indépendamment de la casse, la valeur par défaut sinon.int
1054,1064c840,843
<   /**
<    * Définit la valeur d'un paramètre de ce PML.
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @param value
<    *            La valeur du paramètre (en tant que PML, object Java, entier,
<    *            décimal ou entier). Si null efface la valeur précédente.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().set(..)</tt>.
---
>   /** Définit la valeur d'un paramètre de ce PML.
>    * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @param value La valeur du paramètre (en tant que PML, object Java, entier, décimal ou entier). Si null efface la valeur précédente.
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().set(..)</tt>.
1074,1075c853
<             data.put(Integer.toString(j),
<                      data.get(Integer.toString(j + 1)));
---
>             data.put(Integer.toString(j), data.get(Integer.toString(j + 1)));
1153,1163c931,934
<   /**
<    * Elimine la valeur d'un paramètre de ce PML.
<    * <p>
<    * Cet appel est formellement équivalent à <tt>set(name, null);</tt>
<    * </p>
<    *
<    * @param name
<    *            Le nom de l'attribut ou l'index de l'élément (sous forme de
<    *            chaîne ou d'entier).
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().del(..)</tt>.
---
>   /** Elimine la valeur d'un paramètre de ce PML.
>    * <p>Cet appel est formellement équivalent à <tt>set(name, null);</tt></p>
>    * @param name  Le nom de l'attribut ou l'index de l'élément (sous forme de chaîne ou d'entier).
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().del(..)</tt>.
1174,1184c945,948
<   /**
<    * Ajoute un élément à ce PML.
<    * <p>
<    * Cet appel est formellement équivalent à <tt>set(getCount(), value);</tt>
<    * </p>
<    *
<    * @param value
<    *            La valeur du paramètre (en tant que PML, entier, décimal ou
<    *            entier).
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().add(..)</tt>.
---
>   /** Ajoute un élément à ce PML.
>    * <p>Cet appel est formellement équivalent à <tt>set(getCount(), value);</tt></p>
>    * @param value La valeur du paramètre (en tant que PML, entier, décimal ou entier).
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().add(..)</tt>.
1212,1218c976,978
<   /**
<    * Définit la valeur de paramètres de ce PML.
<    *
<    * @param pml
<    *            La structure dont on copie les paramètres
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Pml pml= new Pml().set(..)</tt>.
---
>   /**  Définit la valeur de paramètres de ce PML.
>    * @param pml La structure dont on copie les paramètres
>    * @return Cet objet, permettant de définir la construction <tt>Pml pml= new Pml().set(..)</tt>.
1235,1239c995,996
<   /**
<    * Renvoie le nombre d'éléments de ce PML.
<    *
<    * @return Le nombre d'éléments (indépendamment des attributs), les éléments
<    *         null étant éliminés
---
>   /** Renvoie le nombre d'éléments de ce PML.
>    * @return Le nombre d'éléments (indépendamment des attributs), les éléments null étant éliminés
1245c1002
<         if(Pml.isIndex(key)) {
---
>         if(isIndex(key)) {
1253,1257c1010,1011
<   /**
<    * Renvoie le nombre de paramètres de ce PML.
<    *
<    * @return Le nombre d'attributs et d'éléments. Si 0, ce PML correspond
<    *         uniquement à une chaîne: son tag.
---
>   /** Renvoie le nombre de paramètres de ce PML.
>    * @return Le nombre d'attributs et d'éléments. Si 0, ce PML correspond uniquement à une chaîne: son tag.
1262,1273c1016,1018
<   /**
<    * Définir un itérateur sur les attributs de ce PML.
<    * <p>
<    * - Les attributes sont énumérés avec une construction de la forme:
<    * <tt>for(String name : pml.attributes()) { Pml value = pml.getChild(name); .. }</tt>
<    * .
<    * </p>
<    * <p>
<    * - Les éléments sont énumérés avec une construction de la forme:
<    * <tt>for(int n = 0; n &lt; pml.getCount(); n++) { Pml value = pml.getChild(n); .. }</tt>
<    * .
<    * </p>
---
>   /** Définir un itérateur sur les attributs de ce PML.
>    * <p>- Les attributes sont énumérés avec une construction de la forme: <tt>for(String name : pml.attributes()) { Pml value = pml.getChild(name); .. }</tt>.</p>
>    * <p>- Les éléments sont énumérés avec une construction de la forme:  <tt>for(int n = 0; n &lt; pml.getCount(); n++) { Pml value = pml.getChild(n); .. }</tt>.</p>
1288,1290c1033
<                           for(key = null; keys.hasNext()
<                               && Pml.isIndex(key = keys.next()); key = null)
<                           {}
---
>                           for(key = null; keys.hasNext() && isIndex(key = keys.next()); key = null) {}
1311c1054
<     return Pml.index.matcher(name).matches();
---
>     return index.matcher(name).matches();
1315,1319c1058,1059
<   /**
<    * Renvoie les paramètres de cette PML sous forme de Properties.
<    *
<    * @return Une structure Properties contenant attributs et éléments sous
<    *         forme de chaîne de caractère.
---
>   /** Renvoie les paramètres de cette PML sous forme de Properties.
>    * @return Une structure Properties contenant attributs et éléments sous forme de chaîne de caractère.
1329,1333c1069,1070
<   /**
<    * Lanceur du mécanisme de vérification/conversion d'une PML.
<    *
<    * @param usage
<    *            <tt>java org.javascool.tools.Pml input-file [output-file.(pml|xml|php|jmf)]</tt>
---
>   /** Lanceur du mécanisme de vérification/conversion d'une PML.
>    * @param usage <tt>java org.javascool.tools.Pml input-file [output-file.(pml|xml|php|jmf)]</tt>
1337,1341c1074
<       new Pml().load(usage[0]).save(
<         usage.length > 1 ? usage[1] : "stdout:",
<         (usage.length > 1 && usage[1]
<          .matches(".*\\.(pml|php|xml|jmf)")) ? usage[1]
<         .replaceFirst(".*\\.", "") : "pml");
---
>       new Pml().load(usage[0]).save(usage.length > 1 ? usage[1] : "stdout:", (usage.length > 1 && usage[1].matches(".*\\.(pml|php|xml|jmf)")) ? usage[1].replaceFirst(".*\\.", "") : "pml");

>>> ./src/org/javascool/tools/Xml2Xml.java

6a7,9
> import java.util.HashMap;
> 
> // Used for the sax interface
9d11
< import java.util.HashMap;
11d12
< 
13,14d13
< import javax.xml.transform.TransformerConfigurationException;
< import javax.xml.transform.TransformerException;
16c15,16
< import javax.xml.transform.stream.StreamResult;
---
> import javax.xml.transform.TransformerException;
> import javax.xml.transform.TransformerConfigurationException;
17a18
> import javax.xml.transform.stream.StreamResult;
19,24c20
< /**
<  * Transforme une structure XML en une autre structure XML avec un XSLT.
<  *
<  * <p>
<  * Note: utilise <tt>saxon.jar</tt> qui doit être dans le CLASSPATH.
<  * </p>
---
> /** Transforme une structure XML en une autre structure XML avec un XSLT.
25a22
>  * <p>Note: utilise <tt>saxon.jar</tt> qui doit être dans le CLASSPATH.</p>
32,49c29,35
<   /**
<    * Convertit une chaîne XML en une autre chaîne XML selon des règles XSL.
<    *
<    * @param xml
<    *            Le nom de fichier ou la chaîne XML en entrée.
<    * @param xsl
<    *            Le nom de fichier ou la chaîne avec les règles de
<    *            transformation XSL.
<    *            <p>
<    *            - Si la chaîne commence par un <tt>&lt;</tt> elle est reconnue
<    *            comme un texte XSLT.
<    *            </p>
<    *            <p>
<    *            - Sinon elle est reconnue comme un non de fichier.
<    *            </p>
<    * @param params
<    *            Paramètres de la transformation. La valeur null indique qu'il
<    *            n'y a pas de paramètres.
---
> 
>   /** Convertit une chaîne XML en une autre chaîne XML selon des règles XSL.
>    * @param xml Le nom de fichier ou la chaîne XML en entrée.
>    * @param xsl Le nom de fichier ou la chaîne avec les règles de transformation XSL.
>    * <p> - Si la chaîne commence par un <tt>&lt;</tt> elle est reconnue comme un texte XSLT.</p>
>    * <p> - Sinon elle est reconnue comme un non de fichier.</p>
>    * @param params Paramètres de la transformation. La valeur null indique qu'il n'y a pas de paramètres.
53,56c39,40
<    * @throws IllegalArgumentException
<    *             Si une erreur de syntaxe est détecté.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si une erreur de syntaxe est détecté.
>    * @throws RuntimeException  Si une erreur d'entrée-sortie s'est produite.
61c45
<       if(!Xml2Xml.tranformers.containsKey(xsl)) {
---
>       if(!tranformers.containsKey(xsl)) {
69,70c53
<         Xml2Xml.tranformers.put(xsl,
<                                 Xml2Xml.tfactory.newTransformer(xslSource));
---
>         tranformers.put(xsl, tfactory.newTransformer(xslSource));
80c63
<       Transformer transformer = Xml2Xml.tranformers.get(xsl);
---
>       Transformer transformer = tranformers.get(xsl);
86,87c69
<             transformer
<             .setParameter(name, params.getProperty(name));
---
>             transformer.setParameter(name, params.getProperty(name));
90,91c72
<       StreamSource in = xml.trim().startsWith("<") ? new StreamSource(
<         new StringReader(xml)) : new StreamSource(xml);
---
>       StreamSource in = xml.trim().startsWith("<") ? new StreamSource(new StringReader(xml)) : new StreamSource(xml);
101c82
<     return Xml2Xml.run(xml, xsl, null);
---
>     return run(xml, xsl, null);
106,107c87
<   public static String run(String xml, String xsl, String paramName,
<                            String paramValue) {
---
>   public static String run(String xml, String xsl, String paramName, String paramValue) {
110c90
<     return Xml2Xml.run(xml, xsl, params);
---
>     return run(xml, xsl, params);
117,123c97,100
<       System.setProperty("javax.xml.parsers.SAXParserFactory",
<                          "com.icl.saxon.aelfred.SAXParserFactoryImpl");
<       System.setProperty("javax.xml.transform.TransformerFactory",
<                          "com.icl.saxon.TransformerFactoryImpl");
<       System.setProperty("javax.xml.parsers.DocumentBuilderFactory",
<                          "com.icl.saxon.om.DocumentBuilderFactoryImpl");
<       Xml2Xml.tfactory = TransformerFactory.newInstance();
---
>       System.setProperty("javax.xml.parsers.SAXParserFactory", "com.icl.saxon.aelfred.SAXParserFactoryImpl");
>       System.setProperty("javax.xml.transform.TransformerFactory", "com.icl.saxon.TransformerFactoryImpl");
>       System.setProperty("javax.xml.parsers.DocumentBuilderFactory", "com.icl.saxon.om.DocumentBuilderFactoryImpl");
>       tfactory = TransformerFactory.newInstance();
129,143c106,111
<   /**
<    * Convertit une chaîne en HTML en chaîne XHTML.
<    * <p>
<    * Elimine les entitées HTML connues (tout n'est pas implémenté) et passe à
<    * de l'accentuation liée au codage local, élimine les constructions
<    * (commentaires, instructions) qui ne sont pas structures logiques XML et
<    * ferme les balises pur avoir une syntaxe bien formée.
<    * </p>
<    * <p>
<    * C'est une commande "fragile" au sens où un text HTML mal formé ne sera
<    * pas correctement traduit.
<    * </p>
<    *
<    * @param htm
<    *            La chaîne HTML en entrée.
---
>   /** Convertit une chaîne en HTML en chaîne XHTML.
>    * <p>Elimine les entitées HTML connues (tout n'est pas implémenté) et passe à de l'accentuation liée au codage local,
>    * élimine les constructions (commentaires, instructions) qui ne sont pas structures logiques XML et
>    * ferme les balises pur avoir une syntaxe bien formée.</p>
>    * <p>C'est une commande "fragile" au sens où un text HTML mal formé ne sera pas correctement traduit.</p>
>    * @param htm La chaîne HTML en entrée.
147,158c115,131
<     return htm
<            . // Elimine les accentuation HTML
<            replaceAll("&agrave;", "à").replaceAll("&acirc;", "â")
<            .replaceAll("&eacute;", "é").replaceAll("&egrave;", "è")
<            .replaceAll("&euml;", "ë").replaceAll("&ecirc;", "ê")
<            .replaceAll("&iuml;", "ï").replaceAll("&icirc;", "î")
<            .replaceAll("&ouml;", "ö").replaceAll("&ocirc;", "ô")
<            .replaceAll("&ldquo;", "&#8220;")
<            .replaceAll("&rdquo;", "&#8221;")
<            .replaceAll("&laquo;", "&#171;")
<            .replaceAll("&raquo;", "&#172;;").replaceAll("&ugrave;", "ù")
<            .replaceAll("&ccedil;", "ç").
---
>     return htm. // Elimine les accentuation HTML
>            replaceAll("&agrave;", "à").
>            replaceAll("&acirc;", "â").
>            replaceAll("&eacute;", "é").
>            replaceAll("&egrave;", "è").
>            replaceAll("&euml;", "ë").
>            replaceAll("&ecirc;", "ê").
>            replaceAll("&iuml;", "ï").
>            replaceAll("&icirc;", "î").
>            replaceAll("&ouml;", "ö").
>            replaceAll("&ocirc;", "ô").
>            replaceAll("&ldquo;", "&#8220;").
>            replaceAll("&rdquo;", "&#8221;").
>            replaceAll("&laquo;", "&#171;").
>            replaceAll("&raquo;", "&#172;;").
>            replaceAll("&ugrave;", "ù").
>            replaceAll("&ccedil;", "ç").
160c133,134
<            replaceAll("<[!?][^>]*>", "").replaceAll("&nbsp;", "&#160;").
---
>            replaceAll("<[!?][^>]*>", "").
>            replaceAll("&nbsp;", "&#160;").
164,168c138,139
<   /**
<    * Lanceur de la transformation XML -XSLT-> XML.
<    *
<    * @param usage
<    *            <tt>java org.javascool.tools.Xml2Xml input-file XSL-file [output-file] [paramName paramValue]</tt>
---
>   /** Lanceur de la transformation XML -XSLT-> XML.
>    * @param usage <tt>java org.javascool.tools.Xml2Xml input-file XSL-file [output-file] [paramName paramValue]</tt>
173,174c144
<       FileManager.save(usage[2], Xml2Xml.run(FileManager.load(usage[0]),
<                                              usage[1], usage[3], usage[4]));
---
>       FileManager.save(usage[2], run(FileManager.load(usage[0]), usage[1], usage[3], usage[4]));
176,177c146
<       FileManager.save(usage.length > 2 ? usage[2] : "stdout:",
<                        Xml2Xml.run(FileManager.load(usage[0]), usage[1]));
---
>       FileManager.save(usage.length > 2 ? usage[2] : "stdout:", run(FileManager.load(usage[0]), usage[1]));

>>> ./src/org/javascool/tools/UserConfig.java

6a7
> import java.util.Properties;
9d9
< import java.util.Properties;
11,13c11
< /**
<  * Permet de stocker des informations dans un fichier de configuration de
<  * l'utilisateur.
---
> /** Permet de stocker des informations dans un fichier de configuration de l'utilisateur.
27,31c25,26
<   /**
<    * Renvoie le répertoire standard où stocker les données d'une application.
<    *
<    * @return Le répertoire standard où stocker les données d'une application,
<    *         ou un répertoire temporaire si celui-ci est indéfini.
---
>   /** Renvoie le répertoire standard où stocker les données d'une application.
>    * @return Le répertoire standard où stocker les données d'une application, ou un répertoire temporaire si celui-ci est indéfini.
38,39c33
<       return System.getProperty("user.home")
<              + "/Library/Application Support/" + applicationName + "/";
---
>       return System.getProperty("user.home") + "/Library/Application Support/" + applicationName + "/";
41,42c35
<       return System.getProperty("user.home") + "/." + applicationName
<              + "/";
---
>       return System.getProperty("user.home") + "/." + applicationName + "/";
44,47c37
<       System.err
<       .println("Impossible de définir un répertoire de configuration pour l'application "
<                + applicationName
<                + " sous le système d'exploitation «" + OS + "»");
---
>       System.err.println("Impossible de définir un répertoire de configuration pour l'application " + applicationName + " sous le système d'exploitation «" + OS + "»");
51,57c41,43
<   /**
<    * Lit une propriété liée à cette application.
<    *
<    * @param name
<    *            Nom de la propriété.
<    * @param value
<    *            Valeur par défaut.
---
>   /** Lit une propriété liée à cette application.
>    * @param name Nom de la propriété.
>    * @param value Valeur par défaut.
64,68c50,51
<         if(new File(getApplicationFolder() + "configuration.xml")
<            .exists())
<         {
<           properties.loadFromXML(new FileInputStream(
<                                    getApplicationFolder() + "configuration.xml"));
---
>         if(new File(getApplicationFolder() + "configuration.xml").exists()) {
>           properties.loadFromXML(new FileInputStream(getApplicationFolder() + "configuration.xml"));
71,73c54
<         System.err
<         .println("Dysfonctionnement lors la lecture du fichier de configuration de "
<                  + applicationName + " : " + e);
---
>         System.err.println("Dysfonctionnement lors la lecture du fichier de configuration de " + applicationName + " : " + e);
86,94c67,70
<   /**
<    * Ecrit une propriété liée à cette application.
<    *
<    * @param name
<    *            Nom de la propriété.
<    * @param value
<    *            Valeur de la propriété.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>UserConfig.getInstance(..).setProperty(..)</tt>.
---
>   /** Ecrit une propriété liée à cette application.
>    * @param name Nom de la propriété.
>    * @param value Valeur de la propriété.
>    * @return Cet objet, permettant de définir la construction <tt>UserConfig.getInstance(..).setProperty(..)</tt>.
102,104c78
<         properties.storeToXML(new FileOutputStream(
<                                 getApplicationFolder() + "configuration.xml"),
<                               "JavaS'Cool user configuration");
---
>         properties.storeToXML(new FileOutputStream(getApplicationFolder() + "configuration.xml"), "JavaS'Cool user configuration");
106,108c80
<         System.err
<         .println("Dysfonctionnement lors l'écriture du fichier de configuration de "
<                  + applicationName + " : " + e);
---
>         System.err.println("Dysfonctionnement lors l'écriture du fichier de configuration de " + applicationName + " : " + e);
113,117c85,86
<   /**
<    * Crée et/ou renvoie l'unique instance de l'objet.
<    * <p>
<    * Une application ne peut définir qu'un seul objet de configuration.
<    * </p>
---
>   /** Crée et/ou renvoie l'unique instance de l'objet.
>    * <p>Une application ne peut définir qu'un seul objet de configuration.</p>
120,145c89,93
<     if(UserConfig.userConfig == null) {
<       return UserConfig.userConfig = new UserConfig(
<                UserConfig.theApplicationName = applicationName);
<     } else if(UserConfig.theApplicationName.equals(applicationName)) {
<       return UserConfig.userConfig;
<     } else { throw new IllegalArgumentException(
<                      "Appel incohérent à la configuration de l'application avec deux noms différents "
<                      + UserConfig.theApplicationName
<                      + " puis "
<                      + applicationName);
<     }
<   }
<   public static String MAC_OSX = "mac";
<   public static String LINUX = "lin";
<   public static String WINDOWS = "win";
< 
<   /** Détecte le système courrant de l'utilisateur.
<    * @return L'un des drapeau de la classe (MAC_OSX, LINUX, WINDOWS)
<    */
<   public static String getOS() {
<     String os = System.getProperty("os.name").toLowerCase();
<     if(os.indexOf("win") >= 0) {
<       return WINDOWS;
<     }
<     if(os.indexOf("mac") >= 0) {
<       return MAC_OSX;
---
>     if(userConfig == null) {
>       return userConfig = new UserConfig(theApplicationName = applicationName);
>     } else if(theApplicationName.equals(applicationName)) {
>       return userConfig;
>     } else { throw new IllegalArgumentException("Appel incohérent à la configuration de l'application avec deux noms différents " + theApplicationName + " puis " + applicationName);
147d94
<     return LINUX;

>>> ./src/org/javascool/tools/Sampler.java

6a7,9
> // Used to catch exceptions
> import java.lang.RuntimeException;
> 
7a11,16
> import java.lang.Thread;
> import java.lang.Runnable;
> 
> // Used for timer management
> import java.lang.System;
> import java.lang.InterruptedException;
9,10c18
< /**
<  * Defines the implementation of a periodic task.
---
> /** Defines the implementation of a periodic task.
12,15c20,21
<  * <div>The periodic task is:
<  * <ul>
<  * <li><b>defined</b> by a runnable called at each iteration, and one parameter
<  * the <b><i>sampling-period</i></b>.</li>
---
>  * <div>The periodic task is: <ul>
>  * <li><b>defined</b> by a runnable called at each iteration, and one parameter the <b><i>sampling-period</i></b>.</li>
18,20c24,25
<  * <li><a href="#start(int)">start()</a> (re)starting the iteration. <div>User
<  * can overwrite the method with a construct of the form
<  * <tt>public void start() { &lt;specific-code> super.start(); }</tt></div></li>
---
>  * <li><a href="#start(int)">start()</a> (re)starting the iteration.
>  *  <div>User can overwrite the method with a construct of the form <tt>public void start() { &lt;specific-code> super.start(); }</tt></div></li>
22,24c27,28
<  * <li><a href="#stop()">stop()</a> which stops the iteration. <div>User can
<  * overwrite the method with a construct of the form
<  * <tt>public void stop() { super.stop(); &lt;specific-code> }</tt></div></li>
---
>  * <li><a href="#stop()">stop()</a> which stops the iteration.
>  *  <div>User can overwrite the method with a construct of the form <tt>public void stop() { super.stop(); &lt;specific-code> }</tt></div></li>
26,27c30
<  * </ul>
<  * </div>
---
>  * </ul></div>
36,40c39,41
<   /**
<    * Sets the periodic task runnable.
<    *
<    * @param runnable
<    *            The runnable to call periodically.
---
> 
>   /** Sets the periodic task runnable.
>    * @param runnable The runnable to call periodically.
47,51c48,49
<   /**
<    * Sets the periodic task sampling-period.
<    *
<    * @param delay
<    *            The periodic task delay in milli-seconds.
---
>   /** Sets the periodic task sampling-period.
>    * @param delay The periodic task delay in milli-seconds.
58c56
<   /** (Re)starts the sampling of the runnable. */
---
>   /** (Re)starts the sampling of the runnable.  */
63d60
<                            @Override
72,73c69
<                                  spareTime = delay
<                                              - (int) (System.currentTimeMillis() - t);
---
>                                  spareTime = delay - (int) (System.currentTimeMillis() - t);
75,76c71
<                                    try {
<                                      Thread.sleep(spareTime);
---
>                                    try { Thread.sleep(spareTime);
91,93c86
<   /**
<    * Returns the iteraton thread.
<    *
---
>   /** Returns the iteraton thread.
101,102c94
<   /**
<    * Pauses the iteration mechanism.
---
>   /** Pauses the iteration mechanism.
107,108c99
<   /**
<    * Resumes the iteration after a pause.
---
>   /** Resumes the iteration after a pause.
113,118c104,105
<   /**
<    * Tests if the iteration is paused
<    *
<    * @return True if the iteration has been paused via <tt>pause()</tt> false
<    *         if the iteration has been resumed via <tt>resumed()</tt> or never
<    *         paused.
---
>   /** Tests if the iteration is paused
>    * @return True if the iteration has been paused via <tt>pause()</tt> false if the iteration has been resumed via <tt>resumed()</tt> or never paused.
123,127c110,111
<   /**
<    * Returns the runtime-exception thrown by the iteration runnable.
<    *
<    * @return The runtime-exception thrown by the iteration runnable if any,
<    *         else null.
---
>   /** Returns the runtime-exception thrown by the iteration runnable.
>    * @return The runtime-exception thrown by the iteration runnable if any, else null.
134,136c118,119
<   /**
<    * Requires the sampling to stop. <div>The current iteration, if any,
<    * terminates before stopping.</div>
---
>   /** Requires the sampling to stop.
>    * <div>The current iteration, if any, terminates before stopping.</div>
142,143c125
<   /**
<    * Returns the spare-time between two samplings.
---
>   /** Returns the spare-time between two samplings.
145,152c127,131
<    * @return The last spare-time between two samplings, in milliseconds:
<    *         <ul>
<    *         <li>If negative, it indicates that the task overruns.</li>
<    *         <li>It is equal to Integer.MIN_VALUE if no iteration has been
<    *         completed.</li>
<    *         <li>It depends on both the task execution time and other thread
<    *         execution times.</li>
<    *         </ul>
---
>    * @return The last spare-time between two samplings, in milliseconds: <ul>
>    *  <li> If negative, it indicates that the task overruns.</li>
>    *  <li> It is equal to Integer.MIN_VALUE if no iteration has been completed. </li>
>    *  <li> It depends on both the task execution time and other thread execution times.</li>
>    * </ul>

>>> ./src/org/javascool/tools/ErrorCatcher.java

11d10
< 
14d12
< 
17,18c15
< /**
<  * Détecte et rapporte de manière optimisée des erreurs lors de l'exécution.
---
> /** Détecte et rapporte de manière optimisée des erreurs lors de l'exécution.
26,45c23,30
<   /**
<    * Ouvre une fenêtre d'alerte en cas d'exception intempestive et non prise
<    * en compte.
<    * <p>
<    * Installe un gestionnaire d'exception non interceptée qui recueille des
<    * informations sur: les versions des composants logiciels, le nom du
<    * process, la trace de la pile et l'affiche dans une fenêtre séparée afin
<    * d'être recueillies et communiquées par l'utilisateur.
<    * </p>
<    *
<    * @param header
<    *            Un texte entête en HTML expliquant à l'utilisateur quoi faire
<    *            avec cette sortie d'exception.
<    * @param revision
<    *            Nom et/ou numéro de révision de l'application pour avoir une
<    *            trace en cas d'erreur.
<    * @param keyword
<    *            Si différent de null, le message n'est donné à l'utilisateur
<    *            que si la trace de la pile contient le mot-clé (
<    *            <tt>org.javascool</tt> par défaut)
---
> 
>   /** Ouvre une fenêtre d'alerte en cas d'exception intempestive et non prise en compte.
>    * <p> Installe un gestionnaire d'exception non interceptée qui recueille des informations sur:
>    * les versions des composants logiciels, le nom du process, la trace de la pile et
>    * l'affiche dans une fenêtre séparée afin d'être recueillies et communiquées par l'utilisateur.</p>
>    * @param header Un texte entête en HTML expliquant à l'utilisateur quoi faire avec cette sortie d'exception.
>    * @param revision Nom et/ou numéro de révision de l'application pour avoir une trace en cas d'erreur.
>    * @param keyword Si différent de null, le message n'est donné à l'utilisateur que si la trace de la pile contient le mot-clé (<tt>org.javascool</tt> par défaut)
47,50c32,34
<   public static void setUncaughtExceptionAlert(String header,
<                                                String revision, String keyword) {
<     ErrorCatcher.uncaughtExceptionAlertHeader = header;
<     ErrorCatcher.uncaughtExceptionKeyword = keyword;
---
>   public static void setUncaughtExceptionAlert(String header, String revision, String keyword) {
>     uncaughtExceptionAlertHeader = header;
>     uncaughtExceptionKeyword = keyword;
56,62c40,42
<                                                   if(ErrorCatcher.uncaughtExceptionAlertOnce <= 1) {
<                                                     s += ErrorCatcher.uncaughtExceptionAlertHeader
<                                                          + "\n<hr><pre>";
<                                                     for(String p: new String[] { "application.revision",
<                                                                                  "java.version", "java.home", "java.class.path",
<                                                                                  "os.name", "os.arch", "os.version", "user.name",
<                                                                                  "user.home", "user.dir" }
---
>                                                   if(uncaughtExceptionAlertOnce <= 1) {
>                                                     s += uncaughtExceptionAlertHeader + "\n<hr><pre>";
>                                                     for(String p: new String[] { "application.revision", "java.version", "java.home", "java.class.path", "os.name", "os.arch", "os.version", "user.name", "user.home", "user.dir" }
67,68c47
<                                                     s += "> localhost = " + java.net.InetAddress.getLocalHost()
<                                                          + "\n";
---
>                                                     s += "> localhost = " + java.net.InetAddress.getLocalHost() + "\n";
70,71c49
<                                                   s += "> file.enc = " + org.javascool.Core.javascoolJarEnc()
<                                                        + "\n";
---
>                                                   s += "> file.enc = " + org.javascool.Core.javascoolJarEnc() + "\n";
74,76c52,53
<                                                   if(0 < ErrorCatcher.uncaughtExceptionAlertOnce) {
<                                                     s += "> count = " + ErrorCatcher.uncaughtExceptionAlertOnce
<                                                          + "\n";
---
>                                                   if(0 < uncaughtExceptionAlertOnce) {
>                                                     s += "> count = " + uncaughtExceptionAlertOnce + "\n";
80,88c57,61
<                                                     r += e.getStackTrace()[i]
<                                                          + (i < t.getStackTrace().length - 1 ? "\n" : "»");
<                                                   boolean alert = (ErrorCatcher.uncaughtExceptionKeyword == null || r
<                                                                    .indexOf(ErrorCatcher.uncaughtExceptionKeyword) != -1)
<                                                                   && (e.toString().indexOf(
<                                                                         "java.util.ConcurrentModificationException") == -1)
<                                                                   && (e.toString()
<                                                                       .indexOf(
<                                                                         "com.sun.java.swing.plaf.nimbus.DerivedColor$UIResource cannot be cast to com.sun.java.swing.Painter") == -1);
---
>                                                     r += e.getStackTrace()[i] + (i < t.getStackTrace().length - 1 ? "\n" : "»");
>                                                   boolean alert =
>                                                     (uncaughtExceptionKeyword == null || r.indexOf(uncaughtExceptionKeyword) != -1) &&
>                                                     (e.toString().indexOf("java.util.ConcurrentModificationException") == -1) &&
>                                                     (e.toString().indexOf("com.sun.java.swing.plaf.nimbus.DerivedColor$UIResource cannot be cast to com.sun.java.swing.Painter") == -1);
96,101c69,70
<                                                       if((ErrorCatcher.uncaughtExceptionAlertOnce < 3)
<                                                          && alert)
<                                                       {
<                                                         FileManager
<                                                         .load("http://javascool.gforge.inria.fr?weberroreport="
<                                                               + URLEncoder.encode(s, "utf-8"));
---
>                                                       if((uncaughtExceptionAlertOnce < 3) && alert) {
>                                                         FileManager.load("http://javascool.gforge.inria.fr?weberroreport=" + URLEncoder.encode(s, "utf-8"));
104,106c73
<                                                       System.err
<                                                       .println("Impossible de lancer l'alerte à travers le web ("
<                                                                + er + ")");
---
>                                                       System.err.println("Impossible de lancer l'alerte à travers le web (" + er + ")");
108c75
<                                                     if((ErrorCatcher.uncaughtExceptionAlertOnce == 0) && alert) {
---
>                                                     if((uncaughtExceptionAlertOnce == 0) && alert) {
111c78
<                                                     ErrorCatcher.uncaughtExceptionAlertOnce++;
---
>                                                     uncaughtExceptionAlertOnce++;
118,119c85
<     ErrorCatcher.setUncaughtExceptionAlert(header, revision,
<                                            "org.javascool");
---
>     setUncaughtExceptionAlert(header, revision, "org.javascool");
125,133c91,93
<   /**
<    * Impose une version minimale de Java.
<    * <p>
<    * Si la version n'est pas correcte, l'application s'arrête et un
<    * téléchargement est proposé.
<    * </p>
<    *
<    * @param version
<    *            Version de Java 5 pour 1.5, 6 pour 1.6.
---
>   /** Impose une version minimale de Java.
>    * <p>Si la version n'est pas correcte, l'application s'arrête et un téléchargement est proposé.</p>
>    * @param version Version de Java 5 pour 1.5, 6 pour 1.6.
137,138c97
<       if(JOptionPane.YES_OPTION == JOptionPane
<          .showConfirmDialog(
---
>       if(JOptionPane.YES_OPTION == JOptionPane.showConfirmDialog(
141,143c100
<            + "cette application requiert Java 1."
<            + version
<            + " ou plus.<br>"
---
>            + "cette application requiert Java 1." + version + " ou plus.<br>"
145,146c102,103
<            "Confirmation", JOptionPane.YES_NO_OPTION,
<            JOptionPane.ERROR_MESSAGE))
---
>            "Confirmation",
>            JOptionPane.YES_NO_OPTION, JOptionPane.ERROR_MESSAGE))

>>> ./src/org/javascool/tools/FileManager.java

7,8c7,9
< import java.awt.FileDialog;
< import java.io.BufferedReader;
---
> import java.net.URL;
> import java.util.Arrays;
> import org.javascool.macros.Macros;
10d10
< import java.io.FileOutputStream;
11a12,13
> 
> // Used for URL read
13,14c15,17
< import java.io.OutputStreamWriter;
< import java.net.URL;
---
> import java.io.BufferedReader;
> 
> // Used for URL write
15a19,22
> import java.io.OutputStreamWriter;
> import java.io.FileOutputStream;
> 
> // Used for list/exists
18,20d24
< import java.util.Arrays;
< import java.util.Enumeration;
< import java.util.jar.JarEntry;
21a26,27
> import java.util.jar.JarEntry;
> import java.util.Enumeration;
23,33c29,30
< import javax.swing.JFileChooser;
< 
< import org.javascool.macros.Macros;
< import org.javascool.widgets.MainFrame;
< 
< /**
<  * Met à disposition des fonctions de gestion de fichiers locaux et distants.
<  * <p>
<  * Lit/Ecrit un contenu textuel local ou distant en tenant compte de l'encodage
<  * local.
<  * </p>
---
> /** Met à disposition des fonctions de gestion de fichiers locaux et distants.
>  * <p>Lit/Ecrit un contenu textuel local ou distant en tenant compte de l'encodage local.</p>
42,44c39,40
<   /**
<    * Lit un contenu textuel local ou distant en tenant compte de l'encodage
<    * local.
---
> 
>   /** Lit un contenu textuel local ou distant en tenant compte de l'encodage local.
46,73c42,49
<    * @param location
<    *            Une URL (Universal Resource Location) de la forme: <div
<    *            id="load-format">
<    *            <table align="center">
<    *            <tr>
<    *            <td><tt>http:/<i>path-name</i></tt></td>
<    *            <td>pour aller chercher le contenu sur un site web</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>http:/<i>path-name</i>?param_i=value_i&amp;..</tt></td>
<    *            <td>pour le récupérer sous forme de requête HTTP</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>file:/<i>path-name</i></tt></td>
<    *            <td>pour le charger du système de fichier local ou en tant que
<    *            ressource Java dans le CLASSPATH</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>jar:/<i>jar-path-name</i>!/<i>jar-entry</i></tt></td>
<    *            <td>pour le charger d'une archive <div>(exemple:
<    *            <tt>jar:http://javascool.gforge.inria.fr/javascool.jar!/META-INF/MANIFEST.MF</tt>
<    *            )</div></td>
<    *            </tr>
<    *            </table>
<    *            </div>
<    * @param utf8
<    *            Si la valeur est vraie, force l'encodage en UTF-8 à la
<    *            lecture. Par défaut (false) utilise l'encodage local.
---
>    * @param location Une URL (Universal Resource Location) de la forme: <div id="load-format"><table align="center">
>    * <tr><td><tt>http:/<i>path-name</i></tt></td><td>pour aller chercher le contenu sur un site web</td></tr>
>    * <tr><td><tt>http:/<i>path-name</i>?param_i=value_i&amp;..</tt></td><td>pour le récupérer sous forme de requête HTTP</td></tr>
>    * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour le charger du système de fichier local ou en tant que ressource Java dans le CLASSPATH</td></tr>
>    * <tr><td><tt>jar:/<i>jar-path-name</i>!/<i>jar-entry</i></tt></td><td>pour le charger d'une archive
>    *  <div>(exemple:<tt>jar:http://javascool.gforge.inria.fr/javascool.jar!/META-INF/MANIFEST.MF</tt>)</div></td></tr>
>    * </table></div>
>    * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
75,78c51,52
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si l'URL est mal formée.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
82,85c56,57
<       BufferedReader reader = new BufferedReader(
<         new InputStreamReader(Macros.getResourceURL(location, true)
<                               .openStream(), utf8 ? Charset.forName("utf-8")
<                               : Charset.defaultCharset()), 10240);
---
>       BufferedReader reader = new BufferedReader(new InputStreamReader(Macros.getResourceURL(location, true).openStream(),
>                                                                        utf8 ? Charset.forName("utf-8") : Charset.defaultCharset()), 10240);
103c75
<     return FileManager.load(location, false);
---
>     return load(location, false);
105,107c77
<   /**
<    * Ecrit un contenu textuel local ou distant en tenant compte de l'encodage
<    * local.
---
>   /** Ecrit un contenu textuel local ou distant en tenant compte de l'encodage local.
109,142c79,88
<    * @param location
<    *            Une URL (Universal Resource Location) de la forme: <div
<    *            id="save-format">
<    *            <table>
<    *            <tr>
<    *            <td><tt>ftp:/<i>path-name</i></tt></td>
<    *            <td>pour sauver sur un site FTP.</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>file:/<i>path-name</i></tt></td>
<    *            <td>pour sauver dans le système de fichier local (le
<    *            <tt>file:</tt> est optionnel).</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>mailto:<i>address</i>?subject=<i>subject</i></tt></td>
<    *            <td>pour envoyer un courriel avec le texte en contenu.</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>stdout:/</tt></td>
<    *            <td>pour l'imprimer dans la console.</td>
<    *            </tr>
<    *            </table>
<    *            </div>
<    * @param string
<    *            Le texte à sauvegarder.
<    * @param backup
<    *            Si true, dans le cas d'un fichier, crée une sauvegarde d'un
<    *            fichier existant. Par défaut false. *
<    *            <p>
<    *            Le fichier sauvegardé est doté d'un suffixe numérique unique.
<    *            </p>
<    * @param utf8
<    *            Si la valeur est vraie, force l'encodage en UTF-8 à la
<    *            lecture. Par défaut (false) utilise l'encodage local.
---
>    * @param location Une URL (Universal Resource Location) de la forme: <div id="save-format"><table>
>    * <tr><td><tt>ftp:/<i>path-name</i></tt></td><td>pour sauver sur un site FTP.</td></tr>
>    * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour sauver dans le système de fichier local (le <tt>file:</tt> est optionnel).</td></tr>
>    * <tr><td><tt>mailto:<i>address</i>?subject=<i>subject</i></tt></td><td>pour envoyer un courriel avec le texte en contenu.</td></tr>
>    * <tr><td><tt>stdout:/</tt></td><td>pour l'imprimer dans la console.</td></tr>
>    * </table></div>
>    * @param string Le texte à sauvegarder.
>    * @param backup Si true, dans le cas d'un fichier, crée une sauvegarde d'un fichier existant. Par défaut false.
>    * * <p>Le fichier sauvegardé est doté d'un suffixe numérique unique.</p>
>    * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
144,147c90,91
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si l'URL est mal formée.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
149,150c93
<   public static void save(String location, String string, boolean backup,
<                           boolean utf8) {
---
>   public static void save(String location, String string, boolean backup, boolean utf8) {
157,159c100
<       if(location.startsWith("file:")
<          && (new File(location.substring(5)).getParentFile() != null))
<       {
---
>       if(location.startsWith("file:") && (new File(location.substring(5)).getParentFile() != null)) {
162,164c103
<       if(backup && !location.startsWith("file:")) { throw new IllegalArgumentException(
<                                                             "Impossible de procéder à un backup pour l'URL «"
<                                                             + location + "»");
---
>       if(backup && !location.startsWith("file:")) { throw new IllegalArgumentException("Impossible de procéder à un backup pour l'URL «" + location + "»");
166,168c105
<       OutputStreamWriter writer = location.startsWith("file:") ? FileManager
<                                   .getFileWriter(location.substring(5), backup, utf8)
<                                   : FileManager.getUrlWriter(location, utf8);
---
>       OutputStreamWriter writer = location.startsWith("file:") ? getFileWriter(location.substring(5), backup, utf8) : getUrlWriter(location, utf8);
179c116
<     FileManager.save(location, string, backup, false);
---
>     save(location, string, backup, false);
185c122
<     FileManager.save(location, string, false, false);
---
>     save(location, string, false, false);
188,189c125
<   private static OutputStreamWriter getUrlWriter(String location, boolean utf8)
<   throws IOException {
---
>   private static OutputStreamWriter getUrlWriter(String location, boolean utf8) throws IOException {
193,195c129,130
<     OutputStreamWriter writer = new OutputStreamWriter(
<       connection.getOutputStream(), utf8 ? Charset.forName("utf-8")
<       : Charset.defaultCharset());
---
>     OutputStreamWriter writer = new OutputStreamWriter(connection.getOutputStream(),
>                                                        utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
199,200c134
<         writer.write("Subject: " + url.toString().substring(i + 9)
<                      + "\n");
---
>         writer.write("Subject: " + url.toString().substring(i + 9) + "\n");
206,207c140
<   private static OutputStreamWriter getFileWriter(String location,
<                                                   boolean backup, boolean utf8) throws IOException {
---
>   private static OutputStreamWriter getFileWriter(String location, boolean backup, boolean utf8) throws IOException {
213c146
<       FileManager.backup(file);
---
>       backup(file);
215,216c148
<     return new OutputStreamWriter(new FileOutputStream(location),
<                                   utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
---
>     return new OutputStreamWriter(new FileOutputStream(location), utf8 ? Charset.forName("utf-8") : Charset.defaultCharset());
222c154
<       FileManager.backup(backup);
---
>       backup(backup);
226,230c158,159
<   /**
<    * Détecte si une URL existe.
<    *
<    * @param location
<    *            Une URL (Universal Resource Location).
---
>   /** Détecte si une URL existe.
>    * @param location Une URL (Universal Resource Location).
236c165
<         return FileManager.exists(new URL(location));
---
>         return exists(new URL(location));
258,265c187,189
<   /**
<    * Renvoie la date de dernière modification d'une URL si elle existe.
<    *
<    * @param location
<    *            Une URL (Universal Resource Location)
<    * @return La valeur du temps de dernière modification, donné en
<    *         millisecondes depuis le 1er janvier 1970 en temps GMT, ou 0 si la
<    *         valeur est indéfinie.
---
>   /** Renvoie la date de dernière modification d'une URL si elle existe.
>    * @param location Une URL (Universal Resource Location)
>    * @return La valeur du temps de dernière modification, donné en millisecondes depuis le 1er janvier 1970 en temps GMT, ou 0 si la valeur est indéfinie.
282,283c206,210
<   /**
<    * Renvoie les fichiers d'un répertoire ou d'un jar.
---
>   /** Renvoie les fichiers d'un répertoire ou d'un jar.
>    * @param folder Le nom du répertoire ou du fichier jar (fichier d'extension ".jar").
>    * @param pattern Une regex qui définit le type de fichier (ex : <tt>".*\.java"</tt>). Par défaut tous les fichiers.
>    * @param depth Dans le cas d'un répertoire, profondeur: 0 (défaut) pour lire dans le répertoire, 1: répertoire et sous-répertoire, etc..
>    * @return Une énumération des fichiers listés: le path canonique est renvoyé. Si le répertoire ou le jar ne peut être lu, renvoie une liste vide dans erreur.
285,301c212,213
<    * @param folder
<    *            Le nom du répertoire ou du fichier jar (fichier d'extension
<    *            ".jar").
<    * @param pattern
<    *            Une regex qui définit le type de fichier (ex :
<    *            <tt>".*\.java"</tt>). Par défaut tous les fichiers.
<    * @param depth
<    *            Dans le cas d'un répertoire, profondeur: 0 (défaut) pour lire
<    *            dans le répertoire, 1: répertoire et sous-répertoire, etc..
<    * @return Une énumération des fichiers listés: le path canonique est
<    *         renvoyé. Si le répertoire ou le jar ne peut être lu, renvoie une
<    *         liste vide dans erreur.
<    *
<    * @throws IllegalArgumentException
<    *             Si l'URL ne peut pas être listée.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si l'URL ne peut pas être listée.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
304,306c216
<     if(folder.matches("(ftp|http|https|jar):.*")) { throw new IllegalArgumentException(
<                                                             "Impossible de lister le contenu d'un URL de ce type: "
<                                                             + folder);
---
>     if(folder.matches("(ftp|http|https|jar):.*")) { throw new IllegalArgumentException("Impossible de lister le contenu d'un URL de ce type: " + folder);
314,316c224
<         for(Enumeration<JarEntry> e = new JarFile(folder).entries(); e
<             .hasMoreElements();)
<         {
---
>         for(Enumeration<JarEntry> e = new JarFile(folder).entries(); e.hasMoreElements();) {
333,334c241
<               files.addAll(Arrays.asList(FileManager.list(
<                                            file.getCanonicalPath(), pattern, depth - 1)));
---
>               files.addAll(Arrays.asList(list(file.getCanonicalPath(), pattern, depth - 1)));
346c253
<     return FileManager.list(folder, pattern, 0);
---
>     return list(folder, pattern, 0);
352c259
<     return FileManager.list(folder, null, 0);
---
>     return list(folder, null, 0);
354,361c261,263
<   /**
<    * Crée un répertoire temporaire dans le répertoire temporaire de la
<    * machine.
<    *
<    * @param prefix
<    *            Prefix du répertoire.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>   /** Crée un répertoire temporaire dans le répertoire temporaire de la machine.
>    * @param prefix Prefix du répertoire.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
370,432d271
<     }
<   }
<   /** Demande à l'utilisateur d'ouvrir un fichier.
<    * En fonction du système d'explotation, utilise la meilleur façon de demander à l'utilisateur
<    * un fichier. Actuellement AWT sous Macet SWING sous les autres.
<    * @param rep Le répertoir dans lequel se placer, laisser à null si le système doit choisir
<    * @return l'objet File contenant le fichier ou alors lance une erreur
<    * @throws java.lang.IllegalStateException Dans le cas ou l'utilisateur annule ou ne choisit pas de fichier
<    */
<   public static File openFile(String rep) {
<     if(UserConfig.getOS().equals(UserConfig.LINUX)
<        || UserConfig.getOS().equals(UserConfig.WINDOWS))   // On est sous Windows, Linux ou Solaris
<     {
<       JFileChooser fc = new JFileChooser();
<       if(rep != null) {
<         fc.setCurrentDirectory(new File(rep));
<       }
<       fc.setDialogTitle("Ouvrir un fichier");
<       fc.setApproveButtonText("Ouvrir");
<       int returnVal = fc.showOpenDialog(null);
<       if(returnVal == JFileChooser.APPROVE_OPTION) {
<         return fc.getSelectedFile();
<       } else { throw new IllegalStateException("User canceled");
<       }
<     } else { // On est sous Mac
<       FileDialog fdDialog = new FileDialog(MainFrame.getFrame(), null, FileDialog.LOAD);
<       fdDialog.setDirectory(rep);
<       fdDialog.setVisible(true);
<       if(fdDialog.getFiles().length > 0) {
<         return (fdDialog.getFiles())[0];
<       } throw new IllegalStateException("User canceled");
<     }
<   }
<   /** Demande à l'utilisateur où sauvegarder un fichier.
<    * En fonction du système d'explotation, utilise la meilleur façon de demander à l'utilisateur
<    * où sauvegarder un fichier. Actuellement AWT sous Mac et SWING sous les autres.
<    * @param saveAs Un drapeau pour déterminer si c'est Enregistrer (false) ou Enregistrer sous (true)
<    * @param rep Le répertoir dans lequel se placer, laisser à null si le système doit choisir
<    * @return l'objet File contenant le fichier ou alors lance une erreur
<    * @throws java.lang.IllegalStateException Dans le cas ou l'utilisateur annule ou ne choisit pas de fichier
<    */
<   public static File saveFile(boolean saveAs, String rep) {
<     if(UserConfig.getOS().equals(UserConfig.LINUX)
<        || UserConfig.getOS().equals(UserConfig.WINDOWS))   // On est sous Windows, Linux ou Solaris
<     {
<       JFileChooser fc = new JFileChooser();
<       if(rep != null) {
<         fc.setCurrentDirectory(new File(rep));
<       }
<       fc.setDialogTitle("Enregistrer un fichier");
<       fc.setApproveButtonText(saveAs ? "Enregistrer sous" : "Enregistrer");
<       int returnVal = fc.showOpenDialog(null);
<       if(returnVal == JFileChooser.APPROVE_OPTION) {
<         return fc.getSelectedFile();
<       } else { throw new IllegalStateException("User canceled");
<       }
<     } else { // On est sous Mac
<       FileDialog fdDialog = new FileDialog(MainFrame.getFrame(), null, FileDialog.SAVE);
<       fdDialog.setDirectory(rep);
<       fdDialog.setVisible(true);
<       if(fdDialog.getFiles().length > 0) {
<         return (fdDialog.getFiles())[0];
<       } throw new IllegalStateException("User canceled");

>>> ./src/org/javascool/macros/Stdout.java

12,22c12,14
< /**
<  * Cette factory contient des fonctions générales rendues visibles à
<  * l'utilisateur de proglets.
<  * <p>
<  * Elle permet de définir des fonctions statiques qui seront utilisées pour
<  * faire des programmes élèves.
<  * </p>
<  * <p>
<  * Elle permet aussi avoir quelques fonctions de base lors de la création de
<  * nouvelles proglets.
<  * </p>
---
> /** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
>  * <p>Elle permet de définir des fonctions statiques qui seront utilisées pour faire des programmes élèves.</p>
>  * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
30,37c22,25
<   /**
<    * Affiche dans la console une chaîne de caractères ou la représentation
<    * textuelle d'un objet sur la console. - Cette fonction ne change pas le
<    * focus de javascool.
<    *
<    * @param string
<    *            La chaine ou l'objet à afficher sous sa représentation
<    *            textuelle.
---
> 
>   /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console.
>    * - Cette fonction ne change pas le focus de javascool.
>    * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
47c35
<     Stdout.echo("" + string);
---
>     echo("" + string);
53c41
<     Stdout.echo("" + string);
---
>     echo("" + string);
59c47
<     Stdout.echo("" + string);
---
>     echo("" + string);
65c53
<     Stdout.echo("" + string);
---
>     echo("" + string);
71c59
<     Stdout.echo("" + string);
---
>     echo("" + string);
73,80c61,63
<   /**
<    * Affiche dans la console une chaîne de caractères ou la représentation
<    * textuelle d'un objet sur la console. - Cette fonction ramène le focus de
<    * javascool sur la console.
<    *
<    * @param string
<    *            La chaine ou l'objet à afficher sous sa représentation
<    *            textuelle.
---
>   /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console.
>    * - Cette fonction ramène le focus de javascool sur la console.
>    * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
84,85c67
<     // Desktop.getInstance().focusOnConsolePanel();
<     org.javascool.gui2.Desktop.getInstance().focusOnConsolePanel();
---
>     Desktop.getInstance().focusOnConsolePanel();
93c75
<     Stdout.println("" + i);
---
>     println("" + i);
99c81
<     Stdout.println("" + i);
---
>     println("" + i);
105c87
<     Stdout.println("" + d);
---
>     println("" + d);
111c93
<     Stdout.println("" + b);
---
>     println("" + b);
117c99
<     Stdout.println("" + o);
---
>     println("" + o);
119,125c101,102
<   /**
<    * Affiche dans la console une chaîne de caractères ou la représentation
<    * textuelle d'un objet sur la console sans retour à la ligne.
<    *
<    * @param string
<    *            La chaine ou l'objet à afficher sous sa représentation
<    *            textuelle.
---
>   /** Affiche dans la console une chaîne de caractères ou la représentation textuelle d'un objet sur la console sans retour à la ligne.
>    * @param string La chaine ou l'objet à afficher sous sa représentation textuelle.
135c112
<     Stdout.print("" + i);
---
>     print("" + i);
141c118
<     Stdout.print("" + i);
---
>     print("" + i);
147c124
<     Stdout.print("" + d);
---
>     print("" + d);
153c130
<     Stdout.print("" + b);
---
>     print("" + b);
159c136
<     Stdout.print("" + o);
---
>     print("" + o);
165,170c142,143
<   /**
<    * Sauve ce qui est présentement écrit dans la console dans un fichier.
<    *
<    * @param location
<    *            La localisation (chemin du fichier ou localisation internet)
<    *            où sauver le texte.
---
>   /** Sauve ce qui est présentement écrit dans la console dans un fichier.
>    * @param location La localisation (chemin du fichier ou localisation internet) où sauver le texte.

>>> ./src/org/javascool/macros/Macros.java

14,15d13
< import java.io.File;
< import java.io.IOException;
17,18d14
< import java.net.URL;
< import java.util.Calendar;
19a16
> import java.util.Calendar;
20a18,24
> 
> import org.javascool.tools.Sampler;
> import org.javascool.core.ProgletEngine;
> 
> import java.net.URL;
> import java.io.File;
> import java.io.IOException;
23,24d26
< import javax.swing.SwingUtilities;
< 
26d27
< import org.javascool.tools.Sampler;
27a29
> import javax.swing.SwingUtilities;
30,40c32,34
< /**
<  * Cette factory contient des fonctions générales rendues visibles à
<  * l'utilisateur de proglets.
<  * <p>
<  * Elle permet de définir des fonctions plus facile d'utilisation que les appels
<  * Java usuels.
<  * </p>
<  * <p>
<  * Elle permet aussi avoir quelques fonctions de base lors de la création de
<  * nouvelles proglets.
<  * </p>
---
> /** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
>  * <p>Elle permet de définir des fonctions plus facile d'utilisation que les appels Java usuels.</p>
>  * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
49,51c43,44
<   /**
<    * Renvoie un nombre entier aléatoire uniformément distribué entre deux
<    * valeurs (maximum inclus).
---
> 
>   /** Renvoie un nombre entier aléatoire uniformément distribué entre deux valeurs (maximum inclus).
56,62c49,51
<   /**
<    * Renvoie true si deux chaînes de caratères sont égales, faux sinon.
<    *
<    * @param string1
<    *            L'une des chaînes à comparer.
<    * @param string2
<    *            L'autre des chaînes à comparer.
---
>   /** Renvoie true si deux chaînes de caratères sont égales, faux sinon.
>    * @param string1 L'une des chaînes à comparer.
>    * @param string2 L'autre des chaînes à comparer.
67,72c56,57
<   /**
<    * Renvoie le temps actuel en milli-secondes.
<    *
<    * @return Renvoie la différence, en millisecondes, entre le temps actuel et
<    *         celui du 1 Janvier 2000, minuit, en utilisant le temps universel
<    *         coordonné.
---
>   /** Renvoie le temps actuel en milli-secondes.
>    * @return Renvoie la différence, en millisecondes, entre le temps actuel et celui du 1 Janvier 2000, minuit, en utilisant le temps universel coordonné.
75c60
<     return System.currentTimeMillis() - Macros.offset;
---
>     return System.currentTimeMillis() - offset;
82c67
<     Macros.offset = ref.getTimeInMillis();
---
>     offset = ref.getTimeInMillis();
85,90c70,72
<   /**
<    * Temporise une durée fixée. Cela permet aussi de mettre à jour
<    * l'affichage.
<    *
<    * @param delay
<    *            Durée d'attente en milli-secondes.
---
>   /** Temporise une durée fixée.
>    * Cela permet aussi de mettre à jour l'affichage.
>    * @param delay Durée d'attente en milli-secondes.
102,108c84,86
<   /**
<    * Excécute une routine à un intervalle régulier. Exemple d'usage
<    * (impression de 10 messages à interval d'1 sec. puis arrêt):
<    *
<    * <pre>
<    * sample(1000, new Runnable() {
<    *  public void run() {
---
>   /** Excécute une routine à un intervalle régulier.
>    * Exemple d'usage (impression de 10 messages à interval d'1 sec. puis arrêt):<pre>
>    * sample(1000, new Runnable() { public void run() {
110,112c88,89
<    *      println(&quot;Et de &quot; + (++count) + &quot; !&quot;);
<    *    } else
<    *      throw new RuntimeException(&quot;done!&quot;);
---
>    *      println("Et de "+(++count)+" !");
>    *    } else throw new RuntimeException("done!");
114d90
<    *
116,125c92,95
<    * });
<    * </pre>
<    * <p>
<    * Noter que le runnable doit être interrompu par le jet d'une exception,
<    * sinon il tournera sans relâche jusqu'à la fermeture de javascool.
<    *
<    * @param delay
<    *            Période d'échantillonage en milli-secondes.
<    * @param runnable
<    *            Le code à exécuter à chaque appel.
---
>    * });</pre>
>    * <p> Noter que le runnable doit être interrompu par le jet d'une exception, sinon il tournera sans relâche jusqu'à la fermeture de javascool.
>    * @param delay Période d'échantillonage en milli-secondes.
>    * @param runnable Le code à exécuter à chaque appel.
131,155c101,115
<   /**
<    * Vérifie une assertion et arrête le code si elle est fausse. Le diagnoctic
<    * apparait sous la forme:
<    *
<    * <pre>
<    * Arrêt du programme :{
<    *   L'assertion(«<i>message</i>») est fausse.
<    *   Pile d'exécution: {
<    *    <i>fonctions appellées et ligne de code correspondant</i>
<    *   }
<    *   Objet en cause:{
<    *      class = «<i>type de l'objet</i>»
<    *      value = «<i>valeur de l'objet</i>»
<    *   }
<    * }
<    * </pre>
<    *
<    * @param condition
<    *            Si la condition n'est pas vérifiée, le code JavaScool va
<    *            s'arrêter.
<    * @param message
<    *            Un message s'imprime sur la console pour signaler l'erreur.
<    * @param object
<    *            Si l'objet n'est pas null, donne des renseignements sur
<    *            l'objet
---
>   /** Vérifie une assertion et arrête le code si elle est fausse.
>    * Le diagnoctic apparait sous la forme:
>    ***<pre>Arrêt du programme :{
>    *  L'assertion(«<i>message</i>») est fausse.
>    *  Pile d'exécution: {
>    *   <i>fonctions appellées et ligne de code correspondant</i>
>    *  }
>    *  Objet en cause:{
>    *     class = «<i>type de l'objet</i>»
>    *     value = «<i>valeur de l'objet</i>»
>    *  }
>    ***}</pre>
>    * @param condition Si la condition n'est pas vérifiée, le code JavaScool va s'arrêter.
>    * @param message Un message s'imprime sur la console pour signaler l'erreur.
>    * @param object Si l'objet n'est pas null, donne des renseignements sur l'objet
157,158c117
<   public static void assertion(boolean condition, String message,
<                                Object object) {
---
>   public static void assertion(boolean condition, String message, Object object) {
161,162c120
<       System.out.println("Arrêt du programme :{\n  L'assertion(«"
<                          + message + "») est fausse.\n  Pile d'exécution: {");
---
>       System.out.println("Arrêt du programme :{\n  L'assertion(«" + message + "») est fausse.\n  Pile d'exécution: {");
165,166c123
<       // - moins les trois appels run() du bas de pile qui ont lancés la
<       // proglet
---
>       // - moins les trois appels run() du bas de pile qui ont lancés la proglet
168,169c125
<         StackTraceElement where[] = Thread.currentThread()
<                                     .getStackTrace();
---
>         StackTraceElement where[] = Thread.currentThread().getStackTrace();
171,176c127
<           System.out.println("     "
<                              + where[i]
<                              .toString()
<                              .replaceAll("JvsToJavaTranslated[0-9]+\\.",
<                                          "")
<                              .replaceAll("java:([0-9]+)", "ligne : $1"));
---
>           System.out.println("     " + where[i].toString().replaceAll("JvsToJavaTranslated[0-9]+\\.", "").replaceAll("java:([0-9]+)", "ligne : $1"));
180,182c131
<         System.out.println("  Objet en cause:{\n    class = «"
<                            + object.getClass() + "»\n    value = «" + object
<                            + "»\n  }");
---
>         System.out.println("  Objet en cause:{\n    class = «" + object.getClass() + "»\n    value = «" + object + "»\n  }");
193c142
<     Macros.assertion(condition, message, null);
---
>     assertion(condition, message, null);
195,206c144,147
<   /**
<    * Affiche un message dans une fenêtre présentée à l'utilisateur.
<    * <p>
<    * Le message s'affiche sous une forme "copiable" pour que l'utilisateur
<    * puisse le copier/coller.
<    * </p>
<    *
<    * @param text
<    *            Le message à afficher.
<    * @param html
<    *            Mettre à true si le texte est en HTML, false sinon (valeur par
<    *            défaut)
---
>   /** Affiche un message dans une fenêtre présentée à l'utilisateur.
>    * <p>Le message s'affiche sous une forme "copiable" pour que l'utilisateur puisse le copier/coller.</p>
>    * @param text Le message à afficher.
>    * @param html Mettre à true si le texte est en HTML, false sinon (valeur par défaut)
217,237c158,173
<     Macros.messageDialog = new Dialog();
<     Macros.messageDialog.setTitle("Java's Cool message");
<     Macros.messageDialog.setMinimumSize(new Dimension(300, 100));
<     Macros.messageDialog.add(p);
<     Macros.messageDialog.add(new JButton("OK") {
<                                /**
<                                 *
<                                 */
<                                private static final long serialVersionUID = -777885713184033186L;
< 
<                                {
<                                  addActionListener(new ActionListener() {
<                                                      @Override
<                                                      public void actionPerformed(ActionEvent e) {
<                                                        Macros.messageDialog.close();
<                                                      }
<                                                    }
<                                                    );
<                                }
<                              }, BorderLayout.SOUTH);
<     Macros.messageDialog.open(!SwingUtilities.isEventDispatchThread());
---
>     messageDialog = new Dialog();
>     messageDialog.setTitle("Java's Cool message");
>     messageDialog.setMinimumSize(new Dimension(300, 100));
>     messageDialog.add(p);
>     messageDialog.add(new JButton("OK") {
>                         {
>                           addActionListener(new ActionListener() {
>                                               @Override
>                                               public void actionPerformed(ActionEvent e) {
>                                                 messageDialog.close();
>                                               }
>                                             }
>                                             );
>                         }
>                       }, BorderLayout.SOUTH);
>     messageDialog.open(!SwingUtilities.isEventDispatchThread());
245c181
<     Macros.message(text, false);
---
>     message(text, false);
247,252c183,184
<   /**
<    * Renvoie une icone stockée dans le JAR de l'application.
<    *
<    * @param path
<    *            Emplacement de l'icone, par exemple
<    *            <tt>"org/javascool/widget/icons/play.png"</tt>
---
>   /** Renvoie une icone stockée dans le JAR de l'application.
>    * @param path Emplacement de l'icone, par exemple <tt>"org/javascool/widget/icons/play.png"</tt>
256c188
<     URL icon = Macros.getResourceURL(path); // Thread.currentThread().getContextClassLoader().getResource(path);
---
>     URL icon = getResourceURL(path);   // Thread.currentThread().getContextClassLoader().getResource(path);
262,266c194,195
<   /**
<    * Ouvre une URL (Universal Resource Location) dans un navigateur extérieur.
<    *
<    * @param location
<    *            L'URL à afficher.
---
>   /** Ouvre une URL (Universal Resource Location) dans un navigateur extérieur.
>    * @param location L'URL à afficher.
268,271c197,198
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si l'URL est mal formée.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
275,277c202
<       if(Desktop.isDesktopSupported()
<          && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE))
<       {
---
>       if(Desktop.isDesktopSupported() && Desktop.getDesktop().isSupported(Desktop.Action.BROWSE)) {
279,280c204
<         System.err.println("Note: Ouverture de " + location
<                            + " dans un navigateur externe");
---
>         System.err.println("Note: Ouverture de " + location + " dans un navigateur externe");
282c206
<         Macros.openURL2(location);
---
>         openURL2(location);
285c209
<       Macros.openURL2(location);
---
>       openURL2(location);
290,291c214
<     System.err.println("Note: Ouverture de " + location
<                        + " dans un browser navigateur (methode de secours)");
---
>     System.err.println("Note: Ouverture de " + location + " dans un browser navigateur (methode de secours)");
301,302c224
<         // Do a best guess on unix until we get a platform independent
<         // way
---
>         // Do a best guess on unix until we get a platform independent way
304,307c226,228
<         String[] browsers = { "epiphany", "firefox", "mozilla",
<                               "konqueror", "netscape", "opera", "links", "lynx" };
<         // Build a command string which looks like
<         // "browser1 "url" || browser2 "url" ||..."
---
>         String[] browsers = { "epiphany", "firefox", "mozilla", "konqueror",
>                               "netscape", "opera", "links", "lynx" };
>         // Build a command string which looks like "browser1 "url" || browser2 "url" ||..."
310,311c231
<           cmd.append(i == 0 ? "" : " || ").append(browsers[i])
<           .append(" \"").append(url).append("\" ");
---
>           cmd.append(i == 0 ? "" : " || ").append(browsers[i]).append(" \"").append(url).append("\" ");
314,316c234
<       } else { throw new RuntimeException(
<                        "Erreur (pas d'OS détecté) à l'ouverture dans un navigateur de "
<                        + location);
---
>       } else { throw new RuntimeException("Erreur (pas d'OS détecté) à l'ouverture dans un navigateur de " + location);
318,319c236
<     } catch(Exception e) { throw new RuntimeException("Erreur (" + e
<                                                       + ") à l'ouverture dans un navigateur de " + location);
---
>     } catch(Exception e) { throw new RuntimeException("Erreur (" + e + ") à l'ouverture dans un navigateur de " + location);
322,341c239,248
<   /**
<    * Renvoie une URL (Universal Resource Location) normalisée, dans le cas du
<    * système de fichier local ou d'une ressource.
<    * <p>
<    * La fonction recherche l'existence du fichier: (i) par rapport au
<    * répertoire de base qui est donné, (ii) par rapport au dossier de travaul
<    * "user.dir", (iii) par rapport à la racine des fichier "user.home", (iv)
<    * dans les ressources du CLASSPATH.
<    * </p>
<    *
<    * @param location
<    *            L'URL à normaliser.
<    * @param base
<    *            Un répertoire de réference pour la normalisation. Par défaut
<    *            null.
<    * @param reading
<    *            Précise si nous sommes en lecture (true) ou écriture (false).
<    *            Par défaut en lecture.
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
---
>   /** Renvoie une URL (Universal Resource Location) normalisée, dans le cas du système de fichier local ou d'une ressource.
>    * <p>La fonction recherche l'existence du fichier:
>    * (i) par rapport au répertoire de base qui est donné,
>    * (ii) par rapport au dossier de travaul "user.dir",
>    * (iii) par rapport à la racine des fichier "user.home",
>    * (iv) dans les ressources du CLASSPATH.</p>
>    * @param location L'URL à normaliser.
>    * @param base     Un répertoire de réference pour la normalisation. Par défaut null.
>    * @param reading  Précise si nous sommes en lecture (true) ou écriture (false). Par défaut en lecture.
>    * @throws IllegalArgumentException Si l'URL est mal formée.
343,344c250
<   public static URL getResourceURL(String location, String base,
<                                    boolean reading) {
---
>   public static URL getResourceURL(String location, String base, boolean reading) {
352,353c258
<         URL url = Thread.currentThread().getContextClassLoader()
<                   .getResource(res);
---
>         URL url = Thread.currentThread().getContextClassLoader().getResource(res);
356,357c261
<         } else { throw new IllegalArgumentException("Unable to find " + res
<                                                     + " from " + location + " as a classpath resource");
---
>         } else { throw new IllegalArgumentException("Unable to find " + res + " from " + location + " as a classpath resource");
379,380c283
<         URL url = Thread.currentThread().getContextClassLoader()
<                   .getResource(location);
---
>         URL url = Thread.currentThread().getContextClassLoader().getResource(location);
386,389c289,290
<     } catch(IOException e) { throw new IllegalArgumentException(e + " : " + location
<                                                                 + " is a malformed URL");
<     } catch(URISyntaxException e) { throw new IllegalArgumentException(e + " : " + location
<                                                                        + " is a malformed URL");
---
>     } catch(IOException e) { throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
>     } catch(URISyntaxException e) { throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
396c297
<     return Macros.getResourceURL(location, base, true);
---
>     return getResourceURL(location, base, true);
402c303
<     return Macros.getResourceURL(location, null, reading);
---
>     return getResourceURL(location, null, reading);
408c309
<     return Macros.getResourceURL(location, null, true);
---
>     return getResourceURL(location, null, true);
410,414c311,312
<   /**
<    * Renvoie le panneau graphique de la proglet courante.
<    *
<    * @return Le panneau graphique de la proglet courante ou null si il n'est
<    *         pas défini.
---
>   /** Renvoie le panneau graphique de la proglet courante.
>    * @return Le panneau graphique de la proglet courante ou null si il n'est pas défini.
416,417d313
<   @SuppressWarnings("unchecked")
<   // On évite l'erreur de Cast du compilateur

>>> ./src/org/javascool/macros/Stdin.java

11,16d10
< import java.awt.event.InputEvent;
< import java.awt.event.KeyEvent;
< import java.awt.event.KeyListener;
< import java.awt.event.MouseEvent;
< import java.awt.event.MouseListener;
< 
21d14
< 
24,34c17,24
< /**
<  * Cette factory contient des fonctions générales rendues visibles à
<  * l'utilisateur de proglets.
<  * <p>
<  * Elle permet de définir des fonctions statiques qui seront utilisées pour
<  * faire des programmes élèves.
<  * </p>
<  * <p>
<  * Elle permet aussi avoir quelques fonctions de base lors de la création de
<  * nouvelles proglets.
<  * </p>
---
> import java.awt.event.MouseListener;
> import java.awt.event.MouseEvent;
> import java.awt.event.KeyListener;
> import java.awt.event.KeyEvent;
> 
> /** Cette factory contient des fonctions générales rendues visibles à l'utilisateur de proglets.
>  * <p>Elle permet de définir des fonctions statiques qui seront utilisées pour faire des programmes élèves.</p>
>  * <p>Elle permet aussi avoir quelques fonctions de base lors de la création de nouvelles proglets.</p>
42,46c32,34
<   /**
<    * Lit une chaîne de caractère dans une fenêtre présentée à l'utilisateur.
<    *
<    * @param question
<    *            Une invite qui décrit la valeur à entrer (optionel).
---
> 
>   /** Lit une chaîne de caractère dans une fenêtre présentée à l'utilisateur.
>    * @param question Une invite qui décrit la valeur à entrer (optionel).
50,51c38,39
<     if(Stdin.inputBuffer.isPopable()) {
<       return Stdin.inputBuffer.popString();
---
>     if(inputBuffer.isPopable()) {
>       return inputBuffer.popString();
53,83c41,58
<     Stdin.inputQuestion = question;
<     Stdin.inputString = null;
<     Stdin.inputDialog = new Dialog();
<     Stdin.inputDialog.setTitle("Java's Cool read");
<     Stdin.inputDialog.add(new JPanel() {
<                             /**
<                              *
<                              */
<                             private static final long serialVersionUID = -5892042920567248401L;
< 
<                             {
<                               add(new JLabel(Stdin.inputQuestion + " "));
<                               add(new JTextField(40) {
<                                     /**
<                                      *
<                                      */
<                                     private static final long serialVersionUID = -877837293331380204L;
< 
<                                     {
<                                       addActionListener(new ActionListener() {
<                                                           @Override
<                                                           public void actionPerformed(ActionEvent e) {
<                                                             Stdin.inputString = ((JTextField) e.getSource())
<                                                                                 .getText();
<                                                             Stdin.inputDialog.close();
<                                                           }
<                                                         }
<                                                         );
<                                     }
<                                   }
<                                   );
---
>     inputQuestion = question;
>     inputString = null;
>     inputDialog = new Dialog();
>     inputDialog.setTitle("Java's Cool read");
>     inputDialog.add(new JPanel() {
>                       {
>                         add(new JLabel(inputQuestion + " "));
>                         add(new JTextField(40) {
>                               {
>                                 addActionListener(new ActionListener() {
>                                                     @Override
>                                                     public void actionPerformed(ActionEvent e) {
>                                                       inputString = ((JTextField) e.getSource()).getText();
>                                                       inputDialog.close();
>                                                     }
>                                                   }
>                                                   );
>                               }
85,88c60,65
<                           }
<                           );
<     Stdin.inputDialog.open(true);
<     return Stdin.inputString == null ? "" : Stdin.inputString;
---
>                             );
>                       }
>                     }
>                     );
>     inputDialog.open(true);
>     return inputString == null ? "" : inputString;
97c74
<     return Stdin.readString("Entrez une chaîne :");
---
>     return readString("Entrez une chaîne :");
99,103c76,77
<   /**
<    * Lit un nombre entier dans une fenêtre présentée à l'utilisateur.
<    *
<    * @param question
<    *            Une invite qui décrit la valeur à entrer (optionel).
---
>   /** Lit un nombre entier dans une fenêtre présentée à l'utilisateur.
>    * @param question Une invite qui décrit la valeur à entrer (optionel).
107,108c81,82
<     if(Stdin.inputBuffer.isPopable()) {
<       return Stdin.inputBuffer.popInteger();
---
>     if(inputBuffer.isPopable()) {
>       return inputBuffer.popInteger();
110c84
<     String s = Stdin.readString(question);
---
>     String s = readString(question);
120c94
<       return Stdin.readInteger(question);
---
>       return readInteger(question);
127c101
<     return Stdin.readInteger("Entrez un nombre entier : ");
---
>     return readInteger("Entrez un nombre entier : ");
133c107
<     return Stdin.readInteger(question);
---
>     return readInteger(question);
139c113
<     return Stdin.readInteger();
---
>     return readInteger();
141,145c115,116
<   /**
<    * Lit un nombre décimal dans une fenêtre présentée à l'utilisateur.
<    *
<    * @param question
<    *            Une invite qui décrit la valeur à entrer (optionel).
---
>   /** Lit un nombre décimal dans une fenêtre présentée à l'utilisateur.
>    * @param question Une invite qui décrit la valeur à entrer (optionel).
149,150c120,121
<     if(Stdin.inputBuffer.isPopable()) {
<       return Stdin.inputBuffer.popDecimal();
---
>     if(inputBuffer.isPopable()) {
>       return inputBuffer.popDecimal();
152c123
<     String s = Stdin.readString(question);
---
>     String s = readString(question);
162c133
<       return Stdin.readDecimal(question);
---
>       return readDecimal(question);
169c140
<     return Stdin.readDecimal("Entrez un nombre décimal : ");
---
>     return readDecimal("Entrez un nombre décimal : ");
175c146
<     return Stdin.readDecimal(question);
---
>     return readDecimal(question);
181c152
<     return Stdin.readDecimal();
---
>     return readDecimal();
187c158
<     return Stdin.readDecimal(question);
---
>     return readDecimal(question);
193c164
<     return Stdin.readDecimal();
---
>     return readDecimal();
195,199c166,167
<   /**
<    * Lit une valeur booléenne dans une fenêtre présentée à l'utilisateur.
<    *
<    * @param question
<    *            Une invite qui décrit la valeur à entrer (optionel).
---
>   /** Lit une valeur booléenne dans une fenêtre présentée à l'utilisateur.
>    * @param question Une invite qui décrit la valeur à entrer (optionel).
203,204c171,172
<     if(Stdin.inputBuffer.isPopable()) {
<       return Stdin.inputBuffer.popBoolean();
---
>     if(inputBuffer.isPopable()) {
>       return inputBuffer.popBoolean();
206,253c174,191
<     Stdin.inputQuestion = question;
<     Stdin.inputString = null;
<     Stdin.inputDialog = new Dialog();
<     Stdin.inputDialog.setTitle("Java's Cool read");
<     Stdin.inputDialog.add(new JPanel() {
<                             /**
<                              *
<                              */
<                             private static final long serialVersionUID = -3550776051477271733L;
< 
<                             {
<                               add(new JLabel(Stdin.inputQuestion + " "));
<                               add(new JButton("OUI") {
<                                     /**
<                                      *
<                                      */
<                                     private static final long serialVersionUID = 1846013448517515880L;
< 
<                                     {
<                                       addActionListener(new ActionListener() {
<                                                           @Override
<                                                           public void actionPerformed(ActionEvent e) {
<                                                             Stdin.inputString = "OUI";
<                                                             Stdin.inputDialog.close();
<                                                           }
<                                                         }
<                                                         );
<                                     }
<                                   }
<                                   );
<                               add(new JButton("NON") {
<                                     /**
<                                      *
<                                      */
<                                     private static final long serialVersionUID = -5759851092046561872L;
< 
<                                     {
<                                       addActionListener(new ActionListener() {
<                                                           @Override
<                                                           public void actionPerformed(ActionEvent e) {
<                                                             Stdin.inputString = "NON";
<                                                             Stdin.inputDialog.close();
<                                                           }
<                                                         }
<                                                         );
<                                     }
<                                   }
<                                   );
---
>     inputQuestion = question;
>     inputString = null;
>     inputDialog = new Dialog();
>     inputDialog.setTitle("Java's Cool read");
>     inputDialog.add(new JPanel() {
>                       {
>                         add(new JLabel(inputQuestion + " "));
>                         add(new JButton("OUI") {
>                               {
>                                 addActionListener(new ActionListener() {
>                                                     @Override
>                                                     public void actionPerformed(ActionEvent e) {
>                                                       inputString = "OUI";
>                                                       inputDialog.close();
>                                                     }
>                                                   }
>                                                   );
>                               }
255,258c193,211
<                           }
<                           );
<     Stdin.inputDialog.open(true);
<     return "OUI".equals(Stdin.inputString);
---
>                             );
>                         add(new JButton("NON") {
>                               {
>                                 addActionListener(new ActionListener() {
>                                                     @Override
>                                                     public void actionPerformed(ActionEvent e) {
>                                                       inputString = "NON";
>                                                       inputDialog.close();
>                                                     }
>                                                   }
>                                                   );
>                               }
>                             }
>                             );
>                       }
>                     }
>                     );
>     inputDialog.open(true);
>     return "OUI".equals(inputString);
264c217
<     return Stdin.readBoolean("Entrez une valeur booléenne (oui/non) : ");
---
>     return readBoolean("Entrez une valeur booléenne (oui/non) : ");
270c223
<     return Stdin.readBoolean(question);
---
>     return readBoolean(question);
276c229
<     return Stdin.readBoolean();
---
>     return readBoolean();
278,283c231,232
<   /**
<    * Charge une chaine de caractère pour que son contenu serve d'entrée à la
<    * console.
<    *
<    * @param string
<    *            La chaine de caractère à ajouter.
---
>   /** Charge une chaine de caractère pour que son contenu serve d'entrée à la console.
>    * @param string La chaine de caractère à ajouter.
286c235
<     Stdin.inputBuffer.add(string);
---
>     inputBuffer.add(string);
288,294c237,238
<   /**
<    * Charge le contenu d'un fichier pour que son contenu serve d'entrée à la
<    * console.
<    *
<    * @param location
<    *            La localisation (chemin du fichier ou localisation internet)
<    *            d'où charger le texte.
---
>   /** Charge le contenu d'un fichier pour que son contenu serve d'entrée à la console.
>    * @param location La localisation (chemin du fichier ou localisation internet) d'où charger le texte.
297c241
<     Stdin.addConsoleInput(org.javascool.tools.FileManager.load(location));
---
>     addConsoleInput(org.javascool.tools.FileManager.load(location));
299,302c243
<   /**
<    * Définit une zone tampon qui permet de substituer un fichier aux lectures
<    * au clavier.
<    */
---
>   /** Définit une zone tampon qui permet de substituer un fichier aux lectures au clavier. */
306,310c247,248
<     /**
<      * Ajoute une chaîne en substitution d'une lecture au clavier.
<      *
<      * @param string
<      *            Le texte à ajouter.
---
>     /** Ajoute une chaîne en substitution d'une lecture au clavier.
>      * @param string Le texte à ajouter.
315,317c253
<     /**
<      * Teste si il y une chaîne disponible.
<      *
---
>     /** Teste si il y une chaîne disponible.
323,327c259,260
<     /**
<      * Récupére une chaîne en substitution d'une lecture au clavier.
<      *
<      * @return Le texte suivant à considérer. Ou la chaîne vide si le tampon
<      *         est vide.
---
>     /** Récupére une chaîne en substitution d'une lecture au clavier.
>      * @return Le texte suivant à considérer. Ou la chaîne vide si le tampon est vide.
368d300
< 
371,384c303,306
<   /**
<    * Définit une portion de code appelée à chaque entrée d'un caractère au
<    * clavier.
<    * <p>
<    * Les caractères du clavier ne sont détectés que si la souris est sur la
<    * fenêtre de la proglet de façon à ce qu'elle est le focus.
<    * </p>
<    * <p>
<    * Les caractères du clavier et quelques touches de contrôle sont gérés.
<    * </p>
<    *
<    * @param runnable
<    *            La portion de code à appeler, ou null pour annuler l'appel à
<    *            la portion de code précédent.
---
>   /** Définit une portion de code appelée à chaque entrée d'un caractère au clavier.
>    * <p>Les caractères du clavier ne sont détectés que si la souris est sur la fenêtre de la proglet de façon à ce qu'elle est le focus.</p>
>    * <p>Les caractères du clavier et quelques touches de contrôle sont gérés.</p>
>    * @param runnable La portion de code à appeler, ou null pour annuler l'appel à la portion de code précédent.
387,388c309,310
<     if(Stdin.keyKeyListener != null) {
<       Macros.getProgletPane().removeKeyListener(Stdin.keyKeyListener);
---
>     if(keyKeyListener != null) {
>       Macros.getProgletPane().removeKeyListener(keyKeyListener);
390,391c312,313
<     if(Stdin.keyMouseListener != null) {
<       Macros.getProgletPane().removeMouseListener(Stdin.keyMouseListener);
---
>     if(keyMouseListener != null) {
>       Macros.getProgletPane().removeMouseListener(keyMouseListener);
393,456c315,354
<     if(Macros.getProgletPane() != null
<        && (Stdin.keyListenerRunnable = runnable) != null)
<     {
<       Macros.getProgletPane().addMouseListener(
<         Stdin.keyMouseListener = new MouseListener() {
<           @Override
<           public void mousePressed(MouseEvent e) {}
< 
<           @Override
<           public void mouseReleased(MouseEvent e) {}
< 
<           @Override
<           public void mouseClicked(MouseEvent e) {}
< 
<           @Override
<           public void mouseEntered(MouseEvent e) {
<             Macros.getProgletPane().requestFocusInWindow();
<           }
< 
<           @Override
<           public void mouseExited(MouseEvent e) {}
<         }
<         );
<       Macros.getProgletPane().addKeyListener(
<         Stdin.keyKeyListener = new KeyListener() {
<           @Override
<           public void keyPressed(KeyEvent e) {}
< 
<           @Override
<           public void keyReleased(KeyEvent e) {
<             String s = KeyEvent.getKeyText(e.getKeyCode());
<             if((e.getModifiers() & InputEvent.CTRL_MASK) != 0) {
<               Stdin.lastKey = "Ctrl+" + s;
<             } else {
<               int c = e.getKeyChar();
<               if((32 <= c) && (c < 127)) {
<                 Stdin.lastKey = "" + e.getKeyChar();
<               } else {
<                 if("Shift".equals(s) || "Ctrl".equals(s)) {
<                   return;
<                 }
<                 Stdin.lastKey = s;
<               }
<             }
<             if(Stdin.keyListenerRunnable != null) {
<               Stdin.keyListenerRunnable.run();
<             }
<           }
< 
<           @Override
<           public void keyTyped(KeyEvent e) {}
<         }
<         );
<     }
<   }
<   /**
<    * Renvoie la dernière touche entrée au clavier ou la chaine vide sinon.
<    *
<    * @return Renvoie le caractère associée à la touche si il est défini, sinon
<    *         une chaîne qui représente le caractère de contrôle, par exemple
<    *         'Left', 'Up, 'Right', 'Down' pour les flèches, 'F1, 'F2', .. pour
<    *         les touches de fonctions, 'Alt', 'Escape', 'Backspace', 'Enter',
<    *         'Page Down', 'Page Up', 'Home', 'end' pour les autres touches,
<    *         'Ctrl+A' pour la combinaison de la touche 'Control' et 'A', etc.
---
>     if(Macros.getProgletPane() != null&& (keyListenerRunnable = runnable) != null) {
>       Macros.getProgletPane().addMouseListener(keyMouseListener = new MouseListener() {
>                                                  public void mousePressed(MouseEvent e) {}
>                                                  public void mouseReleased(MouseEvent e) {}
>                                                  public void mouseClicked(MouseEvent e) {}
>                                                  public void mouseEntered(MouseEvent e) {
>                                                    Macros.getProgletPane().requestFocusInWindow();
>                                                  }
>                                                  public void mouseExited(MouseEvent e) {}
>                                                }
>                                                );
>       Macros.getProgletPane().addKeyListener(keyKeyListener = new KeyListener() {
>                                                public void keyPressed(KeyEvent e) {}
>                                                public void keyReleased(KeyEvent e) {
>                                                  String s = KeyEvent.getKeyText(e.getKeyCode());
>                                                  if((e.getModifiers() & KeyEvent.CTRL_MASK) != 0) {
>                                                    lastKey = "Ctrl+" + s;
>                                                  } else {
>                                                    int c = e.getKeyChar();
>                                                    if((32 <= c) && (c < 127)) {
>                                                      lastKey = "" + e.getKeyChar();
>                                                    } else {
>                                                      if("Shift".equals(s) || "Ctrl".equals(s)) {
>                                                        return;
>                                                      }
>                                                      lastKey = s;
>                                                    }
>                                                  }
>                                                  if(keyListenerRunnable != null) {
>                                                    keyListenerRunnable.run();
>                                                  }
>                                                }
>                                                public void keyTyped(KeyEvent e) {}
>                                              }
>                                              );
>     }
>   }
>   /** Renvoie la dernière touche entrée au clavier ou la chaine vide sinon.
>    * @return Renvoie le caractère associée à la touche si il est défini, sinon une chaîne qui représente le caractère de contrôle,
>    * par exemple 'Left', 'Up, 'Right', 'Down' pour les flèches, 'F1, 'F2', .. pour les touches de fonctions, 'Alt', 'Escape', 'Backspace', 'Enter', 'Page Down', 'Page Up', 'Home', 'end' pour les autres touches, 'Ctrl+A' pour la combinaison de la touche 'Control' et 'A', etc.
459c357
<     return Stdin.lastKey;
---
>     return lastKey;
465a364
> 

>>> ./src/org/javascool/About.java

5d4
< 
7d5
< 
10,11c8
< /**
<  * Définit le panneau de "about" de javascool et son bouton d'ouverture.
---
> /** Définit le panneau de "about" de javascool et son bouton d'ouverture.
18c15
<   public static String title = "Java's Cool 4";
---
>   public static final String title = "Java's Cool 4";
22,27c19,20
<   /** Numéro de révision de l'application. */
<   public static final String revision = "4.0.1084"; // @revision
<   // automatiquement mis à
<   // jour par ant -f
<   // work/build.xml
<   // classes
---
>   /** Numéro de révision de l'application.*/
>   public static final String revision = "4.0.1127"; // @revision automatiquement mis à jour par ant -f work/build.xml classes
31,42c24,30
<     Macros.message(
<       About.title
<       + " ("
<       + About.revision
<       + ") est un logiciel conçu par : <br/><center>"
<       + "Philippe VIENNE<br/>"
<       + "Guillaume MATHERON<br/>"
<       + " et Inria<br/>"
<       + "</center>"
<       + "en collaboration avec David Pichardie, Philippe Lucaud, etc.. et le conseil de Robert Cabane<br/><br/>"
<       + "Il est distribué sous les conditions de la licence CeCILL et GNU GPL V3<br/>",
<       true);
---
>     Macros.message(title + " (" + revision + ") est un logiciel conçu par : <br/><center>"
>                    + "Philippe VIENNE<br/>"
>                    + "Guillaume MATHERON<br/>"
>                    + " et Inria<br/>"
>                    + "</center>"
>                    + "en collaboration avec David Pichardie, Philippe Lucaud, etc.. et le conseil de Robert Cabane<br/><br/>"
>                    + "Il est distribué sous les conditions de la licence CeCILL et GNU GPL V3<br/>", true);
44,47c32
<   /**
<    * Renvoie une bouton (sous forme de logo) qui affiche le panneau de about
<    * lors de son clic.
<    */
---
>   /** Renvoie une bouton (sous forme de logo) qui affiche le panneau de about lors de son clic. */
49c34
<     JLabel logoLabel = new JLabel(Macros.getIcon(About.logo));
---
>     JLabel logoLabel = new JLabel(Macros.getIcon(logo));
53c38
<                                    About.showAboutMessage();
---
>                                    showAboutMessage();

>>> ./src/org/javascool/builder/DialogFrame.java

7a8,12
> import org.javascool.widgets.MainFrame;
> import javax.swing.JPopupMenu;
> import javax.swing.JLabel;
> import javax.swing.JCheckBox;
> import javax.swing.JMenuItem;
12a18,19
> import org.javascool.widgets.Console;
> import javax.swing.JProgressBar;
14d20
< 
16,18d21
< import javax.swing.JCheckBox;
< import javax.swing.JLabel;
< import javax.swing.JMenuItem;
20,21d22
< import javax.swing.JPopupMenu;
< import javax.swing.JProgressBar;
23,24d23
< import javax.swing.SwingConstants;
< 
27,28d25
< import org.javascool.widgets.Console;
< import org.javascool.widgets.MainFrame;
30,31c27
< /**
<  * Définit l'interface graphique pour la construction de proglets.
---
> /** Définit l'interface graphique pour la construction de proglets.
39,81c35,63
<     DialogFrame.jCreatorButton = Console
<                                  .getInstance()
<                                  .getToolBar()
<                                  .addTool("Créer une nouvelle proglet",
<                                           "org/javascool/widgets/icons/new.png", new Runnable() {
<                                             @Override
<                                             public void run() {
<                                               DialogFrame.startProgletCreatorMenu();
<                                             }
<                                           }
<                                           );
<     DialogFrame.jBuilderButton = Console
<                                  .getInstance()
<                                  .getToolBar()
<                                  .addTool("Lancement du builder",
<                                           "org/javascool/widgets/icons/compile.png",
<                                           new Runnable() {
<                                             @Override
<                                             public void run() {
<                                               DialogFrame.startProgletBuilderMenu();
<                                             }
<                                           }
<                                           );
<     Console.getInstance()
<     .getToolBar()
<     .addTool("Progress Bar",
<              DialogFrame.jProgressBar = new JProgressBar());
<     DialogFrame.jProgressBar.setSize(new Dimension(100, 25));
<     Console.getInstance().getToolBar()
<     .addTool("Status Bar", DialogFrame.jLabel = new JLabel());
<     Console.getInstance().getToolBar()
<     .addRightTool("Convertisseur HML", new Runnable() {
<                     @Override
<                     public void run() {
<                       DialogFrame.startConvertisseurHML();
<                     }
<                   }
<                   );
<     Console.getInstance().getToolBar()
<     .addRightTool(About.getAboutMessage());
<     DialogFrame.setUpdate("", 0);
<     new MainFrame().reset("Java's Cool 4 Proglet Buidler", Build.logo,
<                           Console.getInstance());
---
>     jCreatorButton = Console.getInstance().getToolBar().addTool("Créer une nouvelle proglet", "org/javascool/widgets/icons/new.png",
>                                                                 new Runnable() {
>                                                                   @Override
>                                                                   public void run() {
>                                                                     startProgletCreatorMenu();
>                                                                   }
>                                                                 }
>                                                                 );
>     jBuilderButton = Console.getInstance().getToolBar().addTool("Lancement du builder", "org/javascool/widgets/icons/compile.png",
>                                                                 new Runnable() {
>                                                                   @Override
>                                                                   public void run() {
>                                                                     startProgletBuilderMenu();
>                                                                   }
>                                                                 }
>                                                                 );
>     Console.getInstance().getToolBar().addTool("Progress Bar", jProgressBar = new JProgressBar());
>     jProgressBar.setSize(new Dimension(100, 25));
>     Console.getInstance().getToolBar().addTool("Status Bar", jLabel = new JLabel());
>     Console.getInstance().getToolBar().addRightTool("Convertisseur HML", new Runnable() {
>                                                       @Override
>                                                       public void run() {
>                                                         startConvertisseurHML();
>                                                       }
>                                                     }
>                                                     );
>     Console.getInstance().getToolBar().addRightTool(About.getAboutMessage());
>     setUpdate("", 0);
>     new MainFrame().reset("Java's Cool 4 Proglet Buidler", Build.logo, Console.getInstance());
83,90c65,67
<   /**
<    * Met à jour la progression de la construction.
<    *
<    * @param statut
<    *            Statut sur l'opération en cours. Un message de 64 caractères
<    *            max.
<    * @param percent
<    *            Pourcentage de complétion entre 0 et 100.
---
>   /** Met à jour la progression de la construction.
>    * @param statut Statut sur l'opération en cours. Un message de 64 caractères max.
>    * @param percent Pourcentage de complétion entre 0 et 100.
96,97c73,74
<     if(DialogFrame.jLabel != null) {
<       DialogFrame.jLabel.setText(statut);
---
>     if(jLabel != null) {
>       jLabel.setText(statut);
99,100c76,77
<     if(DialogFrame.jProgressBar != null) {
<       DialogFrame.jProgressBar.setValue(percent);
---
>     if(jProgressBar != null) {
>       jProgressBar.setValue(percent);
107,109c84
< 
<   // Ouvre un menu de sélection des proglets et de lancement de la
<   // construction du Jar.
---
>   // Ouvre un menu de sélection des proglets et de lancement de la construction du Jar.
112,118c87,90
<     jCreatorMenu.add(new JLabel(
<                        "Entrer le nom de la proglet à construire:",
<                        SwingConstants.LEFT));
<     DialogFrame.jCreatorMenuDir = new JTextField();
<     DialogFrame.jCreatorMenuDir.setText(System.getProperty("user.dir")
<                                         + File.separator);
<     DialogFrame.jCreatorMenuDir.setEditable(false);
---
>     jCreatorMenu.add(new JLabel("Entrer le nom de la proglet à construire:", JLabel.LEFT));
>     jCreatorMenuDir = new JTextField();
>     jCreatorMenuDir.setText(System.getProperty("user.dir") + File.separator);
>     jCreatorMenuDir.setEditable(false);
120,124d91
<                        /**
<                         *
<                         */
<                        private static final long serialVersionUID = -236539671856928833L;
< 
126,127c93,94
<                          add(DialogFrame.jCreatorMenuDir);
<                          add(DialogFrame.jCreatorMenuName = new JTextField(20));
---
>                          add(jCreatorMenuDir);
>                          add(jCreatorMenuName = new JTextField(20));
131,132c98
<     JMenuItem menuitem = new JMenuItem(
<       "Créer le répertoire et les fichiers exemples");
---
>     JMenuItem menuitem = new JMenuItem("Créer le répertoire et les fichiers exemples");
140c106
<                                                   String name = DialogFrame.jCreatorMenuName.getText();
---
>                                                   String name = jCreatorMenuName.getText();
142,144c108
<                                                     ProgletCreator
<                                                     .mkdirProglet(DialogFrame.jCreatorMenuDir
<                                                                   .getText() + name);
---
>                                                     ProgletCreator.mkdirProglet(jCreatorMenuDir.getText() + name);
153c117
<     jCreatorMenu.show(DialogFrame.jCreatorButton, 0, parent.getHeight());
---
>     jCreatorMenu.show(jCreatorButton, 0, parent.getHeight());
156,158c120
< 
<   // Ouvre un menu de sélection des proglets et de lancement de la
<   // construction du Jar.
---
>   // Ouvre un menu de sélection des proglets et de lancement de la construction du Jar.
162,163c124,125
<     if((DialogFrame.jBuilderMenu == null) || reload) {
<       DialogFrame.jBuilderMenu = new JPopupMenu();
---
>     if((jBuilderMenu == null) || reload) {
>       jBuilderMenu = new JPopupMenu();
165,166c127
<         DialogFrame.jBuilderMenu.add(new JLabel(
<                                        "Sélectionner les proglets à construire:"));
---
>         jBuilderMenu.add(new JLabel("Sélectionner les proglets à construire:"));
170c131
<           DialogFrame.jBuilderMenu.add(check);
---
>           jBuilderMenu.add(check);
172c133
<         DialogFrame.jBuilderMenu.addSeparator();
---
>         jBuilderMenu.addSeparator();
181,185c142,143
<                                                       for(Component c: DialogFrame.jBuilderMenu
<                                                           .getComponents())
<                                                         if(c instanceof JCheckBox
<                                                            && ((JCheckBox) c).isSelected())
<                                                         {
---
>                                                       for(Component c: jBuilderMenu.getComponents())
>                                                         if(c instanceof JCheckBox && ((JCheckBox) c).isSelected()) {
189,190c147
<                                                       ProgletsBuilder.build(proglets
<                                                                             .toArray(new String[proglets.size()]));
---
>                                                       ProgletsBuilder.build(proglets.toArray(new String[proglets.size()]));
197c154
<         DialogFrame.jBuilderMenu.add(menuitem);
---
>         jBuilderMenu.add(menuitem);
199,200c156
<         DialogFrame.jBuilderMenu.add(new JLabel(
<                                        "Aucune proglet à construire dans ce répertoire"));
---
>         jBuilderMenu.add(new JLabel("Aucune proglet à construire dans ce répertoire"));
204,205c160
<     DialogFrame.jBuilderMenu.show(DialogFrame.jBuilderButton, 0,
<                                   parent.getHeight());
---
>     jBuilderMenu.show(jBuilderButton, 0, parent.getHeight());
214c169
<     jCreatorMenu.show(DialogFrame.jCreatorButton, 0, parent.getHeight());
---
>     jCreatorMenu.show(jCreatorButton, 0, parent.getHeight());

>>> ./src/org/javascool/builder/ProgletCreator.java

10d9
< 
13,14c12
< /**
<  * Cette factory contient les mécanismes de construction d'une nouvelle proglet.
---
> /** Cette factory contient les mécanismes de construction d'une nouvelle proglet.
16d13
<  *
23,28c20,22
<   /**
<    * Crée un répertoire et les fichiers de base de la proglet.
<    *
<    * @param location
<    *            Emplacement de la proglet, le nom du répertoire correspond à
<    *            celui de la proglet.
---
> 
>   /** Crée un répertoire et les fichiers de base de la proglet.
>    * @param location Emplacement de la proglet, le nom du répertoire correspond à celui de la proglet.
31,34c25,26
<    * @throws IllegalArgumentException
<    *             Si le nom de la proglet n'est pas un nom Java standard.
<    * @throws RuntimeException
<    *             Si il y a eu une erreur d'entrée sortie lors de la création.
---
>    * @throws IllegalArgumentException Si le nom de la proglet n'est pas un nom Java standard.
>    * @throws RuntimeException Si il y a eu une erreur d'entrée sortie lors de la création.
39,42c31
<       System.out
<       .println("Le nom de la proglet «"
<                + name
<                + "» est bizarre: \n il ne doit contenir que des lettres, faire au moins quatre caractères, et démarrer par une minuscule.");
---
>       System.out.println("Le nom de la proglet «" + name + "» est bizarre: \n il ne doit contenir que des lettres, faire au moins quatre caractères, et démarrer par une minuscule.");
47,48c36
<       System.out.println("Le répertoire «" + location
<                          + "» existe déjà, les fichiers existants seront renommés");
---
>       System.out.println("Le répertoire «" + location + "» existe déjà, les fichiers existants seront renommés");
51,54c39,40
<       String tail = new File(location).exists() ? "un fichier existe à cet emplacement"
<                     : "il doit être interdit de créer le répertoire ici";
<       System.out.println("Impossible de créer le répertoire «" + location
<                          + "» de la proglet, " + tail);
---
>       String tail = new File(location).exists() ? "un fichier existe à cet emplacement" : "il doit être interdit de créer le répertoire ici";
>       System.out.println("Impossible de créer le répertoire «" + location + "» de la proglet, " + tail);
56,73c42,48
<     FileManager.save(location + File.separator + "proglet.pml",
<                      ProgletCreator.progletPattern.replaceAll("@name", name), true);
<     FileManager.save(location + File.separator + "help.xml",
<                      ProgletCreator.helpPattern.replaceAll("@name", name), true);
<     FileManager.save(location + File.separator + "Panel.java",
<                      ProgletCreator.panelPattern.replaceAll("@name", name), true);
<     FileManager
<     .save(location + File.separator + "Functions.java",
<           ProgletCreator.functionsPattern.replaceAll("@name",
<                                                      name), true);
<     FileManager.save(location + File.separator + "completion.xml",
<                      ProgletCreator.completionPattern.replaceAll("@name", name),
<                      true);
<     FileManager.save(location + File.separator + "Translator.java",
<                      ProgletCreator.translatorPattern.replaceAll("@name", name),
<                      true);
<     System.out.println("La proglet «" + name + "» est crée dans "
<                        + location);
---
>     FileManager.save(location + File.separator + "proglet.pml", progletPattern.replaceAll("@name", name), true);
>     FileManager.save(location + File.separator + "help.xml", helpPattern.replaceAll("@name", name), true);
>     FileManager.save(location + File.separator + "Panel.java", panelPattern.replaceAll("@name", name), true);
>     FileManager.save(location + File.separator + "Functions.java", functionsPattern.replaceAll("@name", name), true);
>     FileManager.save(location + File.separator + "completion.xml", completionPattern.replaceAll("@name", name), true);
>     FileManager.save(location + File.separator + "Translator.java", translatorPattern.replaceAll("@name", name), true);
>     System.out.println("La proglet «" + name + "» est crée dans " + location);
76,144c51,122
<   private static final String progletPattern = "title=\"Exemple de «proglet»\"\n"
<                                                + "author=\"Prenom Nom<email@serveur.com>\"\n"
<                                                + "icon=\"sample.png\"\n";
<   private static final String helpPattern = "<div title=\"La «proglet» @name\">\n"
<                                             + "  <div class=\"objectif\">\n"
<                                             + "  </div>\n"
<                                             + "  <div class=\"intros\">\n"
<                                             + "    <div title=\"item 1\">\n"
<                                             + "    </div>\n"
<                                             + "  etc..\n"
<                                             + "  </div>\n"
<                                             + "  <div class=\"works\">\n"
<                                             + "    <div title=\"item 1\">\n"
<                                             + "    </div>\n"
<                                             + "  etc..\n"
<                                             + "  </div>\n"
<                                             + "  <div class=\"notes\">\n"
<                                             + "   <!-- référencées par des tags de la forme <l class=\"note\" link=\"1\"/> -->\n"
<                                             + "    <div title=\"item 1\">\n"
<                                             + "    </div>\n"
<                                             + "  etc..\n"
<                                             + "  </div>\n" + "</div>\n";
<   private static final String panelPattern = "package org.javascool.proglets.@name;\n"
<                                              + "import static org.javascool.macros.Macros.*;\n"
<                                              + "import static org.javascool.proglets.@name.Functions.*;\n"
<                                              + "import javax.swing.JPanel;\n"
<                                              + "\n"
<                                              + "/** Définit le panneau graphique de la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n"
<                                              + " *\n"
<                                              + " * @see <a href=\"Panel.java.html\">code source</a>\n"
<                                              + " * @serial exclude\n"
<                                              + " */\n"
<                                              + "public class Panel extends JPanel /* ou tout autre Component pertinent. */ {\n"
<                                              + "\n"
<                                              + "  // @bean\n"
<                                              + " public Panel() {"
<                                              + "  // @"
<                                              + "todo Définir ici la construction de l'objet graphique\n"
<                                              + "  }\n"
<                                              + "\n"
<                                              + "  /** Démo de la proglet. */\n"
<                                              + "  public void start() {\n"
<                                              + "  // @"
<                                              + "todo Définir ici le code de démo de la proglet.\n"
<                                              + "  }\n"
<                                              + "\n" + "}\n";
<   private static final String functionsPattern = "package org.javascool.proglets.@name;\n"
<                                                  + "import static org.javascool.macros.Macros.*;\n"
<                                                  + "\n"
<                                                  + "/** Définit les fonctions pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n"
<                                                  + " *\n"
<                                                  + " * @see <a href=\"Functions.java.html\">code source</a>\n"
<                                                  + " * @serial exclude\n"
<                                                  + " */\n"
<                                                  + "public class Functions {\n"
<                                                  + "  private static final long serialVersionUID = 1L;\n"
<                                                  + "  // @factory\n"
<                                                  + "  private Functions() {}\n"
<                                                  + "  /** Renvoie l'instance de la proglet pour accéder à ses éléments.\n"
<                                                  + "   * <p> Utilisé dans une construction de type <tt>getPane().appelDeMethode(..)</tt>.</p>\n"
<                                                  + "   */\n"
<                                                  + "  private static Panel getPane() {\n"
<                                                  + "     return getProgletPane();\n"
<                                                  + "  }\n"
<                                                  + "\n"
<                                                  + "  //@"
<                                                  + "todo Définir ici les fonctions <tt>public static</tt>\n"
<                                                  + "\n"
<                                                  + "}\n";
---
>   private static final String progletPattern =
>     "title=\"Exemple de «proglet»\"\n" +
>     "author=\"Prenom Nom<email@serveur.com>\"\n" +
>     "icon=\"sample.png\"\n";
>   private static final String helpPattern =
>     "<div title=\"La «proglet» @name\">\n" +
>     "  <div class=\"objectif\">\n" +
>     "  </div>\n" +
>     "  <div class=\"intros\">\n" +
>     "    <div title=\"item 1\">\n" +
>     "    </div>\n" +
>     "  etc..\n" +
>     "  </div>\n" +
>     "  <div class=\"works\">\n" +
>     "    <div title=\"item 1\">\n" +
>     "    </div>\n" +
>     "  etc..\n" +
>     "  </div>\n" +
>     "  <div class=\"notes\">\n" +
>     "   <!-- référencées par des tags de la forme <l class=\"note\" link=\"1\"/> -->\n" +
>     "    <div title=\"item 1\">\n" +
>     "    </div>\n" +
>     "  etc..\n" +
>     "  </div>\n" +
>     "</div>\n";
>   private static final String panelPattern =
>     "package org.javascool.proglets.@name;\n" +
>     "import static org.javascool.macros.Macros.*;\n" +
>     "import static org.javascool.proglets.@name.Functions.*;\n" +
>     "import javax.swing.JPanel;\n" +
>     "\n" +
>     "/** Définit le panneau graphique de la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
>     " *\n" +
>     " * @see <a href=\"Panel.java.html\">code source</a>\n" +
>     " * @serial exclude\n" +
>     " */\n" +
>     "public class Panel extends JPanel /* ou tout autre Component pertinent. */ {\n" +
>     "\n" +
>     "  // @bean\n" +
>     " public Panel() {" +
>     "  // @" + "todo Définir ici la construction de l'objet graphique\n" +
>     "  }\n" +
>     "\n" +
>     "  /** Démo de la proglet. */\n" +
>     "  public void start() {\n" +
>     "  // @" + "todo Définir ici le code de démo de la proglet.\n" +
>     "  }\n" +
>     "\n" +
>     "}\n";
>   private static final String functionsPattern =
>     "package org.javascool.proglets.@name;\n" +
>     "import static org.javascool.macros.Macros.*;\n" +
>     "\n" +
>     "/** Définit les fonctions pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
>     " *\n" +
>     " * @see <a href=\"Functions.java.html\">code source</a>\n" +
>     " * @serial exclude\n" +
>     " */\n" +
>     "public class Functions {\n" +
>     "  private static final long serialVersionUID = 1L;\n" +
>     "  // @factory\n" +
>     "  private Functions() {}\n" +
>     "  /** Renvoie l'instance de la proglet pour accéder à ses éléments.\n" +
>     "   * <p> Utilisé dans une construction de type <tt>getPane().appelDeMethode(..)</tt>.</p>\n" +
>     "   */\n" +
>     "  private static Panel getPane() {\n" +
>     "     return getProgletPane();\n" +
>     "  }\n" +
>     "\n" +
>     "  //@" + "todo Définir ici les fonctions <tt>public static</tt>\n" +
>     "\n" +
>     "}\n";
146,153c124,133
<   private static final String completionPattern = "<keywords>\n"
<                                                   + "  <keyword \n"
<                                                   + "    name=\"nom de la complétion\" \n"
<                                                   + "    title=\"description en ligne\">\n"
<                                                   + "    <code>texte source de la complétion</code>\n"
<                                                   + "    <doc>Texte qui documente la fonction de l'on complète</doc>\n"
<                                                   + "  </keyword>\n" + "  <!-- autres keyword -->\n"
<                                                   + "</keywords>\n";
---
>   private static final String completionPattern =
>     "<keywords>\n" +
>     "  <keyword \n" +
>     "    name=\"nom de la complétion\" \n" +
>     "    title=\"description en ligne\">\n" +
>     "    <code>texte source de la complétion</code>\n" +
>     "    <doc>Texte qui documente la fonction de l'on complète</doc>\n" +
>     "  </keyword>\n" +
>     "  <!-- autres keyword -->\n" +
>     "</keywords>\n";
155,169c135,152
<   private static final String translatorPattern = "package org.javascool.proglets.@name;\n"
<                                                   + "\n"
<                                                   + "/** Définit la traduction d'un code Jvs en code Java  pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n"
<                                                   + " *\n"
<                                                   + " * @see <a href=\"Translator.java.html\">code source</a>\n"
<                                                   + " * @serial exclude\n"
<                                                   + " */\n"
<                                                   + "public class Translator extends org.javascool.core.Translator {\n"
<                                                   + "    @Override\n"
<                                                   + "     public String getImports() {\n"
<                                                   + "    return \"\";\n"
<                                                   + "  }\n"
<                                                   + "    @Override\n"
<                                                   + "  public String translate(String code) {\n"
<                                                   + "    return code;\n" + "  }\n" + "}\n";
---
>   private static final String translatorPattern =
>     "package org.javascool.proglets.@name;\n" +
>     "\n" +
>     "/** Définit la traduction d'un code Jvs en code Java  pour manipuler la proglet «@name» (A DÉTRUIRE SI NON UTILISÉ).\n" +
>     " *\n" +
>     " * @see <a href=\"Translator.java.html\">code source</a>\n" +
>     " * @serial exclude\n" +
>     " */\n" +
>     "public class Translator extends org.javascool.core.Translator {\n" +
>     "    @Override\n" +
>     "     public String getImports() {\n" +
>     "    return \"\";\n" +
>     "  }\n" +
>     "    @Override\n" +
>     "  public String translate(String code) {\n" +
>     "    return code;\n" +
>     "  }\n" +
>     "}\n";

>>> ./src/org/javascool/builder/Htm2Hml.java

2a3
> import javax.swing.JPanel;
4,7c5
< import java.awt.Color;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< 
---
> import javax.swing.JToolBar;
9d6
< import javax.swing.JButton;
11c8,10
< import javax.swing.JPanel;
---
> import javax.swing.JButton;
> import java.awt.event.ActionEvent;
> import java.awt.event.ActionListener;
14,15c13
< import javax.swing.JToolBar;
< 
---
> import java.awt.Color;
21,24d18
<   /**
<    *
<    */
<   private static final long serialVersionUID = -2365819987269409474L;
26d19
< 
31,32c24
<     b.add(new JLabel(
<             "Traduction de [X]HTML en HML (coller le HTML à gauche et copié le HML à droite et cliquer sur le bouton) -> "));
---
>     b.add(new JLabel("Traduction de [X]HTML en HML (coller le HTML à gauche et copié le HML à droite et cliquer sur le bouton) -> "));
34,38d25
<             /**
<              *
<              */
<             private static final long serialVersionUID = 410907766230668800L;
< 
40a28
>                                   private static final long serialVersionUID = 1L;
43c31
<                                     hml.setText(Htm2Hml.translate(htm.getText()));
---
>                                     hml.setText(translate(htm.getText()));
67,68c55
<       hml = Xml2Xml.run(hml,
<                         FileManager.load("org/javascool/builder/htm2hml.xslt"));
---
>       hml = Xml2Xml.run(hml, FileManager.load("org/javascool/builder/htm2hml.xslt"));
74,78c61,62
<   /**
<    * Lanceur de la transformation [X]HTML -> HML.
<    *
<    * @param usage
<    *            <tt>java org.javascool.builder.Htm2Hml input-file [output-file]</tt>
---
>   /** Lanceur de la transformation [X]HTML -> HML.
>    * @param usage <tt>java org.javascool.builder.Htm2Hml input-file [output-file]</tt>
83,84c67
<       FileManager.save(usage.length > 1 ? usage[1] : "stdout:",
<                        Htm2Hml.translate(FileManager.load(usage[0])));
---
>       FileManager.save(usage.length > 1 ? usage[1] : "stdout:", translate(FileManager.load(usage[0])));

>>> ./src/org/javascool/builder/ProgletsBuilder.java

7a8,11
> import org.javascool.tools.FileManager;
> import org.javascool.tools.Xml2Xml;
> import org.javascool.tools.Pml;
> 
11a16
> 
14,15d18
< 
< import org.javascool.About;
17,19c20
< import org.javascool.tools.FileManager;
< import org.javascool.tools.Pml;
< import org.javascool.tools.Xml2Xml;
---
> import org.javascool.About;
21,23c22
< /**
<  * Cette factory contient les mécanismes de construction d'une application
<  * Java's Cool avec des proglets.
---
> /** Cette factory contient les mécanismes de construction d'une application Java's Cool avec des proglets.
30,31c29
<   private static final String fileRegexSeparator = File.separator
<                                                    .equals("\\") ? "\\\\" : File.separator;
---
>   private static final String fileRegexSeparator = File.separator.equals("\\") ? "\\\\" : File.separator;
35,37c33
<   /**
<    * Définit si la construction se fait avec tous les messages intermédiaires.
<    */
---
>   /** Définit si la construction se fait avec tous les messages intermédiaires. */
39c35
<     ProgletsBuilder.verbose = v;
---
>     verbose = v;
42,43c38
< 
<   /** Teste si cette version de Java'sCool a la capacité de créer des jar. */
---
>   /** Teste si cette version de Java'sCool a la capacité de créer des jar.  */
52,56c47,48
<   /**
<    * Renvoie les proglets à construire.
<    *
<    * @param names
<    *            Noms ou suffixes des proglets à sélectionner.
---
>   /** Renvoie les proglets à construire.
>    * @param names Noms ou suffixes des proglets à sélectionner.
78c70
<     return ProgletsBuilder.getProglets(null);
---
>     return getProglets(null);
80,91c72,75
<   /**
<    * Construit une nouvelle archive avec les proglets proposées.
<    *
<    * @param proglets
<    *            Les proglets sélectionnées. Par défaut toutes les proglets
<    *            disponibles.
<    * @param targetDir
<    *            Le répertoire cible dans lequel la construction se fait. Si
<    *            null utilise un répertoire temporaire.
<    * @param webdoc
<    *            Si true compile la javadoc et les jars de chaque proglet
<    *            (false par défaut).
---
>   /** Construit une nouvelle archive avec les proglets proposées.
>    * @param proglets Les proglets sélectionnées. Par défaut toutes les proglets disponibles.
>    * @param targetDir Le répertoire cible dans lequel la construction se fait. Si null utilise un répertoire temporaire.
>    * @param webdoc Si true compile la javadoc et les jars de chaque proglet (false par défaut).
94,97c78,79
<   public static boolean build(String[] proglets, String targetDir,
<                               boolean webdoc) {
<     if(!ProgletsBuilder.canBuildProglets()) { throw new IllegalArgumentException(
<                                                       "Mauvaise configuration du builder, il faut utiliser le bon jar !");
---
>   public static boolean build(String[] proglets, String targetDir, boolean webdoc) {
>     if(!canBuildProglets()) { throw new IllegalArgumentException("Mauvaise configuration du builder, il faut utiliser le bon jar !");
100,101c82
<       if(proglets.length == 0) { throw new IllegalArgumentException(
<                                          "Aucune proglet à construire");
---
>       if(proglets.length == 0) { throw new IllegalArgumentException("Aucune proglet à construire");
104,105c85
<       String targetJar = System.getProperty("user.dir") + File.separator
<                          + "javascool-proglets.jar";
---
>       String targetJar = System.getProperty("user.dir") + File.separator + "javascool-proglets.jar";
107,108c87
<       ProgletsBuilder.log("Scan des proglets à partir du répertoire: "
<                           + System.getProperty("user.dir"));
---
>       log("Scan des proglets à partir du répertoire: " + System.getProperty("user.dir"));
118,119c97
<           if(new File(".").equals(buildDir.getCanonicalFile())) { throw new IllegalArgumentException(
<                                                                           "Le répertoire des proglets et celui du build ne peuvent pas être identiques");
---
>           if(new File(".").equals(buildDir.getCanonicalFile())) { throw new IllegalArgumentException("Le répertoire des proglets et celui du build ne peuvent pas être identiques");
125,126c103
<         progletsDir = jarDir + File.separator + "org" + File.separator
<                       + "javascool" + File.separator + "proglets";
---
>         progletsDir = jarDir + File.separator + "org" + File.separator + "javascool" + File.separator + "proglets";
130,131c107
<       // Expansion des classes javascool et des proglets existantes dans
<       // les jars
---
>       // Expansion des classes javascool et des proglets existantes dans les jars
133c109
<         ProgletsBuilder.log("Extraction des Jars du sketchbook", true);
---
>         log("Extraction des Jars du sketchbook", true);
135,139c111,112
<         for(String jar : FileManager.list(
<               System.getProperty("user.dir"), ".*\\.jar"))
<           if(!jar.matches(".*" + ProgletsBuilder.fileRegexSeparator
<                           + "javascool-(builder|proglets).jar"))
<           {
---
>         for(String jar : FileManager.list(System.getProperty("user.dir"), ".*\\.jar"))
>           if(!jar.matches(".*" + fileRegexSeparator + "javascool-(builder|proglets).jar")) {
142c115
<          // Expansion des jars des proglets
---
>         // Expansion des jars des proglets
146c119
<            // Expansion des jars de javascool
---
>         // Expansion des jars de javascool
148,151c121,122
<         ProgletsBuilder.log("Extraction de Java's cool", true);
<         String libs[] = { "org/javascool", "org/fife",
<                           "sun/tools/java", "com/sun/tools/javac",
<                           "com/sun/source/tree", "com/sun/source/util" };
---
>         log("Extraction de Java's cool", true);
>         String libs[] = { "org/javascool", "org/fife", "sun/tools/java", "com/sun/tools/javac", "com/sun/source/tree", "com/sun/source/util" };
160,161c131
<         ProgletBuild build = new ProgletBuild(proglet,
<                                               new File(proglet).getAbsolutePath(), jarDir);
---
>         ProgletBuild build = new ProgletBuild(proglet, new File(proglet).getAbsolutePath(), jarDir);
163,165c133,134
<         ProgletsBuilder.log("Compilation de " + name + " ...");
<         DialogFrame.setUpdate("Construction de " + name + " 1/4",
<                               level += up);
---
>         log("Compilation de " + name + " ...");
>         DialogFrame.setUpdate("Construction de " + name + " 1/4", level += up);
167,168c136
<         DialogFrame.setUpdate("Construction de " + name + " 2/4",
<                               level += up);
---
>         DialogFrame.setUpdate("Construction de " + name + " 2/4", level += up);
170,171c138
<         DialogFrame.setUpdate("Construction de " + name + " 3/4",
<                               level += up);
---
>         DialogFrame.setUpdate("Construction de " + name + " 3/4", level += up);
174,175c141
<           DialogFrame.setUpdate("Construction de " + name + " 4/4",
<                                 level += up);
---
>           DialogFrame.setUpdate("Construction de " + name + " 4/4", level += up);
184,186c150,151
<         ProgletsBuilder.log("Compilation des fichiers java");
<         String[] javaFiles = FileManager.list(progletsDir, ".*\\.java",
<                                               2);
---
>         log("Compilation des fichiers java");
>         String[] javaFiles = FileManager.list(progletsDir, ".*\\.java", 2);
188c153
<           ProgletsBuilder.javac(jarDir, javaFiles);
---
>           javac(jarDir, javaFiles);
195,207c160,167
<         String version = "Java'sCool v4 on \"" + new Date()
<                          + "\" Revision #" + About.revision;
<         new Pml()
<         .set("Main-Class", "org.javascool.Core")
<         .set("Manifest-version", version)
<         .set("Created-By",
<              "inria.fr (javascool.gforge.inria.fr) ©INRIA: CeCILL V2 + CreativeCommons BY-NC-ND V2")
<         .set("Implementation-URL",
<              "http://javascool.gforge.inria.fr")
<         .set("Implementation-Vendor",
<              "javascool@googlegroups.com, ou=javascool.gforge.inria.fr, o=inria.fr, c=fr")
<         .set("Implementation-Version", version)
<         .save(buildDir + "/manifest.jmf");
---
>         String version = "Java'sCool v4 on \"" + new Date() + "\" Revision #" + About.revision;
>         Pml manifest = new Pml().set("Main-Class", "org.javascool.Core").
>                        set("Manifest-version", version).
>                        set("Created-By", "inria.fr (javascool.gforge.inria.fr) ©INRIA: CeCILL V2 + CreativeCommons BY-NC-ND V2").
>                        set("Implementation-URL", "http://javascool.gforge.inria.fr").
>                        set("Implementation-Vendor", "javascool@googlegroups.com, ou=javascool.gforge.inria.fr, o=inria.fr, c=fr").
>                        set("Implementation-Version", version).
>                        save(buildDir + "/manifest.jmf");
212,213c172
<             String javascoolPrefix = "org" + File.separator
<                                      + "javascool" + File.separator;
---
>             String javascoolPrefix = "org" + File.separator + "javascool" + File.separator;
220,227c179,180
<               javascoolPrefix + "builder",
<               javascoolPrefix + "core",
<               javascoolPrefix + "gui",
<               javascoolPrefix + "macros",
<               javascoolPrefix + "tools",
<               javascoolPrefix + "widgets",
<               javascoolPrefix + "proglets" + File.separator
<               + name
---
>               javascoolPrefix + "builder", javascoolPrefix + "core", javascoolPrefix + "gui", javascoolPrefix + "macros", javascoolPrefix + "tools", javascoolPrefix + "widgets",
>               javascoolPrefix + "proglets" + File.separator + name
229,232c182,183
<             String tmpJar = buildDir + File.separator
<                             + "javascool-proglet-" + name + ".jar";
<             JarManager.jarCreate(tmpJar,
<                                  buildDir + "/manifest.jmf", jarDir, jarEntries);
---
>             String tmpJar = buildDir + File.separator + "javascool-proglet-" + name + ".jar";
>             JarManager.jarCreate(tmpJar, buildDir + "/manifest.jmf", jarDir, jarEntries);
234,236c185
<             new ProgletBuild(proglet,
<                              new File(proglet).getAbsolutePath(), jarDir)
<             .convertHdocs(true);
---
>             new ProgletBuild(proglet, new File(proglet).getAbsolutePath(), jarDir).convertHdocs(true);
240,243c189,190
<         JarManager.jarCreate(targetJar, buildDir + "/manifest.jmf",
<                              jarDir);
<         // Signature et déplacement des "javascool-proglet-"+name+".jar"
<         // dans les répetoires des proglets
---
>         JarManager.jarCreate(targetJar, buildDir + "/manifest.jmf", jarDir);
>         // Signature et déplacement des "javascool-proglet-"+name+".jar" dans les répetoires des proglets
249,253c196,197
<             String tmpJar = buildDir + File.separator
<                             + "javascool-proglet-" + name + ".jar";
<             String signedJar = progletsDir + File.separator + name
<                                + File.separator + "javascool-proglet-" + name
<                                + ".jar";
---
>             String tmpJar = buildDir + File.separator + "javascool-proglet-" + name + ".jar";
>             String signedJar = progletsDir + File.separator + name + File.separator + "javascool-proglet-" + name + ".jar";
256,264c200,201
<               String keystore = jarDir + File.separator + "org"
<                                 + File.separator + "javascool"
<                                 + File.separator + "builder"
<                                 + File.separator + "javascool.key";
<               String args = "-storepass\tjavascool\t-keypass\tmer,d,azof\t-keystore\t"
<                             + keystore
<                             + "\t-signedjar\t"
<                             + signedJar
<                             + "\t" + tmpJar + "\tjavascool";
---
>               String keystore = jarDir + File.separator + "org" + File.separator + "javascool" + File.separator + "builder" + File.separator + "javascool.key";
>               String args = "-storepass\tjavascool\t-keypass\tmer,d,azof\t-keystore\t" + keystore + "\t-signedjar\t" + signedJar + "\t" + tmpJar + "\tjavascool";
275,278c212,213
<       System.out.println("Construction achevée avec succès: «"
<                          + targetJar + "» a été créé");
<       System.out.println("\tIl faut lancer «" + targetJar
<                          + "» pour tester/utiliser les proglets.");
---
>       System.out.println("Construction achevée avec succès: «" + targetJar + "» a été créé");
>       System.out.println("\tIl faut lancer «" + targetJar + "» pour tester/utiliser les proglets.");
282,284c217
<       System.out.println("Erreur inopinée lors de la construction ("
<                          + e.getMessage()
<                          + "): corriger l'erreur et relancer la construction");
---
>       System.out.println("Erreur inopinée lors de la construction (" + e.getMessage() + "): corriger l'erreur et relancer la construction");
292c225
<     return ProgletsBuilder.build(proglets, targetDir, false);
---
>     return build(proglets, targetDir, false);
298c231
<     return ProgletsBuilder.build(proglets, null, webdoc);
---
>     return build(proglets, null, webdoc);
304,305c237
<     return ProgletsBuilder.build(ProgletsBuilder.getProglets(), targetDir,
<                                  webdoc);
---
>     return build(getProglets(), targetDir, webdoc);
311c243
<     return ProgletsBuilder.build(proglets, null, false);
---
>     return build(proglets, null, false);
317,318c249
<     return ProgletsBuilder.build(ProgletsBuilder.getProglets(), targetDir,
<                                  false);
---
>     return build(getProglets(), targetDir, false);
324,325c255
<     return ProgletsBuilder.build(ProgletsBuilder.getProglets(), null,
<                                  webdoc);
---
>     return build(getProglets(), null, webdoc);
331,332c261
<     return ProgletsBuilder
<            .build(ProgletsBuilder.getProglets(), null, false);
---
>     return build(getProglets(), null, false);
336,337c265
<     // if (!Java2Class.compile(javaFiles, true)) throw new
<     // IllegalArgumentException("Erreur de compilation java");
---
>     // if (!Java2Class.compile(javaFiles, true)) throw new IllegalArgumentException("Erreur de compilation java");
346,350c274,276
<       Class.forName("com.sun.tools.javac.Main")
<       .getDeclaredMethod("compile",
<                          Class.forName("[Ljava.lang.String;"),
<                          Class.forName("java.io.PrintWriter"))
<       .invoke(null, args, new PrintWriter(out));
---
>       Class.forName("com.sun.tools.javac.Main").
>       getDeclaredMethod("compile", Class.forName("[Ljava.lang.String;"), Class.forName("java.io.PrintWriter")).
>       invoke(null, (Object) args, new PrintWriter(out));
360,361c286
<   private static void javadoc(String name, String classPath, String srcDir,
<                               String apiDir) throws IOException {
---
>   private static void javadoc(String name, String classPath, String srcDir, String apiDir) throws IOException {
368,371c293
<         String argv = "-quiet\t-classpath\t"
<                       + classPath
<                       + "\t-d\t"
<                       + apiDir
---
>         String argv = "-quiet\t-classpath\t" + classPath + "\t-d\t" + apiDir
376c298
<          // Lance javadoc
---
>         // Lance javadoc
385,387c307
<         Jvs2Html.runDirectory(srcDir, apiDir + File.separator + "org"
<                               + File.separator + "javascool" + File.separator
<                               + "proglets" + File.separator + name);
---
>         Jvs2Html.runDirectory(srcDir, apiDir + File.separator + "org" + File.separator + "javascool" + File.separator + "proglets" + File.separator + name);
391,397c311,313
<   /**
<    * Envoie un message de log dans la console.
<    *
<    * @param text
<    *            Le message
<    * @param onlyVerbose
<    *            Ne s'affiche que si l'option -v est activé
---
>   /** Envoie un message de log dans la console.
>    * @param text Le message
>    * @param onlyVerbose Ne s'affiche que si l'option -v est activé
401c317
<       if(ProgletsBuilder.verbose) {
---
>       if(verbose) {
408,410c324
<   /**
<    * Imprime un message dans la console
<    *
---
>   /** Imprime un message dans la console
414c328
<     ProgletsBuilder.log(text, false);
---
>     log(text, false);
431,441c345,349
<     /**
<      * Crée un nouveau contôleur pour la compilation d'une proglet.
<      *
<      * @param name
<      *            Le nom de la proglet
<      * @param progletDir
<      *            Le répertoire de la proglet à compiler
<      * @param pml
<      *            Le fichier Pml d'information de la proglet
<      * @param jarDest
<      *            Le dossier du jar final
---
>     /** Crée un nouveau contôleur pour la compilation d'une proglet.
>      * @param name Le nom de la proglet
>      * @param progletDir Le répertoire de la proglet à compiler
>      * @param pml Le fichier Pml d'information de la proglet
>      * @param jarDest Le dossier du jar final
445,446c353
<       this.pml = pml = pml != null ? pml : new Pml().load(progletDir
<                                                           + File.separator + "proglet.pml");
---
>       this.pml = pml = pml != null ? pml : new Pml().load(progletDir + File.separator + "proglet.pml");
448,457c355,359
<         this.progletSrc = progletDir != null ? new File(progletDir)
<                           .getAbsolutePath() : "";
<       } catch(Exception e) { throw new RuntimeException("Le dossier source de " + name
<                                                         + " n'existe pas");
<       }
<       this.jarDest = jarDest = jarDest != null ? new File(jarDest)
<                                .getAbsolutePath() : "";
<       this.progletDir = jarDest
<                         + "/org/javascool/proglets/".replace("/", File.separator)
<                         + name;
---
>         this.progletSrc = progletDir != null ? new File(progletDir).getAbsolutePath() : "";
>       } catch(Exception e) { throw new RuntimeException("Le dossier source de " + name + " n'existe pas");
>       }
>       this.jarDest = jarDest = jarDest != null ? new File(jarDest).getAbsolutePath() : "";
>       this.progletDir = jarDest + "/org/javascool/proglets/".replace("/", File.separator) + name;
460,464c362,363
<     /**
<      * Lit automatiquement le fichier Pml
<      *
<      * @see ProgletBuild#ProgletBuild(java.lang.String, java.lang.String,
<      *      org.javascool.tools.Pml, java.lang.String)
---
>     /** Lit automatiquement le fichier Pml
>      * @see ProgletBuild#ProgletBuild(java.lang.String, java.lang.String, org.javascool.tools.Pml, java.lang.String)
471c370
<       ProgletsBuilder.log("Copie des fichiers de " + name, true);
---
>       log("Copie des fichiers de " + name, true);
475,476c374
<       } catch(IOException ex) { throw new RuntimeException(
<                                         "Erreur lors de la copie des fichiers de " + name, ex);
---
>       } catch(IOException ex) { throw new RuntimeException("Erreur lors de la copie des fichiers de " + name, ex);
487c385
<       ProgletsBuilder.log("Vérification de la proglet " + name, true);
---
>       log("Vérification de la proglet " + name, true);
489,496c387,389
<       if(!(name.matches("[a-zA-Z][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]+") && (name
<                                                                           .length() <= 20)))
<       {
<         System.out
<         .println("Le nom de la proglet «"
<                  + name
<                  + "» est bizarre:"
<                  + " il ne doit contenir que des lettres faire au moins quatre caractères et au plus seize et démarrer par une lettre minuscule");
---
>       if(!(name.matches("[a-zA-Z][a-zA-Z0-9][a-zA-Z0-9][a-zA-Z0-9]+") && (name.length() <= 20))) {
>         System.out.println("Le nom de la proglet «" + name + "» est bizarre:" +
>                            " il ne doit contenir que des lettres faire au moins quatre caractères et au plus seize et démarrer par une lettre minuscule");
500,501c393
<         System.out.println("Pas de fichier d'aide pour " + name
<                            + ", la proglet ne sera pas construite.");
---
>         System.out.println("Pas de fichier d'aide pour " + name + ", la proglet ne sera pas construite.");
504,512c396,398
<       if(FileManager.exists(progletDir + File.separator
<                             + "completion.xml"))
<       {
<         String err = Xml2Xml.run(
<           FileManager.load(progletDir + File.separator
<                            + "completion.xml"),
<           FileManager.load(jarDest
<                            + "/org/javascool/builder/completionok.xslt"
<                            .replace("/", File.separator))).trim();
---
>       if(FileManager.exists(progletDir + File.separator + "completion.xml")) {
>         String err = Xml2Xml.run(FileManager.load(progletDir + File.separator + "completion.xml"),
>                                  FileManager.load(jarDest + "/org/javascool/builder/completionok.xslt".replace("/", File.separator))).trim();
514,517c400
<           System.out
<           .println("Il y a une erreur dans le fichier completion.xml : «"
<                    + err.replaceAll("\\s+", " ")
<                    + "», la proglet ne sera pas construite.");
---
>           System.out.println("Il y a une erreur dans le fichier completion.xml : «" + err.replaceAll("\\s+", " ") + "», la proglet ne sera pas construite.");
522,524c405
<         System.out.println("Le champ «author» n'est pas défini dans "
<                            + name
<                            + "/proglet.pml, la proglet ne sera pas construite.");
---
>         System.out.println("Le champ «author» n'est pas défini dans " + name + "/proglet.pml, la proglet ne sera pas construite.");
528,530c409
<         System.out.println("Le champ «title» n'est pas défini dans "
<                            + name
<                            + "/proglet.pml, la proglet ne sera pas construite.");
---
>         System.out.println("Le champ «title» n'est pas défini dans " + name + "/proglet.pml, la proglet ne sera pas construite.");
533,539c412,413
<       if(isprocessing
<          && !(pml.isDefined("width") && pml.isDefined("height")))
<       {
<         System.out
<         .println("Les champ «width» et «height» ne sont pas définis dans "
<                  + name
<                  + "/proglet.pml, la proglet processing ne sera pas construite.");
---
>       if(isprocessing && !(pml.isDefined("width") && pml.isDefined("height"))) {
>         System.out.println("Les champ «width» et «height» ne sont pas définis dans " + name + "/proglet.pml, la proglet processing ne sera pas construite.");
543,544c417
<       if(error) { throw new IllegalArgumentException(
<                           "La proglet ne respecte pas les spécifications");
---
>       if(error) { throw new IllegalArgumentException("La proglet ne respecte pas les spécifications");
549c422
<       ProgletsBuilder.log("Convertion des HDocs pour " + name, true);
---
>       log("Convertion des HDocs pour " + name, true);
553,555c426
<             ProgletsBuilder.log(
<               "Convertion de " + new File(doc).getName(),
<               true);
---
>             log("Convertion de " + new File(doc).getName(), true);
557,570c428,432
<             FileManager
<             .save(doc.replaceFirst("\\.xml", "\\.htm"),
<                   Xml2Xml.run(
<                     FileManager.load(doc, true),
<                     FileManager.load(jarDest
<                                      + "/org/javascool/builder/hdoc2htm.xslt"
<                                      .replace(
<                                        "/",
<                                        File.separator)),
<                     "output", webdoc ? "web"
<                     : "jvs"), false, true);
<           } catch(IllegalArgumentException e) { throw new IllegalArgumentException("dans "
<                                                                                    + new File(doc).getName() + " : "
<                                                                                    + e.getMessage());
---
>             FileManager.save(doc.replaceFirst("\\.xml", "\\.htm"),
>                              Xml2Xml.run(FileManager.load(doc, true),
>                                          FileManager.load(jarDest + "/org/javascool/builder/hdoc2htm.xslt".replace("/", File.separator)),
>                                          "output", webdoc ? "web" : "jvs"), false, true);
>           } catch(IllegalArgumentException e) { throw new IllegalArgumentException("dans " + new File(doc).getName() + " : " + e.getMessage());
581c443
<       ProgletsBuilder.log("Création de l'applet HTML pour " + name, true);
---
>       log("Création de l'applet HTML pour " + name, true);
584,589c446,449
<                        + "s.PanelApplet' archive='./proglets/" + name
<                        + "/javascool" + "-proglet-" + name
<                        + ".jar'><param name='panel' value='org"
<                        + ".javascool.proglets." + name
<                        + ".Panel'/><pre>Impossible " + "de lancer " + name
<                        + ": Java n'est pas installé ou mal co"
---
>                        + "s.PanelApplet' archive='./proglets/" + name + "/javascool"
>                        + "-proglet-" + name + ".jar'><param name='panel' value='org"
>                        + ".javascool.proglets." + name + ".Panel'/><pre>Impossible "
>                        + "de lancer " + name + ": Java n'est pas installé ou mal co"
595,600c455,457
<         ProgletsBuilder
<         .log("Création de la javadoc pour " + name, true);
<         ProgletsBuilder.javadoc(name, classPath, progletDir, progletDir
<                                 + File.separator + "api");
<       } catch(IOException ex) { throw new RuntimeException(
<                                         "Erreur lors de la génération de la javadoc");
---
>         log("Création de la javadoc pour " + name, true);
>         ProgletsBuilder.javadoc(name, classPath, progletDir, progletDir + File.separator + "api");
>       } catch(IOException ex) { throw new RuntimeException("Erreur lors de la génération de la javadoc");

>>> ./src/org/javascool/builder/LinkCheck.java

10c10,11
< import java.util.HashMap;
---
> 
> // Used to cache the links
12,13c13
< import java.util.regex.Matcher;
< import java.util.regex.Pattern;
---
> import java.util.HashMap;
14a15,17
> // Used to patch href
> import java.util.regex.Pattern;
> import java.util.regex.Matcher;
17,19c20
< /**
<  * Permet de vérifier les liens cassés sur un site.
<  *
---
> /** Permet de vérifier les liens cassés sur un site.
25,33c26,29
<   /**
<    * Lanceur du test des liens cassés.
<    *
<    * @param usage
<    *            <tt>java org.javascool.tools.LinkCheck [-recursive] location</tt>
<    *            <p>
<    *            Teste les liens d'une adresse web, avec récursion à travers
<    *            les sous-pages si besoin.
<    *            </p>
---
> 
>   /** Lanceur du test des liens cassés.
>    * @param usage <tt>java org.javascool.tools.LinkCheck [-recursive] location</tt>
>    * <p>Teste les liens d'une adresse web, avec récursion à travers les sous-pages si besoin.</p>
37,38c33
<       LinkCheck.check(usage[usage.length - 1],
<                       "-recursive".equals(usage[0]));
---
>       check(usage[usage.length - 1], "-recursive".equals(usage[0]));
41,42c36,38
<   /**
<    * Teste les liens d'une adresse web et donne les liens cassés à la console.
---
>   /** Teste les liens d'une adresse web et donne les liens cassés à la console.
>    * @param location L'adresse web à tester.
>    * @param recursive Si true, effectue récursion à travers les sous-pages.
44,50c40
<    * @param location
<    *            L'adresse web à tester.
<    * @param recursive
<    *            Si true, effectue récursion à travers les sous-pages.
<    *
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
---
>    * @throws IllegalArgumentException Si l'URL est mal formée.
53,64c43,52
<     LinkCheck.echoBroken("LINKCHECK: " + LinkCheck.getRoot(location));
<     LinkCheck.links = new HashSet<String>();
<     LinkCheck.anchors = new HashMap<String, HashSet<String> >();
<     LinkCheck.root = LinkCheck.getRoot(location);
<     LinkCheck.loop = recursive;
<     LinkCheck.npages = LinkCheck.nlinks = LinkCheck.nbrokens = 0;
<     LinkCheck.check(location);
<     LinkCheck.echoBroken("  SCANNED PAGES: " + LinkCheck.npages
<                          + " SCANNED LINKS: " + LinkCheck.nlinks + " BROKENS LINKS: "
<                          + LinkCheck.nbrokens);
<     LinkCheck.links = null;
<     LinkCheck.anchors = null;
---
>     echoBroken("LINKCHECK: " + getRoot(location));
>     links = new HashSet<String>();
>     anchors = new HashMap<String, HashSet<String> >();
>     root = getRoot(location);
>     loop = recursive;
>     npages = nlinks = nbrokens = 0;
>     check(location);
>     echoBroken("  SCANNED PAGES: " + npages + " SCANNED LINKS: " + nlinks + " BROKENS LINKS: " + nbrokens);
>     links = null;
>     anchors = null;
71d58
< 
75,76c62,63
<       LinkCheck.npages++;
<       for(String href : LinkCheck.getLinks(text))
---
>       npages++;
>       for(String href : getLinks(text))
79,83c66,69
<             href = new URL(new URL(location), href.replaceAll(
<                              "%2e", ".")).toString();
<             if(!LinkCheck.links.contains(href)) {
<               LinkCheck.links.add(href);
<               LinkCheck.nlinks++;
---
>             href = new URL(new URL(location), href.replaceAll("%2e", ".")).toString();
>             if(!links.contains(href)) {
>               links.add(href);
>               nlinks++;
91,92c77
<                 LinkCheck.echoBroken("BROKEN  Link in "
<                                      + location + " -> " + href);
---
>                 echoBroken("BROKEN  Link in " + location + " -> " + href);
94,99c79,80
<                 if(LinkCheck.loop
<                    && href.startsWith(LinkCheck.root)
<                    && href.matches("^http:.*([?][^?]*|/|\\.(htm|html|shtml|php))$")
<                    && !href.matches("^.*\\.(xslt|java)"))
<                 {
<                   LinkCheck.check(href);
---
>                 if(loop && href.startsWith(root) && href.matches("^http:.*([?][^?]*|/|\\.(htm|html|shtml|php))$") && !href.matches("^.*\\.(xslt|java)")) {
>                   check(href);
102,105c83,84
<                   if(!LinkCheck.anchors.containsKey(href)) {
<                     LinkCheck.anchors.put(href, LinkCheck
<                                           .getAnchorSet(FileManager
<                                                         .load(href)));
---
>                   if(!anchors.containsKey(href)) {
>                     anchors.put(href, getAnchorSet(FileManager.load(href)));
107,114c86,87
<                   if(!LinkCheck.anchors.get(href).contains(
<                        anchor))
<                   {
<                     LinkCheck
<                     .echoBroken("BROKEN  Anchor in "
<                                 + location
<                                 + " -> "
<                                 + href + " #" + anchor);
---
>                   if(!anchors.get(href).contains(anchor)) {
>                     echoBroken("BROKEN  Anchor in " + location + " -> " + href + " #" + anchor);
120,121c93
<             LinkCheck.echoBroken("SPURIOUS Link in " + location
<                                  + " -> " + href + " (" + e + ") ");
---
>             echoBroken("SPURIOUS Link in " + location + " -> " + href + " (" + e + ") ");
125c97
<       LinkCheck.echoBroken("SPURIOUS   " + location + " (" + e + ") ");
---
>       echoBroken("SPURIOUS   " + location + " (" + e + ") ");
129,130c101
<     try {
<       return new URI(location).normalize().toString();
---
>     try { return new URI(location).normalize().toString();
137c108
<     LinkCheck.nbrokens++;
---
>     nbrokens++;
139,142c110,111
<   /**
<    * Renvoie les ancres d'un texte HTML. <div> Ici les attributs
<    * <tt>&lt;a href=..</tt> <tt>&lt;img src=..</tt> sont considérés comme des
<    * liens.</div>
---
>   /** Renvoie les ancres d'un texte HTML.
>    * <div> Ici les attributs  <tt>&lt;a href=..</tt> <tt>&lt;img src=..</tt> sont considérés comme des liens.</div>
147c116
<       Matcher matcher = LinkCheck.linkPattern.matcher(text).region(i, l);
---
>       Matcher matcher = linkPattern.matcher(text).region(i, l);
149c118
<         int i1 = matcher.end(), i2 = LinkCheck.nextQuote(text, i1);
---
>         int i1 = matcher.end(), i2 = nextQuote(text, i1);
161,164c130,131
<   /**
<    * Renvoie les ancres d'un texte HTML. <div> Ici les attributs
<    * <tt>&lt;a name=..</tt> et <tt>&lt; id=..</tt> sont considérés comme des
<    * ancres.</div>
---
>   /** Renvoie les ancres d'un texte HTML.
>    * <div> Ici les attributs <tt>&lt;a name=..</tt> et <tt>&lt; id=..</tt> sont considérés comme des ancres.</div>
167c134
<     HashSet<String> a = LinkCheck.getAnchorSet(text);
---
>     HashSet<String> a = getAnchorSet(text);
173,174c140
<       Matcher matcher = LinkCheck.anchorPattern.matcher(text)
<                         .region(i, l);
---
>       Matcher matcher = anchorPattern.matcher(text).region(i, l);
176c142
<         int i1 = matcher.end(), i2 = LinkCheck.nextQuote(text, i1);
---
>         int i1 = matcher.end(), i2 = nextQuote(text, i1);
190,193c156,157
<   private static final Pattern linkPattern = Pattern
<                                              .compile("(href|HREF|src|SRC)\\s*=\\s*[\"']");
<   private static final Pattern anchorPattern = Pattern
<                                                .compile("<([aA]\\s+(name|NAME)|[^>]+(id|ID))\\s*=\\s*[\"']");
---
>   private static final Pattern linkPattern = Pattern.compile("(href|HREF|src|SRC)\\s*=\\s*[\"']");
>   private static final Pattern anchorPattern = Pattern.compile("<([aA]\\s+(name|NAME)|[^>]+(id|ID))\\s*=\\s*[\"']");

>>> ./src/org/javascool/builder/JarManager.java

9,10c9,10
< import java.io.BufferedInputStream;
< import java.io.BufferedOutputStream;
---
> import org.javascool.tools.FileManager;
> 
11a12,13
> import java.io.OutputStream;
> import java.io.InputStream;
13a16,17
> import java.io.BufferedInputStream;
> import java.io.BufferedOutputStream;
15,16c19,20
< import java.io.InputStream;
< import java.io.OutputStream;
---
> 
> import java.util.Enumeration;
24,29c28
< import org.javascool.tools.FileManager;
< 
< /**
<  * Met à disposition des fonctions de gestion de jar et répertoires de
<  * déploiement.
<  */
---
> /** Met à disposition des fonctions de gestion de jar et répertoires de déploiement. */
33,42c32,36
<   /**
<    * Extrait une arborescence d'un jar.
<    *
<    * @param jarFile
<    *            Jarre dont on extrait les fichiers.
<    * @param destDir
<    *            Dossier où on déploie les fichiers.
<    * @param jarEntry
<    *            Racine des sous-dossiers à extraire. Si null extrait tout les
<    *            fichiers.
---
> 
>   /** Extrait une arborescence d'un jar.
>    * @param jarFile Jarre dont on extrait les fichiers.
>    * @param destDir Dossier où on déploie les fichiers.
>    * @param jarEntry Racine des sous-dossiers à extraire. Si null extrait tout les fichiers.
44,45c38
<   public static void jarExtract(String jarFile, String destDir,
<                                 String jarEntry) {
---
>   public static void jarExtract(String jarFile, String destDir, String jarEntry) {
47,52c40
<       ProgletsBuilder.log("Extract files from "
<                           + jarFile
<                           + " to "
<                           + destDir
<                           + ((!jarEntry.isEmpty()) ? " which start with " + jarEntry
<                              : ""), true);
---
>       ProgletsBuilder.log("Extract files from " + jarFile + " to " + destDir + ((!jarEntry.isEmpty()) ? " which start with " + jarEntry : ""), true);
54,56c42,43
<       JarInputStream jip = new JarInputStream(
<         new FileInputStream(jarFile));
<       jf.entries();
---
>       JarInputStream jip = new JarInputStream(new FileInputStream(jarFile));
>       Enumeration<JarEntry> entries = jf.entries();
59,65c46,47
<         if((jarEntry.isEmpty() ? true : je.getName().startsWith(
<               jarEntry))
<            && !je.isDirectory()
<            && !je.getName().contains("META-INF"))
<         {
<           File dest = new File(destDir + File.separator
<                                + je.getName());
---
>         if((jarEntry.isEmpty() ? true : je.getName().startsWith(jarEntry)) && !je.isDirectory() && !je.getName().contains("META-INF")) {
>           File dest = new File(destDir + File.separator + je.getName());
67c49
<           JarManager.copyStream(jip, new FileOutputStream(dest));
---
>           copyStream(jip, new FileOutputStream(dest));
78c60
<     JarManager.jarExtract(jarFile, destDir, "");
---
>     jarExtract(jarFile, destDir, "");
80,91c62,66
<   /**
<    * Crée un jar à partir d'une arborescence.
<    *
<    * @param jarFile
<    *            Jar à construire. Elle est détruite avant d'être crée.
<    * @param mfFile
<    *            Fichier de manifeste (obligatoire).
<    * @param srcDir
<    *            Dossier source avec les fichiers à mettre en jarre.
<    * @param jarEntries
<    *            Racine des sous-dossiers à extraire. Si null extrait tout les
<    *            fichiers.
---
>   /** Crée un jar à partir d'une arborescence.
>    * @param jarFile Jar à construire. Elle est détruite avant d'être crée.
>    * @param mfFile Fichier de manifeste (obligatoire).
>    * @param srcDir Dossier source avec les fichiers à mettre en jarre.
>    * @param jarEntries Racine des sous-dossiers à extraire. Si null extrait tout les fichiers.
93,94c68
<   public static void jarCreate(String jarFile, String mfFile, String srcDir,
<                                String[] jarEntries) {
---
>   public static void jarCreate(String jarFile, String mfFile, String srcDir, String[] jarEntries) {
104,109c78,80
<       manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION,
<                                        "1.0");
<       JarOutputStream target = new JarOutputStream(new FileOutputStream(
<                                                      jarFile), manifest);
<       JarManager.copyFileToJar(new File(srcDir), target,
<                                new File(srcDir), jarEntries);
---
>       manifest.getMainAttributes().put(Attributes.Name.MANIFEST_VERSION, "1.0");
>       JarOutputStream target = new JarOutputStream(new FileOutputStream(jarFile), manifest);
>       copyFileToJar(new File(srcDir), target, new File(srcDir), jarEntries);
119c90
<     JarManager.jarCreate(jarFile, mfFile, srcDir, null);
---
>     jarCreate(jarFile, mfFile, srcDir, null);
121,127c92,94
<   /**
<    * Copie un répertoire/fichier dans un autre en oubliant les svn.
<    *
<    * @param srcDir
<    *            Dossier source.
<    * @param dstDir
<    *            Dossier cible.
---
>   /** Copie un répertoire/fichier dans un autre en oubliant les svn.
>    * @param srcDir Dossier source.
>    * @param dstDir Dossier cible.
129,130c96
<   public static void copyFiles(String srcDir, String dstDir)
<   throws IOException {
---
>   public static void copyFiles(String srcDir, String dstDir) throws IOException {
134,136c100,101
<           String d = dstDir + File.separator
<                      + new File(s).getAbsoluteFile().getName();
<           JarManager.copyFiles(s, d);
---
>           String d = dstDir + File.separator + new File(s).getAbsoluteFile().getName();
>           copyFiles(s, d);
141,142c106
<       JarManager.copyStream(new FileInputStream(srcDir),
<                             new FileOutputStream(dstDir));
---
>       copyStream(new FileInputStream(srcDir), new FileOutputStream(dstDir));
146,147c110
<   private static void copyFileToJar(File source, JarOutputStream target,
<                                     File root, String[] jarEntries) throws IOException {
---
>   private static void copyFileToJar(File source, JarOutputStream target, File root, String[] jarEntries) throws IOException {
153,154c116
<         skip &= !(entry.startsWith(source.toString()) | source
<                   .toString().startsWith(entry));
---
>         skip &= !(entry.startsWith(source.toString()) | source.toString().startsWith(entry));
159a122
>     BufferedInputStream in = null;
162,164c125
<         String name = source.getPath()
<                       .replace(root.getAbsolutePath() + File.separator, "")
<                       .replace(File.separator, "/");
---
>         String name = source.getPath().replace(root.getAbsolutePath() + File.separator, "").replace(File.separator, "/");
175,176c136
<           JarManager.copyFileToJar(nestedFile, target, root,
<                                    jarEntries);
---
>           copyFileToJar(nestedFile, target, root, jarEntries);
178,180c138
<         JarEntry entry = new JarEntry(source.getPath()
<                                       .replace(root.getAbsolutePath() + File.separator, "")
<                                       .replace(File.separator, "/"));
---
>         JarEntry entry = new JarEntry(source.getPath().replace(root.getAbsolutePath() + File.separator, "").replace(File.separator, "/"));
183,184c141
<         JarManager.copyStream(new BufferedInputStream(
<                                 new FileInputStream(source)), target);
---
>         copyStream(new BufferedInputStream(new FileInputStream(source)), target);
191,196c148,150
<   private static void copyStream(InputStream in, OutputStream out)
<   throws IOException {
<     InputStream i = in instanceof JarInputStream ? in
<                     : new BufferedInputStream(in, 2048);
<     OutputStream o = out instanceof JarOutputStream ? out
<                      : new BufferedOutputStream(out, 2048);
---
>   private static void copyStream(InputStream in, OutputStream out) throws IOException {
>     InputStream i = in instanceof JarInputStream ? in : new BufferedInputStream(in, 2048);
>     OutputStream o = out instanceof JarOutputStream ? out : new BufferedOutputStream(out, 2048);
211,215c165,166
<   /**
<    * Détruit récursivement un fichier ou répertoire. *
<    * <p>
<    * Irréversible: à utiliser avec la plus grande prudence.
<    * </p>
---
>   /** Détruit récursivement un fichier ou répertoire.
>    * * <p>Irréversible: à utiliser avec la plus grande prudence.</p>
220c171
<         JarManager.rmDir(f);
---
>         rmDir(f);

>>> ./src/org/javascool/builder/Jvs2Html.java

3,9d2
< import java.io.File;
< import java.io.IOException;
< import java.io.StringReader;
< import java.io.StringWriter;
< 
< import org.javascool.tools.FileManager;
< 
16a10,13
> import java.io.File;
> import java.io.IOException;
> import java.io.StringReader;
> import java.io.StringWriter;
18,26c15,18
< /**
<  * Convertit une portion de source Java ou Jvs en Html colorisé.
<  * <p>
<  * Note: utilise une version patchée de <a
<  * href="http://www.java2html.de">java2html</a>, disponible dans <a href=
<  * "http://code.google.com/p/javascool/source/browse/work/lib/jvs2html.jar"
<  * >jvs2html.jar</a>, qui doit être dans le CLASSPATH.
<  * </p>
<  * </p>
---
> import org.javascool.tools.FileManager;
> 
> /** Convertit une portion de source Java ou Jvs en Html colorisé.
>  * <p>Note: utilise une version patchée de <a href="http://www.java2html.de">java2html</a>, disponible dans <a href="http://code.google.com/p/javascool/source/browse/work/lib/jvs2html.jar">jvs2html.jar</a>, qui doit être dans le CLASSPATH.</p></p>
35,39c27,29
<   /**
<    * Convertit une portion de source Java ou JVs en Html colorisé..
<    *
<    * @param code
<    *            Le code Java ou Jvs.
---
> 
>   /** Convertit une portion de source Java ou JVs en Html colorisé..
>    * @param code Le code Java ou Jvs.
41,43c31
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite lors de
<    *             l'éxecution.
---
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de l'éxecution.
50,53c38,39
<       JavaSourceConversionOptions options = JavaSourceConversionOptions
<                                             .getDefault();
<       options.getStyleTable().put(JavaSourceType.KEYWORD,
<                                   new JavaSourceStyleEntry(RGB.ORANGE, true, false));
---
>       JavaSourceConversionOptions options = JavaSourceConversionOptions.getDefault();
>       options.getStyleTable().put(JavaSourceType.KEYWORD, new JavaSourceStyleEntry(RGB.ORANGE, true, false));
56,60c42
<       return "<pre>"
<              + writer.toString().replace("\n", "")
<              .replace("<br/>", "\n")
<              .replace("&#160;&#160;&#160;&#160;", "\t")
<              + "</pre>";
---
>       return "<pre>" + writer.toString().replace("\n", "").replace("<br/>", "\n").replace("&#160;&#160;&#160;&#160;", "\t") + "</pre>";
64,71c46,48
<   /**
<    * Convertit un répertoire de source Java vers un autre répertoire en source
<    * HTML Colorisé.
<    *
<    * @param srcDir
<    *            Le répertoire source
<    * @param destDir
<    *            Le répertoire de destination
---
>   /** Convertit un répertoire de source Java vers un autre répertoire en source HTML Colorisé.
>    * @param srcDir Le répertoire source
>    * @param destDir Le répertoire de destination
73,74c50
<    * @throws RuntimeException
<    *             si il y a une erreur durant la convertion
---
>    * @throws RuntimeException si il y a une erreur durant la convertion
78c54
<       new File(srcDir);
---
>       File src = new File(srcDir);
83,85c59
<           FileManager.save(dest.getCanonicalPath() + File.separator
<                            + new File(file).getName() + ".html",
<                            Jvs2Html.run(FileManager.load(file)));
---
>           FileManager.save(dest.getCanonicalPath() + File.separator + new File(file).getName() + ".html", Jvs2Html.run(FileManager.load(file)));
91,96c65,66
<   /**
<    * Lanceur de la conversion d'une portion de source Java ou Jvs en Html
<    * colorisé.
<    *
<    * @param usage
<    *            <tt>java org.javascool.builder.Jvs2Html input-file [output-file]</tt>
---
>   /** Lanceur de la conversion d'une portion de source Java ou Jvs en Html colorisé.
>    * @param usage <tt>java org.javascool.builder.Jvs2Html input-file [output-file]</tt>
101,102c71
<       FileManager.save(usage.length > 1 ? usage[1] : "stdout:",
<                        Jvs2Html.run(FileManager.load(usage[0])));
---
>       FileManager.save(usage.length > 1 ? usage[1] : "stdout:", run(FileManager.load(usage[0])));

>>> ./src/org/javascool/gui2/TextFilesEditor.java

3,4c3,4
< import java.awt.BorderLayout;
< 
---
> import org.javascool.widgets.TabbedPane;
> import org.javascool.widgets.ToolBar;
8,9c8
< import org.javascool.widgets.TabbedPane;
< import org.javascool.widgets.ToolBar;
---
> import java.awt.BorderLayout;
11,14c10
< /**
<  * Définit un panneau éditeur de plusieurs fichiers texte qui intègre les
<  * fonctions de colorisation et de complétion automatique.
<  *
---
> /** Définit un panneau éditeur de plusieurs fichiers texte qui intègre les fonctions de colorisation et de complétion automatique.
20,31c16,20
<   /**
<    * Ouvre un éditeur dans une fenêtre autonome.
<    *
<    * @param title
<    *            Le titre de la fenêtre.
<    * @param width
<    *            Largeur de la fenêtre. Si 0 on prend tout l'écran.
<    * @param height
<    *            Hauteur de la fenêtre. Si 0 on prend tout l'écran.
<    * @param extension
<    *            Extension des fichiers par exemple "java" ou "jvs", ou null
<    *            (valeur par défaut) pour pas fixer d'extension
---
>   /** Ouvre un éditeur dans une fenêtre autonome.
>    * @param title Le titre de la fenêtre.
>    * @param width Largeur de la fenêtre. Si 0 on prend tout l'écran.
>    * @param height Hauteur de la fenêtre. Si 0 on prend tout l'écran.
>    * @param extension Extension des fichiers par exemple "java" ou "jvs", ou null (valeur par défaut) pour pas fixer d'extension
34,37c23,24
<   public static MainFrame newTextFilesEditor(String title, int width,
<                                              int height, String extension) {
<     return new MainEditorFrame().reset(title, width, height,
<                                        new TextFilesEditor().setExtension(extension));
---
>   public static MainFrame newTextFilesEditor(String title, int width, int height, String extension) {
>     return new MainEditorFrame().reset(title, width, height, new TextFilesEditor().setExtension(extension));
40,46c27
<     /**
<      *
<      */
<     private static final long serialVersionUID = -1177064832805212550L;
< 
<     public MainFrame reset(String title, int width, int height,
<                            TextFilesEditor editor) {
---
>     public MainFrame reset(String title, int width, int height, TextFilesEditor editor) {
61,65c42,43
<   /**
<    * Ajoute à une barre de menu les boutons de contrôle de ce panneau.
<    *
<    * @param toolbar
<    *            La barre de menu à utiliser.
---
>   /** Ajoute à une barre de menu les boutons de contrôle de ce panneau.
>    * @param toolbar La barre de menu à utiliser.
68,69c46
<     toolbar.addTool("Nouveau fichier",
<                     "org/javascool/widgets/icons/new.png", new Runnable() {
---
>     toolbar.addTool("Nouveau fichier", "org/javascool/widgets/icons/new.png", new Runnable() {
76,77c53
<     toolbar.addTool("Ouvrir un fichier",
<                     "org/javascool/widgets/icons/open.png", new Runnable() {
---
>     toolbar.addTool("Ouvrir un fichier", "org/javascool/widgets/icons/open.png", new Runnable() {
84,85c60
<     toolbar.addTool("Sauver", "org/javascool/widgets/icons/save.png",
<                     new Runnable() {
---
>     toolbar.addTool("Sauver", "org/javascool/widgets/icons/save.png", new Runnable() {
92,93c67
<     toolbar.addTool("Sauver sous",
<                     "org/javascool/widgets/icons/saveas.png", new Runnable() {
---
>     toolbar.addTool("Sauver sous", "org/javascool/widgets/icons/saveas.png", new Runnable() {
101,108c75,77
<   /**
<    * Définit l'extension des fichiers si celle si est forcée.
<    *
<    * @param extension
<    *            Extension des fichiers par exemple "java" ou "jvs", ou null
<    *            (valeur par défaut) pour pas fixer d'extension.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new TextFilesEditor().setExtension(..)</tt>.
---
>   /** Définit l'extension des fichiers si celle si est forcée.
>    * @param extension Extension des fichiers par exemple "java" ou "jvs", ou null (valeur par défaut) pour pas fixer d'extension.
>    * @return Cet objet, permettant de définir la construction <tt>new TextFilesEditor().setExtension(..)</tt>.
118,124c87
<   /** Ouvre un nouveau fichier.
<    *
<    */
<   public void openNewFile() {
<     openFile(false);
<   }
<   private String extension = "jvs";
---
>   private String extension = null;
126,127c89
<   // Ouvre une nouvelle fenêtre d'édition, vide ou à partir d'un dialogue
<   // utilisateur.
---
>   // Ouvre une nouvelle fenêtre d'édition, vide ou à partir d'un dialogue utilisateur.
135c97
<       addTab(file.getName(), file, true);
---
>       addTab("Nouveau fichier", file, true);
139,140c101
<   // Teste si un fichier n'est pas déjà ouvert à moins de souhaiter forcer son
<   // ouverture
---
>   // Teste si un fichier n'est pas déjà ouvert à moins de souhaiter forcer son ouverture
144,148c105
<       if(getComponentAt(i) instanceof TextFileEditor
<          && file.getFileLocation().equals(
<            ((TextFileEditor) getComponentAt(i))
<            .getFileLocation()))
<       {
---
>       if(getComponentAt(i) instanceof TextFileEditor && file.getFileLocation().equals(((TextFileEditor) getComponentAt(i)).getFileLocation())) {
152,158c109,112
<       int r = JOptionPane
<               .showConfirmDialog(
<         null,
<         "Le fichier "
<         + file.getName()
<         + " est déjà ouvert, voulez-vous vraiment éditer «sur» l'autre version ?",
<         "Erreur d'ouverture", JOptionPane.YES_NO_OPTION);
---
>       int r = JOptionPane.showConfirmDialog(null,
>                                             "Le fichier " + file.getName() + " est déjà ouvert, voulez-vous vraiment éditer «sur» l'autre version ?",
>                                             "Erreur d'ouverture",
>                                             JOptionPane.YES_NO_OPTION);
164,165c118
<   private boolean saveFile(boolean saveAs) {
<     boolean r = false;
---
>   private void saveFile(boolean saveAs) {
168c121
<         r = selectedFile.saveAs();
---
>         selectedFile.saveAs();
170c123
<         r = selectedFile.save(false);
---
>         selectedFile.save(false);
174d126
<     return r;
182,184c134
<     if((getSelectedIndex() != -1)
<        && getComponentAt(getSelectedIndex()) instanceof TextFileEditor)
<     {
---
>     if((getSelectedIndex() != -1) && getComponentAt(getSelectedIndex()) instanceof TextFileEditor) {
189c139,140
<                                       "Il n'y a aucun fichier sélectionné !", "Erreur",
---
>                                       "Il n'y a aucun fichier sélectionné !",
>                                       "Erreur",
197,199c148
<   /**
<    * Ferme tous les fichiers.
<    *
---
>   /** Ferme tous les fichiers.
208,247c157,158
<   /**
<    * Vérifie que le fichier courant est compilable.
<    *
<    * @return La valeur vraie si c'est bon, faux sinon.
<    */
<   public boolean isCompilable() {
<     if(getSelectedFile(false) == null) {
<       return false;
<     }
<     if(getSelectedFile(false).isTmp()) {
<       return saveFile(true);
<     }
<     return getSelectedFile(false).save(true);
<   }
<   /**
<    * Efface toutes les lignes mises en valeur dans tous les onglets ouverts
<    */
<   public void removeLineSignals() {
<     for(int i = 0; i < getTabCount(); i++) {
<       if(!(getComponentAt(i) instanceof TextFileEditor)) {
<         continue;
<       }
<       ((TextFileEditor) getComponentAt(i)).removeLineSignals();
<     }
<   }
<   /** Instance de la classe. */
<   private static TextFilesEditor editors;
< 
<   /** Permet d'avoir une instance unique de la classe.*/
<   public static TextFilesEditor getInstance() {
<     if(TextFilesEditor.editors == null) {
<       TextFilesEditor.editors = new TextFilesEditor();
<     }
<     return TextFilesEditor.editors;
<   }
<   /**
<    * Lanceur du mécanisme d'éditon.
<    *
<    * @param usage
<    *            <tt>java org.javascool.gui2.TextFilesEditor</tt>
---
>   /** Lanceur du mécanisme d'éditon.
>    * @param usage <tt>java org.javascool.gui2.TextFilesEditor</tt>

>>> ./src/org/javascool/gui2/TextFileEditor.java

3c3
< import java.io.File;
---
> import org.javascool.widgets.TextEditor;
4a5,6
> import java.io.File;
> import javax.swing.JFileChooser;
6,7d7
< import javax.swing.UIManager;
< 
10c10
< import org.javascool.widgets.TextEditor;
---
> import javax.swing.UIManager;
12,15c12
< /**
<  * Définit un panneau éditeur d'un fichier texte qui intègre les fonctions de
<  * colorisation et de complétion automatique.
<  *
---
> /** Définit un panneau éditeur d'un fichier texte qui intègre les fonctions de colorisation et de complétion automatique.
26,28c23
<   /**
<    * Renvoie la localisation du fichier.
<    *
---
>   /** Renvoie la localisation du fichier.
34,40d28
<   /** Construit un éditeur de Fichier
<    * Surcharge la classe
<    */
<   public TextFileEditor() {
<     super();
<     setName("Nouveau Fichier");
<   }
46,69c34,45
<   // @todo: Ce n'est pas la meilleur solution
< // /**
< // * Renvoie le nom du fichier définit par la localisation.
< // *
< // * @return Le nom du fichier (sans extension si celle si est forcée), ou
< // *         null si indéfini.
< // */
< // @Override
< // public String getName() {
< // String name = location == null ? "Fichier sans nom" : location.replaceAll(".*/", "");
< // return name == null ? name : name.replaceFirst("\\.[^.]*$", ""); // @todo: Pourquoi le cacher à l'utilisateur ?
< // }
< 
<   /**
<    * Définit l'extension du fichier si celle si est forcée.
<    * <p>
<    * Cette extension définie la syntaxe de l'éditeur.
<    * </p>
<    *
<    * @param extension
<    *            Extension du fichier par exemple "java" ou "jvs", ou "txt"
<    *            (valeur par défaut) pour pas fixer d'extension.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new TextFileEditor().setExtension(..)</tt>.
---
>   /** Renvoie le nom du fichier définit par la localisation.
>    * @return Le nom du fichier (sans extension si celle si est forcée), ou null si indéfini.
>    */
>   @Override
>   public String getName() {
>     String name = location == null ? null : location.replaceAll(".*/", "");
>     return name == null ? name : name.replaceFirst("\\.[^.]*$", "");
>   }
>   /** Définit l'extension du fichier si celle si est forcée.
>    * <p>Cette extension définie la syntaxe de l'éditeur.</p>
>    * @param extension Extension du fichier par exemple "java" ou "jvs", ou null (valeur par défaut) pour pas fixer d'extension.
>    * @return Cet objet, permettant de définir la construction <tt>new TextFileEditor().setExtension(..)</tt>.
75c51
<   private String extension = "txt";
---
>   private String extension = null;
77,82c53,54
<   /**
<    * Charge le texte à partir d'un fichier local.
<    * <p>
<    * Lance un dialogue avec l'utilisateur pour choisir le fichier.
<    * </p>
<    *
---
>   /** Charge le texte à partir d'un fichier local.
>    * <p>Lance un dialogue avec l'utilisateur pour choisir le fichier.</p>
86,88c58,65
<     try {
<       File f = FileManager.openFile(TextFileEditor.getWorkingDir());
<       TextFileEditor.setWorkingDir(f.getParentFile().getAbsolutePath());
---
>     JFileChooser fc = new JFileChooser();
>     String dir = getWorkingDir();
>     if(dir != null) {
>       fc.setCurrentDirectory(new File(dir));
>     }
>     int returnVal = fc.showOpenDialog(null);
>     if(returnVal == JFileChooser.APPROVE_OPTION) {
>       setWorkingDir(fc.getSelectedFile().getParentFile().getAbsolutePath());
90,91c67
<         load(f.getAbsolutePath());
<         setName(f.getName());
---
>         load(fc.getSelectedFile().getAbsolutePath());
94,98c70,73
<         JOptionPane
<         .showMessageDialog(
<           null,
<           "Le fichier ne peut pas être lu, il est inaccessible en tant que fichier texte.",
<           "Erreur de lecture", JOptionPane.ERROR_MESSAGE);
---
>         JOptionPane.showMessageDialog(null,
>                                       "Le fichier ne peut pas être lu, il est inaccessible en tant que fichier texte.",
>                                       "Erreur de lecture",
>                                       JOptionPane.ERROR_MESSAGE);
101c76
<     } catch(IllegalStateException e) { // L'utilisateur a annulé la demande
---
>     } else {
103,125c78
<     } /*
<        *  JFileChooser fc = new JFileChooser();
<        *  String dir = TextFileEditor.getWorkingDir();
<        *  if (dir != null) {
<        *  fc.setCurrentDirectory(new File(dir));
<        *  }
<        *  int returnVal = fc.showOpenDialog(null);
<        *  if (returnVal == JFileChooser.APPROVE_OPTION) {
<        *  TextFileEditor.setWorkingDir(fc.getSelectedFile().getParentFile()
<        *   .getAbsolutePath());
<        *  try {
<        *  load(fc.getSelectedFile().getAbsolutePath());
<        *  return true;
<        *  } catch (Exception e) {
<        *  JOptionPane
<        *     .showMessageDialog(
<        *         null,
<        *         "Le fichier ne peut pas être lu, il est inaccessible en tant que fichier texte.",
<        *         "Erreur de lecture", JOptionPane.ERROR_MESSAGE);
<        *  return false;
<        *  }
<        *  } else
<        *  return false;*/
---
>     }
131,133c84
<     } else if(System.getProperty("os.name").toLowerCase().contains("nix")
<               || System.getProperty("os.name").toLowerCase().contains("nux"))
<     {
---
>     } else if(System.getProperty("os.name").toLowerCase().contains("nix") || System.getProperty("os.name").toLowerCase().contains("nux")) {
145,146c96
<   /**
<    * Charge le texte à partir d'une localisation.
---
>   /** Charge le texte à partir d'une localisation.
148,175c98,105
<    * @param location
<    *            Une URL (Universal Resource Location) de la forme: <div
<    *            id="load-format">
<    *            <table align="center">
<    *            <tr>
<    *            <td><tt>http:/<i>path-name</i></tt></td>
<    *            <td>pour aller chercher le contenu sur un site web</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>http:/<i>path-name</i>?param_i=value_i&amp;..</tt></td>
<    *            <td>pour le récupérer sous forme de requête HTTP</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>file:/<i>path-name</i></tt></td>
<    *            <td>pour le charger du système de fichier local ou en tant que
<    *            ressource Java dans le CLASSPATH</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>jar:/<i>jar-path-name</i>!/<i>jar-entry</i></tt></td>
<    *            <td>pour le charger d'une archive <div>(exemple:
<    *            <tt>jar:http://javascool.gforge.inria.fr/javascool.jar!/META-INF/MANIFEST.MF</tt>
<    *            )</div></td>
<    *            </tr>
<    *            </table>
<    *            </div>
<    * @param utf8
<    *            Si la valeur est vraie, force l'encodage en UTF-8 à la
<    *            lecture. Par défaut (false) utilise l'encodage local.
---
>    * @param location Une URL (Universal Resource Location) de la forme: <div id="load-format"><table align="center">
>    * <tr><td><tt>http:/<i>path-name</i></tt></td><td>pour aller chercher le contenu sur un site web</td></tr>
>    * <tr><td><tt>http:/<i>path-name</i>?param_i=value_i&amp;..</tt></td><td>pour le récupérer sous forme de requête HTTP</td></tr>
>    * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour le charger du système de fichier local ou en tant que ressource Java dans le CLASSPATH</td></tr>
>    * <tr><td><tt>jar:/<i>jar-path-name</i>!/<i>jar-entry</i></tt></td><td>pour le charger d'une archive
>    *  <div>(exemple:<tt>jar:http://javascool.gforge.inria.fr/javascool.jar!/META-INF/MANIFEST.MF</tt>)</div></td></tr>
>    * </table></div>
>    * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
177,180c107,108
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si l'URL est mal formée.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
192,197c120,121
<   /**
<    * Sauve le texte dans un fichier local.
<    * <p>
<    * Lance un dialogue avec l'utilisateur pour choisir le fichier.
<    * </p>
<    *
---
>   /** Sauve le texte dans un fichier local.
>    * <p>Lance un dialogue avec l'utilisateur pour choisir le fichier.</p>
201,208c125,135
<     try {
<       File f = FileManager.saveFile(false, TextFileEditor.getWorkingDir());
<       if(!f.getName().endsWith('.' + extension)) {
<         f = (new File(f.getAbsolutePath() + '.' + extension));
<       }
<       TextFileEditor.setWorkingDir(f.getParentFile().getAbsolutePath());
<       save(f.getAbsolutePath());
<       setName(f.getName());
---
>     JFileChooser fc = new JFileChooser();
>     String dir = getWorkingDir();
>     if(dir != null) {
>       fc.setCurrentDirectory(new File(dir));
>     }
>     fc.setApproveButtonText("Enregistrer");
>     fc.setDialogTitle("Enregistrer");
>     int returnVal = fc.showOpenDialog(this.getParent());
>     if(returnVal == JFileChooser.APPROVE_OPTION) {
>       setWorkingDir(fc.getSelectedFile().getParentFile().getAbsolutePath());
>       save(fc.getSelectedFile().getAbsolutePath());
210c137
<     } catch(IllegalStateException e) { // L'utilisateur a annulé la demande
---
>     } else {
213,227d139
<     /*JFileChooser fc = new JFileChooser();
<      *  String dir = TextFileEditor.getWorkingDir();
<      *  if (dir != null) {
<      *  fc.setCurrentDirectory(new File(dir));
<      *  }
<      *  fc.setApproveButtonText("Enregistrer");
<      *  fc.setDialogTitle("Enregistrer");
<      *  int returnVal = fc.showOpenDialog(this.getParent());
<      *  if (returnVal == JFileChooser.APPROVE_OPTION) {
<      *  TextFileEditor.setWorkingDir(fc.getSelectedFile().getParentFile()
<      *     .getAbsolutePath());
<      *  save(fc.getSelectedFile().getAbsolutePath());
<      *  return true;
<      *  } else
<      *  return false;*/
229,233c141,142
<   /**
<    * Sauve le texte à la dernière location choisie, si le texte a été modifié.
<    *
<    * @param confirm
<    *            Si true demande à l'utilisateur confirmation avant de sauver.
---
>   /** Sauve le texte à la dernière location choisie, si le texte a été modifié.
>    * @param confirm Si true demande à l'utilisateur confirmation avant de sauver.
240,241c149
<                                               "Voulez vous enregistrer " + getName()
<                                               + " avant de continuer ?");
---
>                                               "Voulez vous enregistrer " + getName() + " avant de continuer ?");
254,259c162,163
<               int r = JOptionPane
<                       .showConfirmDialog(
<                 null,
<                 "Le fichier "
<                 + getName()
<                 + " a été modifié par un autre logiciel : voulez-vous écraser ces modifications ?");
---
>               int r = JOptionPane.showConfirmDialog(null,
>                                                     "Le fichier " + getName() + " a été modifié par un autre logiciel : voulez-vous écraser ces modifications ?");
270,275c174,177
<           JOptionPane
<           .showMessageDialog(
<             null,
<             "Le fichier ne peut pas être écrit ici, choisisez un nouvel endroit.",
<             "Erreur d'écriture",
<             JOptionPane.ERROR_MESSAGE);
---
>           JOptionPane.showMessageDialog(null,
>                                         "Le fichier ne peut pas être écrit ici, choisisez un nouvel endroit.",
>                                         "Erreur d'écriture",
>                                         JOptionPane.ERROR_MESSAGE);
283,284c185
<   /**
<    * Sauve le texte dans une localisation.
---
>   /** Sauve le texte dans une localisation.
286,317c187,195
<    * @param location
<    *            Une URL (Universal Resource Location) de la forme: <div
<    *            id="save-format">
<    *            <table>
<    *            <tr>
<    *            <td><tt>ftp:/<i>path-name</i></tt></td>
<    *            <td>pour sauver sur un site FTP.</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>file:/<i>path-name</i></tt></td>
<    *            <td>pour sauver dans le système de fichier local (le
<    *            <tt>file:</tt> est optionnel).</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>mailto:<i>address</i>?subject=<i>subject</i></tt></td>
<    *            <td>pour envoyer un courriel avec le texte en contenu.</td>
<    *            </tr>
<    *            <tr>
<    *            <td><tt>stdout:/</tt></td>
<    *            <td>pour l'imprimer dans la console.</td>
<    *            </tr>
<    *            </table>
<    *            </div>
<    * @param backup
<    *            Si true, dans le cas d'un fichier, crée une sauvegarde d'un
<    *            fichier existant. Par défaut false. *
<    *            <p>
<    *            Le fichier sauvegardé est doté d'un suffixe numérique unique.
<    *            </p>
<    * @param utf8
<    *            Si la valeur est vraie, force l'encodage en UTF-8 à la
<    *            lecture. Par défaut (false) utilise l'encodage local.
---
>    * @param location Une URL (Universal Resource Location) de la forme: <div id="save-format"><table>
>    * <tr><td><tt>ftp:/<i>path-name</i></tt></td><td>pour sauver sur un site FTP.</td></tr>
>    * <tr><td><tt>file:/<i>path-name</i></tt></td><td>pour sauver dans le système de fichier local (le <tt>file:</tt> est optionnel).</td></tr>
>    * <tr><td><tt>mailto:<i>address</i>?subject=<i>subject</i></tt></td><td>pour envoyer un courriel avec le texte en contenu.</td></tr>
>    * <tr><td><tt>stdout:/</tt></td><td>pour l'imprimer dans la console.</td></tr>
>    * </table></div>
>    * @param backup Si true, dans le cas d'un fichier, crée une sauvegarde d'un fichier existant. Par défaut false.
>    * * <p>Le fichier sauvegardé est doté d'un suffixe numérique unique.</p>
>    * @param utf8 Si la valeur est vraie, force l'encodage en UTF-8 à la lecture. Par défaut (false) utilise l'encodage local.
319,322c197,198
<    * @throws IllegalArgumentException
<    *             Si l'URL est mal formée.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite.
---
>    * @throws IllegalArgumentException Si l'URL est mal formée.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite.
343,348d218
<   /** Dit si le fichier est temporaire (uniquement en mémoire).
<    *
<    */
<   public boolean isTmp() {
<     return location == null;
<   }
351,352c221
<     return "<TextFileEditor location=\"" + location + "\" name=\""
<            + getName() + "\"/>";
---
>     return "<TextFileEditor location=\"" + location + "\" name=\"" + getName() + "\"/>";

>>> ./src/org/javascool/Build.java

5d4
< 
10,11c9
< /**
<  * Lanceur de l'application "formateur" qui permet de construire des «proglets».
---
> /** Lanceur de l'application "formateur" qui permet de construire des «proglets».
20,24c18,19
<   /**
<    * Lanceur de la conversion Jvs en Java.
<    *
<    * @param usage
<    *            <tt>java org.javascool.Build  [-q [targetDir]]</tt>
---
>   /** Lanceur de la conversion Jvs en Java.
>    * @param usage <tt>java org.javascool.Build  [-q [targetDir]]</tt>
30,31c25
<     ProgletsBuilder.setVerbose(args.getBoolean("v")
<                                || args.getBoolean("verbose"));
---
>     ProgletsBuilder.setVerbose(args.getBoolean("v") || args.getBoolean("verbose"));
33,36c27,28
<       System.out
<       .println("Java's Cool Builder - Construit un jar avec les proglets souhaitées");
<       System.out
<       .println("Usage : java -jar javascool-builder.jar [-q] [-w] [-v] [-target target-dir] [-proglets proglet-list]");
---
>       System.out.println("Java's Cool Builder - Construit un jar avec les proglets souhaitées");
>       System.out.println("Usage : java -jar javascool-builder.jar [-q] [-w] [-v] [-target target-dir] [-proglets proglet-list]");
38,47c30,34
<       System.out
<       .println("\t-q\tPermet de lancer l'application en console sur toutes les proglets disponibles et sans interface graphique.");
<       System.out
<       .println("\t-w\tPermet de lancer l'application en console et génère les fichiers javadoc et jars des proglets.");
<       System.out
<       .println("\t-v\tPermet de lancer l'application en mode verbose, toute les étapes sont affiché.");
<       System.out
<       .println("\t-target target-dir\tLe répertoire cible dans lequel la construction se fait (c'est le répertoire temporaire .build par défaut).");
<       System.out
<       .println("\t-proglets proglet-dir\tLes proglets à prendre en compte (elle le sont toutes part défaut).");
---
>       System.out.println("\t-q\tPermet de lancer l'application en console sur toutes les proglets disponibles et sans interface graphique.");
>       System.out.println("\t-w\tPermet de lancer l'application en console et génère les fichiers javadoc et jars des proglets.");
>       System.out.println("\t-v\tPermet de lancer l'application en mode verbose, toute les étapes sont affiché.");
>       System.out.println("\t-target target-dir\tLe répertoire cible dans lequel la construction se fait (c'est le répertoire temporaire .build par défaut).");
>       System.out.println("\t-proglets proglet-dir\tLes proglets à prendre en compte (elle le sont toutes part défaut).");
52,57c39
<         if(args.isDefined("target")
<            && new File(".").getCanonicalPath().equals(
<              new File(args.getString("target"))
<              .getCanonicalPath()))
<         { throw new IllegalArgumentException(
<                   "Le répertoire du sketchbook et celui du build ne peuvent pas être identiques !!!");
---
>         if(args.isDefined("target") && new File(".").getCanonicalPath().equals(new File(args.getString("target")).getCanonicalPath())) { throw new IllegalArgumentException("Le répertoire du sketchbook et celui du build ne peuvent pas être identiques !!!");
59,60c41
<       } catch(IOException e) { throw new IllegalArgumentException(
<                                        "Le répertoire du build n'est pas utilisable.");
---
>       } catch(IOException e) { throw new IllegalArgumentException("Le répertoire du build n'est pas utilisable.");
62,70c43,46
<       ProgletsBuilder.setVerbose(args.getBoolean("v")
<                                  || args.getBoolean("verbose"));
<       String target = args.isDefined("target") ? args.getString("target")
<                       : null;
<       String names[] = args.isDefined("proglets") ? args
<                        .getString("proglets").trim().split("[, \t]+") : null;
<       System.exit(ProgletsBuilder.build(
<                     ProgletsBuilder.getProglets(names), target,
<                     args.getBoolean("w")) ? 0 : -1);
---
>       ProgletsBuilder.setVerbose(args.getBoolean("v") || args.getBoolean("verbose"));
>       String target = args.isDefined("target") ? args.getString("target") : null;
>       String names[] = args.isDefined("proglets") ? args.getString("proglets").trim().split("[, \t]+") : null;
>       System.exit(ProgletsBuilder.build(ProgletsBuilder.getProglets(names), target, args.getBoolean("w")) ? 0 : -1);

>>> ./src/org/javascool/gui/JVSToolBar.java

3c3
< import javax.swing.JButton;
---
> import org.javascool.core.ProgletEngine;
4a5,6
> import org.javascool.widgets.ToolBar;
> import javax.swing.JButton;
7,8d8
< import org.javascool.builder.ProgletsBuilder;
< import org.javascool.core.ProgletEngine;
10c10
< import org.javascool.widgets.ToolBar;
---
> import org.javascool.builder.ProgletsBuilder;
12,15c12,14
< /**
<  * La barre d'outils de Java's cool Elle est placée en haut de l'interface. Elle
<  * contient les boutons de gestion des fichiers, de compilation et d'éxecution.
<  *
---
> /** La barre d'outils de Java's cool
>  * Elle est placée en haut de l'interface. Elle contient les boutons de gestion
>  * des fichiers, de compilation et d'éxecution.
29,30c28,29
<     if(JVSToolBar.jvstb == null) {
<       JVSToolBar.jvstb = new JVSToolBar();
---
>     if(jvstb == null) {
>       jvstb = new JVSToolBar();
32c31
<     return JVSToolBar.jvstb;
---
>     return jvstb;
40,41c39
<     addTool("Nouvelle activité", "org/javascool/widgets/icons/new.png",
<             new Runnable() {
---
>     addTool("Nouvelle activité", "org/javascool/widgets/icons/new.png", new Runnable() {
48,49c46
<     addTool("Nouveau fichier", "org/javascool/widgets/icons/new.png",
<             new Runnable() {
---
>     addTool("Nouveau fichier", "org/javascool/widgets/icons/new.png", new Runnable() {
56,57c53
<     addTool("Ouvrir un fichier", "org/javascool/widgets/icons/open.png",
<             new Runnable() {
---
>     addTool("Ouvrir un fichier", "org/javascool/widgets/icons/open.png", new Runnable() {
64,65c60
<     addTool("Sauver", "org/javascool/widgets/icons/save.png",
<             new Runnable() {
---
>     addTool("Sauver", "org/javascool/widgets/icons/save.png", new Runnable() {
72,73c67
<     addTool("Sauver sous", "org/javascool/widgets/icons/saveas.png",
<             new Runnable() {
---
>     addTool("Sauver sous", "org/javascool/widgets/icons/saveas.png", new Runnable() {
81,82c75
<     compileButton = addTool("Compiler",
<                             "org/javascool/widgets/icons/compile.png", new Runnable() {
---
>     compileButton = addTool("Compiler", "org/javascool/widgets/icons/compile.png", new Runnable() {
111,112c104
<     this.demoButton = addTool("Demo",
<                               "org/javascool/widgets/icons/play.png", new Runnable() {
---
>     this.demoButton = addTool("Demo", "org/javascool/widgets/icons/play.png", new Runnable() {
123,129c115,121
<       addRightTool("Proglet Builder", new Runnable() {
<                      @Override
<                      public void run() {
<                        DialogFrame.startFrame();
<                      }
<                    }
<                    );
---
>       pbutton = addRightTool("Proglet Builder", new Runnable() {
>                                @Override
>                                public void run() {
>                                  DialogFrame.startFrame();
>                                }
>                              }
>                              );
132a125,127
>   // @ inner-class-variable
>   private JButton pbutton;
> 

>>> ./src/org/javascool/gui/JVSWidgetPanel.java

3,4d2
< import javax.swing.JScrollPane;
< 
6d3
< import org.javascool.core.Proglet;
7a5
> import org.javascool.core.ProgletEngine.Proglet;
8a7
> import javax.swing.JScrollPane;
12,16c11,13
< /**
<  * Le panneau contenant les widgets Les widgets de Java's cool sont disposés
<  * dans des onglets. Certain onglets de navigation web peuvent être fermés par
<  * une croix.
<  *
---
> /** Le panneau contenant les widgets
>  * Les widgets de Java's cool sont disposés dans des onglets. Certain onglets de
>  * navigation web peuvent être fermés par une croix.
28,29c25,26
<     if(JVSWidgetPanel.jwp == null) {
<       JVSWidgetPanel.jwp = new JVSWidgetPanel();
---
>     if(jwp == null) {
>       jwp = new JVSWidgetPanel();
31c28
<     return JVSWidgetPanel.jwp;
---
>     return jwp;
37,42c34,36
<   /**
<    * Charge les tabs de la proglet Charge le tab de la proglet (Panel) et
<    * l'HTMLDisplay avec le fichier d'aide.
<    *
<    * @param name
<    *            Le nom du package de la proglet
---
>   /** Charge les tabs de la proglet
>    * Charge le tab de la proglet (Panel) et l'HTMLDisplay avec le fichier d'aide.
>    * @param name Le nom du package de la proglet
49,50c43
<       this.progletTabId = this.add("Proglet " + name, "",
<                                    new JScrollPane(proglet.getPane()));
---
>       this.progletTabId = this.add("Proglet " + name, "", new JScrollPane(proglet.getPane()));
53,54c46
<       this.add("Aide de la proglet", "", new HtmlDisplay().setPage(Macros
<                                                                    .getResourceURL(proglet.getHelp())));
---
>       this.add("Aide de la proglet", "", new HtmlDisplay().setPage(Macros.getResourceURL(proglet.getHelp())));
71,79c63,67
<   /**
<    * Ouvre un nouvel onglet web Ouvre un nouveau HTMLDisplay dans un onglet.
<    * Cet onglet peut être fermer à l'aide de la croix qui se situe à droite du
<    * titre de l'onglet.
<    *
<    * @param url
<    *            L'url de la page à charger
<    * @param tabName
<    *            Le titre du tab à ouvrir
---
>   /** Ouvre un nouvel onglet web
>    * Ouvre un nouveau HTMLDisplay dans un onglet. Cet onglet peut être fermer à
>    * l'aide de la croix qui se situe à droite du titre de l'onglet.
>    * @param url L'url de la page à charger
>    * @param tabName Le titre du tab à ouvrir

>>> ./src/org/javascool/gui/JvsXMLCompletion.java

14d13
< 
17d15
< 
22d19
< import org.fife.ui.autocomplete.FunctionCompletion;
29,30c26
<  * Parser for an XML file describing a procedural language such as JVS.
<  * <p>
---
>  * Parser for an XML file describing a procedural language such as JVS.<p>
38c34
<   private List<Completion> completions;
---
>   private List completions;
61,64c57,60
<    * The class loader to use to load custom completion classes, such as the
<    * one defined by {@link #funcCompletionType}. If this is <code>null</code>,
<    * then a default class loader is used. This field will usually be
<    * <code>null</code>.
---
>    * The class loader to use to load custom completion classes, such as
>    * the one defined by {@link #funcCompletionType}.  If this is
>    * <code>null</code>, then a default class loader is used.  This field
>    * will usually be <code>null</code>.
71,72c67
<    * @param provider
<    *            The provider to get completions for.
---
>    * @param provider The provider to get completions for.
81,88c76,80
<    * @param provider
<    *            The provider to get completions for.
<    * @param cl
<    *            The class loader to use, if necessary, when loading classes
<    *            from the XML (custom {@link FunctionCompletion}s, for
<    *            example). This may be <code>null</code> if the default is to
<    *            be used, or if the XML does not define specific classes for
<    *            completion types.
---
>    * @param provider The provider to get completions for.
>    * @param cl The class loader to use, if necessary, when loading classes
>    *        from the XML  (custom {@link FunctionCompletion}s, for example).
>    *        This may be <code>null</code> if the default is to be used, or
>    *        if the XML does not define specific classes for completion types.
96c88
<       completionCL = JvsXMLCompletion.DEFAULT_COMPLETION_CLASS_LOADER;
---
>       completionCL = DEFAULT_COMPLETION_CLASS_LOADER;
98c90
<     completions = new ArrayList<Completion>();
---
>     completions = new ArrayList();
160,161c152
<    * @param provider
<    *            The new provider to get completions for.
---
>    * @param provider The new provider to get completions for.
173,174c164
<    * from XML.
<    * <p>
---
>    * from XML.<p>
178,180c168,169
<    * @param cl
<    *            The class loader to use. If this is <code>null</code>, then a
<    *            default is used.
---
>    * @param cl The class loader to use.  If this is <code>null</code>, then
>    *        a default is used.
183c172
<     JvsXMLCompletion.DEFAULT_COMPLETION_CLASS_LOADER = cl;
---
>     DEFAULT_COMPLETION_CLASS_LOADER = cl;
196,197c185
<         shortDesc = attrs.getIndex("title") > -1 ? attrs
<                     .getValue("title") : "";
---
>         shortDesc = attrs.getIndex("title") > -1 ? attrs.getValue("title") : "";
209c197
<   public List<Completion> getCompletions() {
---
>   public List getCompletions() {
212,213c200
<   public static DefaultCompletionProvider readCompletionToProvider(
<     String file, DefaultCompletionProvider cp) {
---
>   public static DefaultCompletionProvider readCompletionToProvider(String file, DefaultCompletionProvider cp) {
215,218c202,203
<     JvsXMLCompletion handler = new JvsXMLCompletion(cp,
<                                                     ClassLoader.getSystemClassLoader());
<     BufferedInputStream bin = new BufferedInputStream(ClassLoader
<                                                       .getSystemClassLoader().getResourceAsStream(file));
---
>     JvsXMLCompletion handler = new JvsXMLCompletion(cp, ClassLoader.getSystemClassLoader());
>     BufferedInputStream bin = new BufferedInputStream(ClassLoader.getSystemClassLoader().getResourceAsStream(file));
222c207
<       List<Completion> completions = handler.getCompletions();
---
>       List completions = handler.getCompletions();
225,227c210
<       Macros.message(
<         "Erreur lors de la lecture de la librairie de<br/>complétion vérifier si le fichier xml<br/>est correctement écrit.<hr><i>Erreur : "
<         + ex.getMessage() + "</i>", true);
---
>       Macros.message("Erreur lors de la lecture de la librairie de<br/>complétion vérifier si le fichier xml<br/>est correctement écrit.<hr><i>Erreur : " + ex.getMessage() + "</i>", true);

>>> ./src/org/javascool/gui/JVSStartPanel.java

12d11
< 
16a16
> import javax.swing.JLabel;
19,20d18
< import javax.swing.ScrollPaneConstants;
< import javax.swing.SwingConstants;
22,23d19
< 
< import org.javascool.core.Proglet;
27,31c23,25
< /**
<  * Ecran d'accueil de Java's cool Il présente toutes les activités présentes
<  * dans le jar sous la forme d'un panneau d'icones avec le nom des proglets
<  * respectives.
<  *
---
> /** Ecran d'accueil de Java's cool
>  * Il présente toutes les activités présentes dans le jar sous la forme d'un
>  * panneau d'icones avec le nom des proglets respectives.
39,41c33,34
<     if(JVSStartPanel.jvssp == null) {
<       JVSStartPanel.jvssp = new JVSStartPanel(
<         JVSStartPanel.shortcutPanel());
---
>     if(jvssp == null) {
>       jvssp = new JVSStartPanel(JVSStartPanel.shortcutPanel());
43c36
<     return JVSStartPanel.jvssp;
---
>     return jvssp;
46,47c39
<     super(panel, ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED,
<           ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
---
>     super(panel, JScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
51,53c43
<   /**
<    * Dessine le JPanel en listant les proglets
<    *
---
>   /** Dessine le JPanel en listant les proglets
59c49,51
<     int i = ProgletEngine.getInstance().count();
---
>     int i = 0;
>     for(ProgletEngine.Proglet proglet : ProgletEngine.getInstance().getProglets())
>       i++;
61,65c53,54
<     for(Proglet proglet : ProgletEngine.getInstance()
<         .getProglets())
<       shortcuts.add(JVSStartPanel.createShortcut(
<                       Macros.getIcon(proglet.getIcon()), proglet.getName(),
<                       proglet.getTitle(), new ProgletLoader(proglet.getName())));
---
>     for(ProgletEngine.Proglet proglet : ProgletEngine.getInstance().getProglets())
>       shortcuts.add(JVSStartPanel.createShortcut(Macros.getIcon(proglet.getIcon()), proglet.getName(), proglet.getTitle(), new ProgletLoader(proglet.getName())));
69c58,59
<   private static class ProgletLoader implements Runnable {
---
>   private static
>   class ProgletLoader implements Runnable {
82,83c72
<   private static JPanel createShortcut(ImageIcon icon, String name,
<                                        String title, final Runnable start) {
---
>   private static JPanel createShortcut(ImageIcon icon, String name, String title, final Runnable start) {
91,92c80,81
<     label.setVerticalTextPosition(SwingConstants.BOTTOM);
<     label.setHorizontalTextPosition(SwingConstants.CENTER);
---
>     label.setVerticalTextPosition(JLabel.BOTTOM);
>     label.setHorizontalTextPosition(JLabel.CENTER);

>>> ./src/org/javascool/gui/TabPanel.java

6,24c6
< import java.awt.BasicStroke;
< import java.awt.Color;
< import java.awt.Component;
< import java.awt.Dimension;
< import java.awt.FlowLayout;
< import java.awt.Graphics;
< import java.awt.Graphics2D;
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< import java.awt.event.MouseAdapter;
< import java.awt.event.MouseEvent;
< import java.awt.event.MouseListener;
< 
< import javax.swing.AbstractButton;
< import javax.swing.BorderFactory;
< import javax.swing.JButton;
< import javax.swing.JLabel;
< import javax.swing.JPanel;
< import javax.swing.JTabbedPane;
---
> import javax.swing.*;
25a8,9
> import java.awt.*;
> import java.awt.event.*;
28c12,13
<  * Component to be used as tabComponent; Contains a JLabel to show the text and
---
>  * Component to be used as tabComponent;
>  * Contains a JLabel to show the text and
88c73
<       addMouseListener(TabPanel.buttonMouseListener);
---
>       addMouseListener(buttonMouseListener);
133,136c118,119
<       g2.drawLine(delta, delta, getWidth() - delta - 1, getHeight()
<                   - delta - 1);
<       g2.drawLine(getWidth() - delta - 1, delta, delta, getHeight()
<                   - delta - 1);
---
>       g2.drawLine(delta, delta, getWidth() - delta - 1, getHeight() - delta - 1);
>       g2.drawLine(getWidth() - delta - 1, delta, delta, getHeight() - delta - 1);
158d140
< 

>>> ./src/org/javascool/gui/Desktop.java

10d9
< 
12d10
< 
22,23c20
< /**
<  * Définit les functions d'interaction avec l'interface graphique de JavaScool.
---
> /** Définit les functions d'interaction avec l'interface graphique de JavaScool.
31,35c28,29
<   /**
<    * Crée et/ou renvoie l'unique instance du desktop.
<    * <p>
<    * Une application ne peut définir qu'un seul desktop.
<    * </p>
---
>   /** Crée et/ou renvoie l'unique instance du desktop.
>    * <p>Une application ne peut définir qu'un seul desktop.</p>
38,39c32,33
<     if(Desktop.desktop == null) {
<       Desktop.desktop = new Desktop();
---
>     if(desktop == null) {
>       desktop = new Desktop();
41c35
<     return Desktop.desktop;
---
>     return desktop;
50,54d43
<                  /**
<                   *
<                   */
<                  private static final long serialVersionUID = 1727893520791296658L;
< 
68c57
<     return JVSToolBar.getInstance();
---
>     return (ToolBar) JVSToolBar.getInstance();
70,74c59,60
<   /**
<    * Demande la fermeture du desktop à la fin du programme.
<    *
<    * @return La valeur true si le desktop peut être fermé sans dommage pour
<    *         l'utilisateur, sinon la valeur fausse.
---
>   /** Demande la fermeture du desktop à la fin du programme.
>    * @return La valeur true si le desktop peut être fermé sans dommage pour l'utilisateur, sinon la valeur fausse.
83,86c69,70
<   /**
<    * Crée un nouveau fichier.
<    *
<    * @return La valeur true si le fichier est bien créé.
---
>   /** Crée un nouveau fichier.
>    * @return  La valeur true si le fichier est bien créé.
93,94c77
<       System.out.println("Aie impossible de créer un nouveau fichier "
<                          + th);
---
>       System.out.println("Aie impossible de créer un nouveau fichier " + th);
98,110c81,85
<   /**
<    * Ouvre un fichier Demande à l'utilisateur de choisir un fichier et l'ouvre
<    *
<    * @param file
<    *            Le fichier à ouvrir.
<    *            <p>
<    *            -Avec la valeur null une boîte de dialogue le demandera à
<    *            l'utilisateur.
<    *            </p>
<    *            <p>
<    *            - Si le fichier est une URL, une copie locale du fichier (avec
<    *            sauvegarde du fichier existant) est effectuée avant ouverture.
<    *            </p>
---
>   /** Ouvre un fichier
>    * Demande à l'utilisateur de choisir un fichier et l'ouvre
>    * @param file Le fichier à ouvrir.
>    * <p>-Avec la valeur null une boîte de dialogue le demandera à l'utilisateur.</p>
>    * <p>- Si le fichier est une URL, une copie locale du fichier (avec sauvegarde du fichier existant) est effectuée avant ouverture.</p>
132,133c107
<         JVSFileTabs.getInstance().openFile(
<           new JVSFile(FileManager.load(url.toExternalForm())));
---
>         JVSFileTabs.getInstance().openFile(new JVSFile(FileManager.load(url.toExternalForm())));
156,158c130
<   /**
<    * Demande à l'utilisateur de sauvegarder le fichier courant.
<    *
---
>   /** Demande à l'utilisateur de sauvegarder le fichier courant.
176,182c148,150
<   /**
<    * Ouvre une proglet
<    *
<    * @param proglet
<    *            Le nom de code de la Proglet
<    * @return True si tous les fichier ont été sauvegardé et la proglet
<    *         sauvegardé
---
>   /** Ouvre une proglet
>    * @param proglet Le nom de code de la Proglet
>    * @return True si tous les fichier ont été sauvegardé et la proglet sauvegardé
192,200c160,163
<   /**
<    * Ouvre un nouvel onglet de navigation Ouvre un onglet HTML3 dans le
<    * JVSWidgetPanel, cet onglet peut être fermé
<    *
<    * @param url
<    *            L'adresse à ouvrir sous forme de chaîne de caractères ou
<    *            d'URL.
<    * @param name
<    *            Le titre du nouvel onglet
---
>   /** Ouvre un nouvel onglet de navigation
>    * Ouvre un onglet HTML3 dans le JVSWidgetPanel, cet onglet peut être fermé
>    * @param url L'adresse à ouvrir sous forme de chaîne de caractères ou d'URL.
>    * @param name Le titre du nouvel onglet

>>> ./src/org/javascool/gui/JVSFileTabs.java

6d5
< 
12c11
< 
---
> import org.javascool.widgets.Console;
15d13
< import org.javascool.widgets.Console;
17,19c15,16
< /**
<  * The JVSFileTabs A powerful JVSTabs to manage a multi-file editing. It only
<  * support JVSFile.
---
> /** The JVSFileTabs
>  * A powerful JVSTabs to manage a multi-file editing. It only support JVSFile.
40,41c37,38
<     if(JVSFileTabs.desktop == null) {
<       JVSFileTabs.desktop = new JVSFileTabs();
---
>     if(desktop == null) {
>       desktop = new JVSFileTabs();
43c40
<     return JVSFileTabs.desktop;
---
>     return desktop;
49c46
<     return JVSFileTabs.currentCompiledFile;
---
>     return currentCompiledFile;
55,57c52
<   /**
<    * Open a new empty Java's cool file in tmp
<    *
---
>   /** Open a new empty Java's cool file in tmp
63,67c58,59
<   /**
<    * Open a new empty Java's cool file in tmp
<    *
<    * @param url
<    *            The url to the file (used by File())
---
>   /** Open a new empty Java's cool file in tmp
>    * @param url The url to the file (used by File())
73,77c65,67
<   /**
<    * Open a file Open a file from the instance and open its tab
<    *
<    * @param file
<    *            The opened file
---
>   /** Open a file
>    * Open a file from the instance and open its tab
>    * @param file The opened file
83,87c73,74
<       if(JVSFileTabs.files.get(this.getFileId(file.getName())).getFile()
<          .equals(file.getFile()))
<       {
<         this.setSelectedIndex(this.getTabId(this.getFileId(file
<                                                            .getName())));
---
>       if(JVSFileTabs.files.get(this.getFileId(file.getName())).getFile().equals(file.getFile())) {
>         this.setSelectedIndex(this.getTabId(this.getFileId(file.getName())));
99,112c86,98
<     editor.getRTextArea().getDocument()
<     .addDocumentListener(new DocumentListener() {
<                            @Override
<                            public void insertUpdate(DocumentEvent e) {}
< 
<                            @Override
<                            public void removeUpdate(DocumentEvent e) {}
< 
<                            @Override
<                            public void changedUpdate(DocumentEvent e) {
<                              JVSFileTabs.fileUpdateNotification();
<                            }
<                          }
<                          );
---
>     editor.getRTextArea().getDocument().addDocumentListener(new DocumentListener() {
>                                                               @Override
>                                                               public void insertUpdate(DocumentEvent e) {}
> 
>                                                               @Override
>                                                               public void removeUpdate(DocumentEvent e) {}
> 
>                                                               @Override
>                                                               public void changedUpdate(DocumentEvent e) {
>                                                                 fileUpdateNotification();
>                                                               }
>                                                             }
>                                                             );
128c114
<     add(tabTitle, "", JVSFileTabs.editors.get(fileId));
---
>     add(tabTitle, "", editors.get(fileId));
137,138c123
<     this.setTabComponentAt(this.getTabId(fileId),
<                            new TabPanel(this, fileId));
---
>     this.setTabComponentAt(this.getTabId(fileId), new TabPanel(this, fileId));
142,146c127,128
<   /**
<    * Close an opened file
<    *
<    * @param fileId
<    *            The file ID
---
>   /** Close an opened file
>    * @param fileId The file ID
149,150c131,132
<     if(this.getTabId(fileId) != -1) {  // We check if file is opened
<       this.getTitleAt(this.getTabId(fileId));
---
>     if(this.getTabId(fileId) != -1) {                     // We check if file is opened
>       String tab_title = this.getTitleAt(this.getTabId(fileId));                         // Save the tap title (Useful)
157,160c139,142
<         this.removeTabAt(this.getTabId(fileId)); // First remove the tab
<         JVSFileTabs.fileIds.remove(fileName); // Remove id in the index
<         JVSFileTabs.files.remove(fileId); // Remove the file class
<         JVSFileTabs.editors.remove(fileId); // Remove the editor
---
>         this.removeTabAt(this.getTabId(fileId));                                  // First remove the tab
>         JVSFileTabs.fileIds.remove(fileName);                                 // Remove id in the index
>         JVSFileTabs.files.remove(fileId);                                 // Remove the file class
>         JVSFileTabs.editors.remove(fileId);                                 // Remove the editor
166,168c148
<   /**
<    * Get the Current file ID
<    *
---
>   /** Get the Current file ID
172,177c152,153
<     String tab_name = this.getTitleAt(this.getSelectedIndex()); // Get the
<     // tab name
<     // opened to
<     // find the
<     // id
<     String fileId = JVSFileTabs.fileIds.get(tab_name); // We get the id
---
>     String tab_name = this.getTitleAt(this.getSelectedIndex());                 // Get the tab name opened to find the id
>     String fileId = JVSFileTabs.fileIds.get(tab_name);                 // We get the id
182c158
<     return this.saveFile(this.getCurrentFileId()); // We just save the file
---
>     return this.saveFile(this.getCurrentFileId());                 // We just save the file
186,187c162
<     return this.saveAsFile(this.getCurrentFileId()); // We just save the
<     // file
---
>     return this.saveAsFile(this.getCurrentFileId());                 // We just save the file
189,191c164
<   /**
<    * Check if the current file is in tempory memory
<    *
---
>   /** Check if the current file is in tempory memory
195,202c168
<     return JVSFileTabs.files.get(this.getCurrentFileId()).isTmp(); // Check
<     // in
<     // the
<     // JVS
<     // File
<     // object
<     // if is
<     // tempory
---
>     return JVSFileTabs.files.get(this.getCurrentFileId()).isTmp();                 // Check in the JVS File object if is tempory
204,210c170,172
<   /**
<    * Compile a file
<    *
<    * @param fileId
<    *            The id of the file to javaCompile
<    * @return True on success, false in case of error. Can return true if file
<    *         is not openned
---
>   /** Compile a file
>    * @param fileId The id of the file to javaCompile
>    * @return True on success, false in case of error. Can return true if file is not openned
213,215c175
<     if(!JVSFileTabs.fileIds.containsValue(fileId)
<        || JVSFileTabs.files.get(fileId).isTmp())
<     {
---
>     if(!JVSFileTabs.fileIds.containsValue(fileId) || JVSFileTabs.files.get(fileId).isTmp()) {
219,221c179
<     if(ProgletEngine.getInstance().doCompile(
<          JVSFileTabs.editors.get(fileId).getText()))
<     {
---
>     if(ProgletEngine.getInstance().doCompile(JVSFileTabs.editors.get(fileId).getText())) {
229,235c187,189
<   /**
<    * Save a file
<    *
<    * @param fileId
<    *            The id of the file to save
<    * @return True on success, false in case of error. Can return true if file
<    *         is not openned
---
>   /** Save a file
>    * @param fileId The id of the file to save
>    * @return True on success, false in case of error. Can return true if file is not openned
238,239c192,193
<     if(!JVSFileTabs.fileIds.containsValue(fileId)) {
<       return true; // Return true because file is not opened
---
>     if(!JVSFileTabs.fileIds.containsValue(fileId)) {    // Check if id is opened
>       return true;                         // Return true because file is not opened
244,249c198,199
<       JVSFileTabs.files.get(fileId).setCode(
<         JVSFileTabs.editors.get(fileId).getText());   // Set the
<       // editor's text
<       // into the
<       // object
<       JVSFileTabs.files.get(fileId).save(); // Write data in the file
---
>       JVSFileTabs.files.get(fileId).setCode(JVSFileTabs.editors.get(fileId).getText());                         // Set the editor's text into the object
>       JVSFileTabs.files.get(fileId).save();                         // Write data in the file
253,258c203,205
<   /**
<    * Prompt where we can save after prompt it call
<    * JVSFileTabs.saveFile(fileId)
<    *
<    * @param fileId
<    *            The id of the file to save
---
>   /** Prompt where we can save
>    * after prompt it call JVSFileTabs.saveFile(fileId)
>    * @param fileId The id of the file to save
262c209
<     JFileChooser fc = new JFileChooser(); // We create a file chooser
---
>     JFileChooser fc = new JFileChooser();                 // We create a file chooser
264,267c211
<       if(System.getProperty("os.name").toLowerCase().contains("nix")
<          || System.getProperty("os.name").toLowerCase()
<          .contains("nux"))
<       {
---
>       if(System.getProperty("os.name").toLowerCase().contains("nix") || System.getProperty("os.name").toLowerCase().contains("nux")) {
269,271c213,214
<       } else if(UserConfig.getInstance("javascool").getProperty("dir") != null
<                 && !UserConfig.getInstance("javascool").getProperty("dir")
<                 .isEmpty())
---
>       } else if(UserConfig.getInstance("javascool").getProperty("dir") != null&&
>                 !UserConfig.getInstance("javascool").getProperty("dir").isEmpty())
273,274c216
<         fc.setCurrentDirectory(new File(UserConfig.getInstance(
<                                           "javascool").getProperty("dir")));
---
>         fc.setCurrentDirectory(new File(UserConfig.getInstance("javascool").getProperty("dir")));
279,283c221,222
<       // @todo Ici un platrage quand la mise en place du repertoire par
<       // defaut echoue
<       System.err
<       .println("Notice: échec de la mise en place du répertoire par défaut: "
<                + e);
---
>       // @todo Ici un platrage quand la mise en place du repertoire par defaut echoue
>       System.err.println("Notice: échec de la mise en place du répertoire par défaut: " + e);
287,298c226,228
<     int returnVal = fc.showOpenDialog(this.getParent()); // Get the return
<     // value of user
<     // choice
<     if(returnVal == JFileChooser.APPROVE_OPTION) {  // Check if user is ok
<       // to save the file
<       String path = fc.getSelectedFile().getAbsolutePath(); // Get the
<       // path
<       // which has
<       // been
<       // choosed
<       // by the
<       // user
---
>     int returnVal = fc.showOpenDialog(this.getParent());                 // Get the return value of user choice
>     if(returnVal == JFileChooser.APPROVE_OPTION) {                     // Check if user is ok to save the file
>       String path = fc.getSelectedFile().getAbsolutePath();                         // Get the path which has been choosed by the user
300,303c230,232
<       UserConfig.getInstance("javascool").setProperty("dir",
<                                                       fc.getSelectedFile().getParentFile().getAbsolutePath());
<       if(!path.endsWith(".jvs")) { // Test if user writed the extension
<         path = path + ".jvs"; // If not we just add it
---
>       UserConfig.getInstance("javascool").setProperty("dir", fc.getSelectedFile().getParentFile().getAbsolutePath());
>       if(!path.endsWith(".jvs")) {      // Test if user writed the extension
>         path = path + ".jvs";                                 // If not we just add it
305,307c234,236
<       if(!name.endsWith(".jvs")) { // Test if user writed the extension
<         name = name + ".jvs"; // If not we just add it
<       } // JVSFile file = new JVSFile(path, true);
---
>       if(!name.endsWith(".jvs")) {      // Test if user writed the extension
>         name = name + ".jvs";                                 // If not we just add it
>       }            // JVSFile file = new JVSFile(path, true);
310,320c239,244
<         System.out.println(JVSFileTabs.files.get(this.getFileId(name))
<                            .getFile().getName().equals(name));
<         if(JVSFileTabs.files.get(this.getFileId(name)).getFile()
<            .getName().equals(name))
<         {
<           JOptionPane
<           .showMessageDialog(
<             Desktop.getInstance().getFrame(),
<             "Ce fichier est déjà ouvert dans Java's cool, choisisez un nouvelle endroit.",
<             "Erreur d'écriture",
<             JOptionPane.ERROR_MESSAGE);
---
>         System.out.println(JVSFileTabs.files.get(this.getFileId(name)).getFile().getName().equals(name));
>         if(JVSFileTabs.files.get(this.getFileId(name)).getFile().getName().equals(name)) {
>           JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
>                                         "Ce fichier est déjà ouvert dans Java's cool, choisisez un nouvelle endroit.",
>                                         "Erreur d'écriture",
>                                         JOptionPane.ERROR_MESSAGE);
324,333c248,251
<       JVSFileTabs.files.get(fileId).setPath(path); // We set the new path
<       JVSFileTabs.files.get(fileId).setName(
<         fc.getSelectedFile().getName());   // We set the new Name
<       this.editTabName(fileId, name); // Update the TabTitle to the new
<       // name
<       JVSFileTabs.files.get(fileId).setCode(
<         JVSFileTabs.editors.get(fileId).getText());   // Set the
<       // editor's text
<       // into the
<       // object
---
>       JVSFileTabs.files.get(fileId).setPath(path);                         // We set the new path
>       JVSFileTabs.files.get(fileId).setName(fc.getSelectedFile().getName());                         // We set the new Name
>       this.editTabName(fileId, name);                         // Update the TabTitle to the new name
>       JVSFileTabs.files.get(fileId).setCode(JVSFileTabs.editors.get(fileId).getText());                         // Set the editor's text into the object
337,341c255,258
<         JOptionPane
<         .showMessageDialog(
<           Desktop.getInstance().getFrame(),
<           "Le fichier ne peut pas être écrit ici, choisisez un nouvelle endroit.",
<           "Erreur d'écriture", JOptionPane.ERROR_MESSAGE);
---
>         JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
>                                       "Le fichier ne peut pas être écrit ici, choisisez un nouvelle endroit.",
>                                       "Erreur d'écriture",
>                                       JOptionPane.ERROR_MESSAGE);
343c260
<       } // Write data in the file
---
>       }                        // Write data in the file
345c262
<       return false; // If the user is not ok
---
>       return false;                         // If the user is not ok
350,351c267,268
<     if(JVSFileTabs.fileIds.containsValue(fileId)) {
<       return this.indexOfComponent(JVSFileTabs.editors.get(fileId)); // Get
---
>     if(JVSFileTabs.fileIds.containsValue(fileId)) {    // We check if fileId exist
>       return this.indexOfComponent(JVSFileTabs.editors.get(fileId));                         // Get index from the editor
353,357c270
<     // index
<     // from
<     // the
<     // editor
<     return -1; // If file not exist, return -1.
---
>     return -1;                 // If file not exist, return -1.
359,365c272,274
<   /**
<    * Change the tab name
<    *
<    * @param fileId
<    *            The id of the file wich we change the title
<    * @param newTitle
<    *            The new title
---
>   /** Change the tab name
>    * @param fileId The id of the file wich we change the title
>    * @param newTitle The new title
369,371c278,279
<     String tabTitle = newTitle; // create the new title
<     if(this.indexOfTab(newTitle) != -1) {  // Check if tab with its name
<       // exist
---
>     String tabTitle = newTitle;                 // create the new title
>     if(this.indexOfTab(newTitle) != -1) {                     // Check if tab with its name exist
373c281
<       while(this.indexOfTab(newTitle + " " + i) != -1) { // Generate it
---
>       while(this.indexOfTab(newTitle + " " + i) != -1) {      // Generate it
378,385c286,290
<     String oldTabTitle = this.getTitleAt(this.getTabId(fileId)); // Get the
<     // old
<     // tab
<     // title
<     this.setTitleAt(this.getTabId(fileId), tabTitle); // Update the title
<     JVSFileTabs.fileIds.remove(oldTabTitle); // remove old index
<     JVSFileTabs.fileIds.put(tabTitle, fileId); // set the new fil
<     return true; // return true all time
---
>     String oldTabTitle = this.getTitleAt(this.getTabId(fileId));                 // Get the old tab title
>     this.setTitleAt(this.getTabId(fileId), tabTitle);                 // Update the title
>     JVSFileTabs.fileIds.remove(oldTabTitle);                 // remove old index
>     JVSFileTabs.fileIds.put(tabTitle, fileId);                 // set the new fil
>     return true;                 // return true all time
387,391c292,293
<   /**
<    * Get the fileId from a TabName
<    *
<    * @param tabName
<    *            The tab Name
---
>   /** Get the fileId from a TabName
>    * @param tabName The tab Name
395,396c297,298
<     if(JVSFileTabs.fileIds.containsKey(tabName)) {
<       return JVSFileTabs.fileIds.get(tabName); // Return the id
---
>     if(JVSFileTabs.fileIds.containsKey(tabName)) {    // Check if tabName exist
>       return JVSFileTabs.fileIds.get(tabName);                         // Return the id
398c300
<       return ""; // Return empty string if tabName not exist
---
>       return "";                         // Return empty string if tabName not exist
403,404c305,306
<     if(JVSFileTabs.files.containsKey(id)) {
<       return JVSFileTabs.files.get(id); // Return the JVSFile
---
>     if(JVSFileTabs.files.containsKey(id)) {    // Check if id exist
>       return JVSFileTabs.files.get(id);                         // Return the JVSFile
406c308
<       return new JVSFile(); // Return new empty JVSFile if id not exists
---
>       return new JVSFile();                         // Return new empty JVSFile if id not exists
411,412c313,314
<     if(JVSFileTabs.editors.containsKey(fileId)) {
<       return JVSFileTabs.editors.get(fileId); // Return the editor
---
>     if(JVSFileTabs.editors.containsKey(fileId)) {    // Check if fileId exist
>       return JVSFileTabs.editors.get(fileId);                         // Return the editor
414c316
<       return new JVSEditor(); // Return new empty JVSEditor if fileId not
---
>       return new JVSEditor();                         // Return new empty JVSEditor if fileId not exists
416d317
<     // exists
418,421c319,320
<   /**
<    * File update is call when a file is edited Call
<    * JVSPanel.mustSave(this.getCurrentFileId()) to check if file has to be
<    * save
---
>   /** File update is call when a file is edited
>    * Call JVSPanel.mustSave(this.getCurrentFileId()) to check if file has to be save
424,425c323
<     JVSPanel.getInstance().mustSave(
<       JVSFileTabs.getInstance().getCurrentFileId());
---
>     JVSPanel.getInstance().mustSave(JVSFileTabs.getInstance().getCurrentFileId());

>>> ./src/org/javascool/gui/JVSEditor.java

16c16,17
< 
---
> import java.util.logging.Level;
> import java.util.logging.Logger;
22d22
< import javax.swing.JPopupMenu;
26d25
< 
38,40c37,40
< /**
<  * Define a JVSEditor Use JVSEditor to edit jvs files, it can be used as a panel
<  *
---
> import javax.swing.JPopupMenu;
> 
> /** Define a JVSEditor
>  * Use JVSEditor to edit jvs files, it can be used as a panel
53,54c53,54
<   /**
<    * Create a new JVSEditor Common setup
---
>   /** Create a new JVSEditor
>    * Common setup
61c61
<     new JVSAutoCompletionProvider(TextPane);
---
>     JVSAutoCompletionProvider jacp = new JVSAutoCompletionProvider(TextPane);
93,95c93,94
<   /**
<    * TextArea initialization Creates the text area for this application.
<    *
---
>   /** TextArea initialization
>    * Creates the text area for this application.
116c115
<     if(JVSEditor.isMac()) {
---
>     if(isMac()) {
119,124c118,125
<     KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.CTRL_MASK);
<     if(JVSEditor.isMac()) {
<       KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.META_MASK);
<     }
<     textArea.getInputMap().put(key, "save");
<     textArea.getActionMap().put("save", new AbstractAction() {
---
>     KeyStroke copy_key = KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.CTRL_MASK);
>     if(isMac()) {
>       copy_key = KeyStroke.getKeyStroke(KeyEvent.VK_C, Event.META_MASK);
>     }
>     textArea.getInputMap().put(key,
>                                "save");
>     textArea.getActionMap().put("save",
>                                 new AbstractAction() {
140,142c141
<   /**
<    * Get text into the TextArea
<    *
---
>   /** Get text into the TextArea
148,152c147,148
<   /**
<    * Set the text
<    *
<    * @param text
<    *            The text to write on screen
---
>   /** Set the text
>    * @param text The text to write on screen
174,176c170
<       img = ImageIO
<             .read(ClassLoader
<                   .getSystemResourceAsStream("org/javascool/widgets/icons/error.png"));
---
>       img = ImageIO.read(ClassLoader.getSystemResourceAsStream("org/javascool/widgets/icons/error.png"));
183,184c177
<       getRTextArea().setCaretPosition(
<         getRTextArea().getLineStartOffset(line - 1));
---
>       getRTextArea().setCaretPosition(getRTextArea().getLineStartOffset(line - 1));
189,190c182
<       // Logger.getLogger(JVSEditor.class.getName()).log(Level.SEVERE,
<       // null, ex);
---
>       // Logger.getLogger(JVSEditor.class.getName()).log(Level.SEVERE, null, ex);
195c187
<       super(JVSEditor.createCodeCompletionProvider());
---
>       super(createCodeCompletionProvider());
199,200c191
<       TextPane.setToolTipSupplier((ToolTipSupplier) this
<                                   .getCompletionProvider());
---
>       TextPane.setToolTipSupplier((ToolTipSupplier) this.getCompletionProvider());
206,209c197
<                                   if((ch > 33) && (ch != 127) && (ch != 129) && (ch != 141)
<                                      && (ch != 143) && (ch != 144) && (ch != 157) && (ch != 160)
<                                      && JVSEditor.this.completion)
<                                   {
---
>                                   if((ch > 33) && (ch != 127) && (ch != 129) && (ch != 141) && (ch != 143) && (ch != 144) && (ch != 157) && (ch != 160) && JVSEditor.this.completion) {
236,245c224,228
<     if(!ProgletEngine.getInstance().getProglet().getCompletion()
<        .equals(""))
<     {
<       JvsXMLCompletion.readCompletionToProvider(ProgletEngine
<                                                 .getInstance().getProglet().getCompletion(), cp);
<     }
<     JvsXMLCompletion.readCompletionToProvider(
<       "org/javascool/gui/completion-macros.xml", cp);
<     LanguageAwareCompletionProvider lacp = new LanguageAwareCompletionProvider(
<       cp);
---
>     if(!ProgletEngine.getInstance().getProglet().getCompletion().equals("")) {
>       JvsXMLCompletion.readCompletionToProvider(ProgletEngine.getInstance().getProglet().getCompletion(), cp);
>     }
>     JvsXMLCompletion.readCompletionToProvider("org/javascool/gui/completion-macros.xml", cp);
>     LanguageAwareCompletionProvider lacp = new LanguageAwareCompletionProvider(cp);

>>> ./src/org/javascool/gui/JVSFile.java

11d10
< 
15c14,16
<   public static String defaultCode = "void main(){\n" + "\t\n" + "}";
---
>   public static String defaultCode = "void main(){\n"
>                                      + "\t\n"
>                                      + "}";
32,36c33,34
<   /**
<    * Open a new file from a text
<    *
<    * @param text
<    *            The text of new file
---
>   /** Open a new file from a text
>    * @param text The text of new file
41,47c39,42
<   /**
<    * Open a file from an url Don't forget to put fromurl to true
<    *
<    * @param url
<    *            The url of file
<    * @param fromurl
<    *            True for open from an url
---
>   /** Open a file from an url
>    * Don't forget to put fromurl to true
>    * @param url The url of file
>    * @param fromurl  True for open from an url
66,70c61,62
<       if(fileContent
<          .matches("^[ \\t\\n\\r]*@proglet:[A-Za-z]*[\\n\\r]*"))
<       {
<         this.proglet = fileContent.replaceAll(
<           "^[ \\t\\n\\r]*@proglet:([A-Za-z]*)[\\n\\r]*.*", "$1");
---
>       if(fileContent.matches("^[ \\t\\n\\r]*@proglet:[A-Za-z]*[\\n\\r]*")) {
>         this.proglet = fileContent.replaceAll("^[ \\t\\n\\r]*@proglet:([A-Za-z]*)[\\n\\r]*.*", "$1");
91,93c83
<   /**
<    * Get the file name
<    *
---
>   /** Get the file name
99,103c89,90
<   /**
<    * Set the file name
<    *
<    * @param name
<    *            the name to set
---
>   /** Set the file name
>    * @param name the name to set
108,110c95
<   /**
<    * Get the path to file
<    *
---
>   /** Get the path to file
116,121c101,103
<   /**
<    * Set a new path for the file Use save() to write the file into the new
<    * path
<    *
<    * @param path
<    *            the path to set
---
>   /** Set a new path for the file
>    * Use save() to write the file into the new path
>    * @param path the path to set
127,129c109
<   /**
<    * Get the file Instance in memory
<    *
---
>   /** Get the file Instance in memory
145,146c125
<    * @param proglet
<    *            the proglet to set
---
>    * @param proglet the proglet to set
152,154c131
<   /**
<    * Get the code in the file
<    *
---
>   /** Get the code in the file
160,165c137,139
<   /**
<    * Set the code !! WARNING !! It no write the text to the file, it just save
<    * it into the object use save() insted.
<    *
<    * @param code
<    *            the text to set
---
>   /** Set the code
>    * !! WARNING !! It no write the text to the file, it just save it into the object use save() insted.
>    * @param code the text to set
178,179c152
<   public static String readFileAsString(String filePath)
<   throws java.io.IOException {
---
>   public static String readFileAsString(String filePath) throws java.io.IOException {
181,182c154
<     BufferedInputStream f = new BufferedInputStream(new FileInputStream(
<                                                       filePath));
---
>     BufferedInputStream f = new BufferedInputStream(new FileInputStream(filePath));

>>> ./src/org/javascool/gui/JVSTabs.java

5d4
< 
9d7
< 
12,15c10,11
< /**
<  * Create a tab structure Java's cool Tab Structure is used to make easy
<  * JTabbedPane
<  *
---
> /** Create a tab structure
>  * Java's cool Tab Structure is used to make easy JTabbedPane
24,32c20,23
<   /**
<    * Add a tab with a JPanel
<    *
<    * @param name
<    *            The tab name
<    * @param icon
<    *            The link to the icon, can be an empty String
<    * @param panel
<    *            The JPanel to show into the tab
---
>   /** Add a tab with a JPanel
>    * @param name The tab name
>    * @param icon The link to the icon, can be an empty String
>    * @param panel The JPanel to show into the tab
38,46c29,32
<   /**
<    * Add a tab with an Applet
<    *
<    * @param name
<    *            The tab name
<    * @param icon
<    *            The link to the icon, can be an empty String
<    * @param panel
<    *            The Applet to show into the tab
---
>   /** Add a tab with an Applet
>    * @param name The tab name
>    * @param icon The link to the icon, can be an empty String
>    * @param panel The Applet to show into the tab
60,70c46,50
<   /**
<    * Add a tab with a JPanel
<    *
<    * @param name
<    *            The tab name
<    * @param icon
<    *            The link to the icon, can be an empty String
<    * @param panel
<    *            The JPanel to show into the tab
<    * @param tooltip
<    *            An tooltip for the tab
---
>   /** Add a tab with a JPanel
>    * @param name The tab name
>    * @param icon The link to the icon, can be an empty String
>    * @param panel The JPanel to show into the tab
>    * @param tooltip An tooltip for the tab
84,88c64,65
<   /**
<    * Get a JPanel
<    *
<    * @param name
<    *            The id of JPanel
---
>   /** Get a JPanel
>    * @param name The id of JPanel
94,98c71,72
<   /**
<    * Delete a tab
<    *
<    * @param name
<    *            The tab id
---
>   /** Delete a tab
>    * @param name The tab id
104,108c78,79
<   /**
<    * Switch to a tab
<    *
<    * @param name
<    *            The id of the tab
---
>   /** Switch to a tab
>    * @param name The id of the tab

>>> ./src/org/javascool/gui/JVSCenterPanel.java

5,8c5,7
< /**
<  * Le double pannau central de Java's cool Le JVSCenterPanel est utilisé pour
<  * plaçer correctemment le JVSWidgetPanel à droite et le JVSFileTabs à gauche
<  *
---
> /** Le double pannau central de Java's cool
>  * Le JVSCenterPanel est utilisé pour plaçer correctemment le JVSWidgetPanel à
>  * droite et le JVSFileTabs à gauche
19,20c18,19
<     if(JVSCenterPanel.jvssplitpane == null) {
<       JVSCenterPanel.jvssplitpane = new JVSCenterPanel();
---
>     if(jvssplitpane == null) {
>       jvssplitpane = new JVSCenterPanel();
22c21
<     return JVSCenterPanel.jvssplitpane;
---
>     return jvssplitpane;

>>> ./src/org/javascool/gui/JVSPanel.java

7d6
< 
12d10
< 
16,20c14,16
< /**
<  * The main panel for Java's cool This class wich is very static contain all
<  * that we need to run Java's cool like save and open file command. This class
<  * can only be called by JVSPanel on instance otherwise it can throw very big
<  * errors
---
> /** The main panel for Java's cool
>  * This class wich is very static contain all that we need to run Java's cool like save and open file command.
>  * This class can only be called by JVSPanel on instance otherwise it can throw very big errors
37,38c33,34
<     if(JVSPanel.desktop == null) {
<       JVSPanel.desktop = new JVSPanel();
---
>     if(desktop == null) {
>       desktop = new JVSPanel();
40c36
<     return JVSPanel.desktop;
---
>     return desktop;
66,68c62
<   /**
<    * Open a new file in the editor
<    *
---
>   /** Open a new file in the editor
75,77c69
<   /**
<    * Compile file in the editor
<    *
---
>   /** Compile file in the editor
81,83c73
<     JVSFileTabs.getInstance()
<     .getEditor(JVSFileTabs.getCurrentCompiledFile())
<     .removeLineSignals();
---
>     JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()).removeLineSignals();
86,88c76
<       if(JVSFileTabs.getInstance().compileFile(
<            JVSFileTabs.getInstance().getCurrentFileId()))
<       {
---
>       if(JVSFileTabs.getInstance().compileFile(JVSFileTabs.getInstance().getCurrentFileId())) {
95,97c83,84
<   /**
<    * Open a file Start a file chooser and open selected file
<    *
---
>   /** Open a file
>    * Start a file chooser and open selected file
104,108c91,92
<       fc.setCurrentDirectory(new File(UserConfig.getInstance("javascool")
<                                       .getProperty("dir")));
<     } else if(System.getProperty("os.name").toLowerCase().contains("nix")
<               || System.getProperty("os.name").toLowerCase().contains("nux"))
<     {
---
>       fc.setCurrentDirectory(new File(UserConfig.getInstance("javascool").getProperty("dir")));
>     } else if(System.getProperty("os.name").toLowerCase().contains("nix") || System.getProperty("os.name").toLowerCase().contains("nux")) {
120,121c104
<       UserConfig.getInstance("javascool").setProperty("dir",
<                                                       fc.getSelectedFile().getParentFile().getAbsolutePath());
---
>       UserConfig.getInstance("javascool").setProperty("dir", fc.getSelectedFile().getParentFile().getAbsolutePath());
129,131c112
<   /**
<    * Save the current file
<    *
---
>   /** Save the current file
142,144c123
<   /**
<    * Save the current file
<    *
---
>   /** Save the current file
155,157c134
<   /**
<    * Close the current file
<    *
---
>   /** Close the current file
162,166c139,140
<       if(saveFileIdBeforeClose(JVSFileTabs.getInstance()
<                                .getCurrentFileId()) == 1)
<       {
<         JVSFileTabs.getInstance().closeFile(
<           JVSFileTabs.getInstance().getCurrentFileId());
---
>       if(saveFileIdBeforeClose(JVSFileTabs.getInstance().getCurrentFileId()) == 1) {
>         JVSFileTabs.getInstance().closeFile(JVSFileTabs.getInstance().getCurrentFileId());
169,170c143
<       JVSFileTabs.getInstance().closeFile(
<         JVSFileTabs.getInstance().getCurrentFileId());
---
>       JVSFileTabs.getInstance().closeFile(JVSFileTabs.getInstance().getCurrentFileId());
176,180c149,151
<   /**
<    * Update haveToSave for a file Set it to true
<    *
<    * @param fileId
<    *            The file id
---
>   /** Update haveToSave for a file
>    * Set it to true
>    * @param fileId The file id
186,190c157,159
<   /**
<    * Update haveToSave for a file Set it to true
<    *
<    * @param fileId
<    *            The file id
---
>   /** Update haveToSave for a file
>    * Set it to true
>    * @param fileId The file id
198,205c167,170
<   /**
<    * Show a compile error for an human Open a dialog with compile error
<    * explains and hightlight the error line
<    *
<    * @param line
<    *            The line error
<    * @param explication
<    *            Human explain for that error
---
>   /** Show a compile error for an human
>    * Open a dialog with compile error explains and hightlight the error line
>    * @param line The line error
>    * @param explication Human explain for that error
211,216c176,177
<     if(JVSFileTabs.getInstance().getEditor(
<          JVSFileTabs.getCurrentCompiledFile()) != null)
<     {
<       JVSFileTabs.getInstance()
<       .getEditor(JVSFileTabs.getCurrentCompiledFile())
<       .signalLine(line);
---
>     if(JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()) != null) {
>       JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()).signalLine(line);
219,224c180,182
<   /**
<    * Handle the close application task Check if all files are saved and if the
<    * user want to close the application
<    *
<    * @return True mean that app can be close and false that app can NOT be
<    *         closed
---
>   /** Handle the close application task
>    * Check if all files are saved and if the user want to close the application
>    * @return True mean that app can be close and false that app can NOT be closed
232c190
<       if(haveToSave.get(fileId)) {
---
>       if(haveToSave.get((String) fileId)) {
235c193
<      // If user no have dialog to stop close, we create one
---
>     // If user no have dialog to stop close, we create one
237,239c195,199
<       final int n = JOptionPane.showConfirmDialog(Desktop.getInstance()
<                                                   .getFrame(), "Voulez vous vraiment quitter Java's cool ?",
<                                                   "Confirmation", JOptionPane.YES_NO_OPTION);
---
>       final int n = JOptionPane.showConfirmDialog(
>         Desktop.getInstance().getFrame(),
>         "Voulez vous vraiment quitter Java's cool ?",
>         "Confirmation",
>         JOptionPane.YES_NO_OPTION);
252,253c212
<         // For number see saveFileIdBeforeClose() documentation about
<         // return
---
>         // For number see saveFileIdBeforeClose() documentation about return
265c224
<       } else { // If file has not to be saved it's good
---
>       } else {     // If file has not to be saved it's good
268c227
<       if(can_close[i]) { // If we can close this file, we close the tab
---
>       if(can_close[i]) {      // If we can close this file, we close the tab
283,288c242,244
<   /**
<    * Handle the close file task Check if all files are saved and if the user
<    * want to continue
<    *
<    * @return True meen that app can be close and false that app can NOT be
<    *         closed
---
>   /** Handle the close file task
>    * Check if all files are saved and if the user want to continue
>    * @return True meen that app can be close and false that app can NOT be closed
296c252
<       if(haveToSave.get(fileId)) {
---
>       if(haveToSave.get((String) fileId)) {
304,306c260,264
<       final int n = JOptionPane.showConfirmDialog(Desktop.getInstance()
<                                                   .getFrame(), "Voulez vous vraiment continuer ?",
<                                                   "Confirmation", JOptionPane.YES_NO_OPTION);
---
>       final int n = JOptionPane.showConfirmDialog(
>         Desktop.getInstance().getFrame(),
>         "Voulez vous vraiment continuer ?",
>         "Confirmation",
>         JOptionPane.YES_NO_OPTION);
319,320c277
<         // For number see saveFileIdBeforeClose() documentation about
<         // return
---
>         // For number see saveFileIdBeforeClose() documentation about return
332c289
<       } else { // If file has not to be saved it's good
---
>       } else {     // If file has not to be saved it's good
335c292
<       if(can_close[i]) { // If we can close this file, we close the tab
---
>       if(can_close[i]) {      // If we can close this file, we close the tab
350,357c307,309
<   /**
<    * Ask to user to save a file before it close
<    *
<    * @param fileId
<    *            The file id
<    * @return 1 meen that file is saved or that user not want to save the file.
<    *         0 meen that there was an error during the save of file. -1 meen
<    *         that user want to stop all that happend (Cancel option).
---
>   /** Ask to user to save a file before it close
>    * @param fileId The file id
>    * @return 1 meen that file is saved or that user not want to save the file. 0 meen that there was an error during the save of file. -1 meen that user want to stop all that happend (Cancel option).
361,363c313,315
<     int result = JOptionPane.showConfirmDialog(Desktop.getInstance()
<                                                .getFrame(), "Voulez vous enregistrer " + file.getName()
<                                                + " avant de continuer ?");
---
>     int result = JOptionPane.showConfirmDialog(
>       Desktop.getInstance().getFrame(),
>       "Voulez vous enregistrer " + file.getName() + " avant de continuer ?");
378,382c330,331
<   /**
<    * Charge une nouvelle proglet dans l'interface utilisateur.
<    *
<    * @param name
<    *            Le nom de code de la proglet (ex:abcdAlgos)
---
>   /** Charge une nouvelle proglet dans l'interface utilisateur.
>    * @param name Le nom de code de la proglet (ex:abcdAlgos)
414,419c363,364
<     if(JVSFileTabs.getInstance().getEditor(
<          JVSFileTabs.getCurrentCompiledFile()) != null)
<     {
<       JVSFileTabs.getInstance()
<       .getEditor(JVSFileTabs.getCurrentCompiledFile())
<       .signalLine(line);
---
>     if(JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()) != null) {
>       JVSFileTabs.getInstance().getEditor(JVSFileTabs.getCurrentCompiledFile()).signalLine(line);
430,431c375
<       JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
<                                     message, title, JOptionPane.INFORMATION_MESSAGE);
---
>       JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(), message, title, JOptionPane.INFORMATION_MESSAGE);
435,436c379
<       JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(),
<                                     message, title, JOptionPane.ERROR_MESSAGE);
---
>       JOptionPane.showMessageDialog(Desktop.getInstance().getFrame(), message, title, JOptionPane.ERROR_MESSAGE);

>>> ./src/org/javascool/core/Java2Jar.java

8d7
< 
13,15c12
< /**
<  * Définit le mécanisme de compilation en ligne d'un code Java et de création du
<  * Jar obtenu.
---
> /** Définit le mécanisme de compilation en ligne d'un code Java et de création du Jar obtenu.
23,43c20,28
<   /**
<    * Compile dans le système de fichier local, un code source Java.
<    * <p>
<    * Les fichiers <tt>.class</tt> sont générés dans sur place.
<    * </p>
<    * <p>
<    * Les erreurs de compilation sont affichées dans la console.
<    * </p>
<    *
<    * @param jarFile
<    *            La jarre de stockage du résultat.
<    * @param mainClass
<    *            Le nom de la classe qui contient le main.
<    * @param javaFile
<    *            Le nom du fichier à compiler. Un tableau de noms de fichiers
<    *            peut être donné.
<    * @param allErrors
<    *            Renvoie toutes les erreur si true, sinon uniquement la
<    *            première erreur (par défaut).
<    * @return La valeur true en cas de succès, false si il y a des erreurs de
<    *         compilation.
---
> 
>   /** Compile dans le système de fichier local, un code source Java.
>    * <p>Les fichiers <tt>.class</tt> sont générés dans sur place.</p>
>    * <p>Les erreurs de compilation sont affichées dans la console.</p>
>    * @param jarFile La jarre de stockage du résultat.
>    * @param mainClass Le nom de la classe qui contient le main.
>    * @param javaFile Le nom du fichier à compiler. Un tableau de noms de fichiers peut être donné.
>    * @param allErrors Renvoie toutes les erreur si true, sinon uniquement la première erreur (par défaut).
>    * @return La valeur true en cas de succès, false si il y a des erreurs de compilation.
45,47c30
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite lors de la
<    *             compilation.
---
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la compilation.
49,50c32
<   public static boolean compile(String jarFile, String mainClass,
<                                 String javaFile, boolean allErrors) {
---
>   public static boolean compile(String jarFile, String mainClass, String javaFile, boolean allErrors) {
52c34
<     return Java2Jar.compile(jarFile, mainClass, javaFiles, allErrors);
---
>     return compile(jarFile, mainClass, javaFiles, allErrors);
57,59c39,40
<   public static boolean compile(String jarFile, String mainClass,
<                                 String javaFile) {
<     return Java2Jar.compile(jarFile, mainClass, javaFile, false);
---
>   public static boolean compile(String jarFile, String mainClass, String javaFile) {
>     return compile(jarFile, mainClass, javaFile, false);
64,66c45,46
<   public static boolean compile(String jarFile, String mainClass,
<                                 String javaFiles[]) {
<     return Java2Jar.compile(jarFile, mainClass, javaFiles, false);
---
>   public static boolean compile(String jarFile, String mainClass, String javaFiles[]) {
>     return compile(jarFile, mainClass, javaFiles, false);
71,72c51
<   public static boolean compile(String jarFile, String mainClass,
<                                 String javaFiles[], boolean allErrors) {
---
>   public static boolean compile(String jarFile, String mainClass, String javaFiles[], boolean allErrors) {
77,78c56
<       JarManager.jarExtract(Core.javascoolJar(), buildDir,
<                             "org/javascool");
---
>       JarManager.jarExtract(Core.javascoolJar(), buildDir, "org/javascool");
88,91c66,68
<       new Pml()
<       .set("Main-Class", mainClass)
<       .set("Implementation-URL",
<            "http://javascool.gforge.inria.fr").save(mfFile);
---
>       Pml manifest = new Pml().set("Main-Class", mainClass).
>                      set("Implementation-URL", "http://javascool.gforge.inria.fr").
>                      save(mfFile);
95,96c72
<     } catch(IOException e) { throw new RuntimeException(
<                                      "Erreur d'entrées-sorties à la compilation : " + e);
---
>     } catch(IOException e) { throw new RuntimeException("Erreur d'entrées-sorties à la compilation : " + e);
99,103c75,76
<   /**
<    * Lanceur de la conversion Jvs en Java.
<    *
<    * @param usage
<    *            <tt>java org.javascool.core.Java2Jar main-file [input-file(s) ..] [output-file]</tt>
---
>   /** Lanceur de la conversion Jvs en Java.
>    * @param usage <tt>java org.javascool.core.Java2Jar main-file [input-file(s) ..] [output-file]</tt>
110,111c83
<       Java2Jar.compile(usage[usage.length - 1], new File(usage[0])
<                        .getName().replaceAll("\\.java$", ""), javaFiles, true);
---
>       compile(usage[usage.length - 1], new File(usage[0]).getName().replaceAll("\\.java$", ""), javaFiles, true);
114a87
> 

>>> ./src/org/javascool/core/Translator.java

3,8c3,4
< /**
<  * Définit une traduction d'un code Jvs en code Java standard.
<  * <p>
<  * Cette classe permet de définir des variantes de langage pour une proglet
<  * donnée.
<  * </p>
---
> /** Définit une traduction d'un code Jvs en code Java standard.
>  * <p>Cette classe permet de définir des variantes de langage pour une proglet donnée.</p>
14,28c10,13
<   /**
<    * Renvoie les déclarations d'import spécifiques à cette proglet.
<    * <p>
<    * Ce sont les déclarations d'import spécifiques dont l'utilisateur a besoin
<    * pour que son code Jvs puisse se compiler.
<    * </p>
<    * <p>
<    * - Par exemple:
<    * <tt>"import javax.swing.JPanel;import static org.javascool.proglets.maProglet.*;"</tt>
<    * </p>
<    * <p>
<    * Note: tous les imports liés aux fonctions de la proglet à l'usage des
<    * macros de JavaScool etc.. sont automatiquement prises en charge.
<    * </p>
<    *
---
>   /** Renvoie les déclarations d'import spécifiques à cette proglet.
>    * <p>Ce sont les déclarations d'import spécifiques dont l'utilisateur a besoin pour que son code Jvs puisse se compiler.</p>
>    * <p>- Par exemple: <tt>"import javax.swing.JPanel;import static org.javascool.proglets.maProglet.*;"</tt></p>
>    * <p>Note: tous les imports liés aux fonctions de la proglet à l'usage des macros de JavaScool etc.. sont automatiquement prises en charge.</p>
34,55c19,24
<   /**
<    * Transforme globalement le code pour passer des constructions spécifiques
<    * à Jvs à du java standard.
<    * <p>
<    * Ce sont souvent des expression régulières appliquées à la chaîne, tout
<    * est ici de la responsabilité du concepteur de la proglet.
<    * </p>
<    * <p>
<    * Note: toutes les traductions standard du passage de Jvs à Java sont
<    * automatiquement prises en charges.
<    * </p>
<    * <p>
<    * Les portions de code de la forme <tt>/*<i>code-jvs</i> @&lt;nojavac*</tt>
<    * <tt>/<i>code-java-derive</ii>/*@nojavac>*</tt><tt>/</tt> issus de
<    * pseudo-code retraduit en Java par la méthode translate sont traités pour
<    * que seul le <i>code-jvs</i> soit affiché en cas d'erreur de syntaxe.
<    * </p>
<    *
<    * @param code
<    *            Le code Jvs en entrée.
<    * @return Le code transformé en Java pour ce qui est spécifique de cette
<    *         proglet (par défaut la chaîne en entrée).</p>
---
>   /** Transforme globalement le code pour passer des constructions spécifiques à Jvs à du java standard.
>    * <p>Ce sont souvent des expression régulières appliquées à la chaîne, tout est ici de la responsabilité du concepteur de la proglet.</p>
>    * <p>Note: toutes les traductions standard du passage de Jvs à Java sont automatiquement prises en charges.</p>
>    * <p>Les portions de code de la forme <tt>/*<i>code-jvs</i> @&lt;nojavac*</tt><tt>/<i>code-java-derive</ii>/*@nojavac>*</tt><tt>/</tt> issus de pseudo-code retraduit en Java par la méthode translate sont traités pour que seul le <i>code-jvs</i> soit affiché en cas d'erreur de syntaxe.</p>
>    * @param code Le code Jvs en entrée.
>    * @return Le code transformé en Java pour ce qui est spécifique de cette proglet (par défaut la chaîne en entrée).</p>
64,102c33,47
<   /**
<    * Détermine les bornes d'un parenthésage. - Exemples de construction:
<    * <p>
<    * <tt>scanConstruct(string, offset, "(", ")", null, true, true)</tt> cerne
<    * un parenthésage dans un code.
<    * </p>
<    * <p>
<    * <tt>scanConstruct(string, offset, "'", "'", "\'", false, false)</tt>
<    * cerne une chaîne entre quotes ' '.
<    * </p>
<    *
<    * @param string
<    *            Le contenu du texte à analyser.
<    * @param offset
<    *            L'index de départ dans le texte à analyser.
<    * @param start
<    *            Le symbole de parenthèse ouvrante, ou null si non défini.
<    * @param stop
<    *            Le symbole de parenthèse fermante.
<    * @param escape
<    *            Le symbole d'échappement de la parenthèse fermante, ou null si
<    *            non défini.
<    * @param recurse
<    *            Effectue une recherche qui tient compte de parenthèses
<    *            emboitées, si égal à true.
<    * @param code
<    *            Passe par dessus les commentaires de programme
<    *            <tt>/* . . *</tt><tt>/</tt> ou <tt>// . . /n</tt> et les
<    *            chaînes de caractères <tt>" . . "</tt>, si égal à true.
<    * @return Renvoie int[2], l'index du premier caratère et un plus l'index du
<    *         dernier caractères du parenthésage,
<    *         <p>
<    *         tel que <tt>string.substring(index[0], index[1])</tt> corresponde
<    *         à la chaîne identifiée, sinon
<    *         </p>
<    *         <p>
<    *         la valeur <tt>{-1, offset}</tt> si le parenthésage n'est pas
<    *         trouvé.
<    *         </p>
---
>   /** Détermine les bornes d'un parenthésage.
>    * - Exemples de construction:
>    * <p><tt>scanConstruct(string, offset, "(", ")", null, true, true)</tt> cerne un parenthésage dans un code.</p>
>    * <p><tt>scanConstruct(string, offset, "'", "'", "\'", false, false)</tt> cerne une chaîne entre quotes ' '.</p>
>    *
>    * @param string Le contenu du texte à analyser.
>    * @param offset L'index de départ dans le texte à analyser.
>    * @param start Le symbole de parenthèse ouvrante, ou null si non défini.
>    * @param stop Le symbole de parenthèse fermante.
>    * @param escape Le symbole d'échappement de la parenthèse fermante, ou null si non défini.
>    * @param recurse Effectue une recherche qui tient compte de parenthèses emboitées, si égal à true.
>    * @param code Passe par dessus les commentaires de programme <tt>/* . . *</tt><tt>/</tt> ou <tt>// . . /n</tt> et les chaînes de caractères <tt>" . . "</tt>, si égal à true.
>    * @return Renvoie int[2], l'index du premier caratère et un plus l'index du dernier caractères du parenthésage,
>    * <p>tel que <tt>string.substring(index[0], index[1])</tt> corresponde à la chaîne identifiée, sinon</p>
>    * <p>la valeur <tt>{-1, offset}</tt> si le parenthésage n'est pas trouvé.</p>
108,109c53
<   public static int[] scanConstruct(String string, int offset, String start,
<                                     String stop, String escape, boolean recurse, boolean code) {
---
>   public static int[] scanConstruct(String string, int offset, String start, String stop, String escape, boolean recurse, boolean code) {
112,116c56,57
<       index[0] = code ? Translator.scanComments(string, offset, false)
<                  : Translator.scanSpaces(string, offset);
<       if(!((index[0] < string.length()) && ((start == null) || string
<                                             .startsWith(start, index[0]))))
<       {
---
>       index[0] = code ? scanComments(string, offset, false) : scanSpaces(string, offset);
>       if(!((index[0] < string.length()) && ((start == null) || string.startsWith(start, index[0])))) {
119,124c60,61
<       for(index[1] = index[0] + (start == null ? 0 : start.length()); index[1] < string
<           .length() && !string.startsWith(stop, index[1]);)
<       {
<         if((escape != null&& escape.length() > 0)
<            && string.startsWith(escape, index[1]))
<         {
---
>       for(index[1] = index[0] + (start == null ? 0 : start.length()); index[1] < string.length() && !string.startsWith(stop, index[1]);) {
>         if((escape != null&& escape.length() > 0) && string.startsWith(escape, index[1])) {
126,130c63,64
<         } else if(recurse && (start != null&& index[1] > index[0])
<                   && string.startsWith(start, index[1]))
<         {
<           int next[] = Translator.scanConstruct(string, index[1],
<                                                 start, stop, escape, recurse, code);
---
>         } else if(recurse && (start != null&& index[1] > index[0]) && string.startsWith(start, index[1])) {
>           int next[] = scanConstruct(string, index[1], start, stop, escape, recurse, code);
137c71
<           index[1] = Translator.scanComments(string, index[1], true);
---
>           index[1] = scanComments(string, index[1], true);
150,153c84
<     // -System.err.println(("In: "+string.substring(offset,
<     // Math.min(string.length(),
<     // offset+16))+"..\t< offset='"+offset+"' start='"+start+"' stop='"+stop+"' index='"+index[0]+", "+index[1]+"'\tstring='"+string.substring(index[0],
<     // index[1])+"' />").replace('\n', ' '));
---
>     // -System.err.println(("In: "+string.substring(offset, Math.min(string.length(), offset+16))+"..\t< offset='"+offset+"' start='"+start+"' stop='"+stop+"' index='"+index[0]+", "+index[1]+"'\tstring='"+string.substring(index[0], index[1])+"' />").replace('\n', ' '));
156,175c87,93
<   /**
<    * Détermine les bornes d'une instruction Java.
<    * <p>
<    * Scanne une construction de la forme <tt>{ ../..}</tt> ou <tt>../..;</tt>
<    * </p>
<    *
<    * @param string
<    *            Le contenu du texte à analyser.
<    * @param offset
<    *            L'index de départ dans le texte à analyser.
<    * @return Renvoie int[2], l'index du premier caratère et un plus l'index du
<    *         dernier caractères du parenthésage,
<    *         <p>
<    *         tel que <tt>string.substring(index[0], index[1])</tt> corresponde
<    *         à la chaîne identifiée, sinon
<    *         </p>
<    *         <p>
<    *         la valeur <tt>{-1, offset}</tt> si le parenthésage n'est pas
<    *         trouvé.
<    *         </p>
---
>   /** Détermine les bornes d'une instruction Java.
>    * <p>Scanne une construction de la forme <tt>{ ../..}</tt> ou <tt>../..;</tt></p>
>    * @param string Le contenu du texte à analyser.
>    * @param offset L'index de départ dans le texte à analyser.
>    * @return Renvoie int[2], l'index du premier caratère et un plus l'index du dernier caractères du parenthésage,
>    * <p>tel que <tt>string.substring(index[0], index[1])</tt> corresponde à la chaîne identifiée, sinon</p>
>    * <p>la valeur <tt>{-1, offset}</tt> si le parenthésage n'est pas trouvé.</p>
178,179c96
<     int index[] = Translator.scanConstruct(string, offset, "{", "}", null,
<                                            true, true);
---
>     int index[] = scanConstruct(string, offset, "{", "}", null, true, true);
181,182c98
<       index = Translator.scanConstruct(string, offset, null, ";", null,
<                                        false, true);
---
>       index = scanConstruct(string, offset, null, ";", null, false, true);
186,203c102,107
<   /**
<    * Passe par dessus espaces, commentaires et chaines de caratères dans une
<    * portion de texte.
<    * <p>
<    * Passe par dessus les commentaires de programme <tt>/* . . *</tt>
<    * <tt>/</tt> ou <tt>// . . /n</tt> et les chaînes de caractères
<    * <tt>" . . "</tt>.
<    * </p>
<    *
<    * @param string
<    *            Le contenu du texte à analyser.
<    * @param offset
<    *            L'index de départ dans le texte à analyser.
<    * @param next
<    *            Incrémente l'offset en l'absence de structure à scanner, si
<    *            égal à true.
<    * @return L'index qui suit le texte éliminé, donc la valeur de l'offset (ou
<    *         offset plus un si incémente) si il n'y en a pas.
---
>   /** Passe par dessus espaces, commentaires et chaines de caratères dans une portion de texte.
>    * <p>Passe par dessus les commentaires de programme <tt>/* . . *</tt><tt>/</tt> ou <tt>// . . /n</tt> et les chaînes de caractères <tt>" . . "</tt>.</p>
>    * @param string Le contenu du texte à analyser.
>    * @param offset L'index de départ dans le texte à analyser.
>    * @param next Incrémente l'offset en l'absence de structure à scanner, si égal à true.
>    * @return L'index qui suit le texte éliminé, donc la valeur de l'offset (ou offset plus un si incémente) si il n'y en a pas.
209,215c113,116
<       offset = Translator.scanSpaces(string, offset);
<       offset = Translator.scanConstruct(string, offset, "/*", "*/", null,
<                                         false, false)[1];
<       offset = Translator.scanConstruct(string, offset, "//", "\n", null,
<                                         false, false)[1];
<       offset = Translator.scanConstruct(string, offset, "\"", "\"",
<                                         "\\\"", false, false)[1];
---
>       offset = scanSpaces(string, offset);
>       offset = scanConstruct(string, offset, "/*", "*/", null, false, false)[1];
>       offset = scanConstruct(string, offset, "//", "\n", null, false, false)[1];
>       offset = scanConstruct(string, offset, "\"", "\"", "\\\"", false, false)[1];
220,228c121,124
<   /**
<    * Passe par dessus les espaces dans une portion de texte.
<    *
<    * @param string
<    *            Le contenu du texte à analyser.
<    * @param offset
<    *            L'index de départ dans le texte à analyser.
<    * @return L'index qui suit les espaces, donc la valeur de l'offset si il
<    *         n'y en a pas.
---
>   /** Passe par dessus les espaces dans une portion de texte.
>    * @param string Le contenu du texte à analyser.
>    * @param offset L'index de départ dans le texte à analyser.
>    * @return L'index qui suit les espaces, donc la valeur de l'offset si il n'y en a pas.
231,233c127
<     for(; offset < string.length()
<         && Character.isWhitespace(string.charAt(offset)); offset++)
<       ;
---
>     for(; offset < string.length() && Character.isWhitespace(string.charAt(offset)); offset++) ;

>>> ./src/org/javascool/core/JvsBeautifier.java

9,17c9,11
<   /**
<    * Reformate un morceau de code Jvs.
<    * <p>
<    * - C'est un mécanisme restritif un peu fragile destiné au sous-langage Jvs
<    * de Java.
<    * </p>
<    *
<    * @param text
<    *            Le source à reformate.
---
>   /** Reformate un morceau de code Jvs.
>    * <p>- C'est un mécanisme restritif un peu fragile destiné au sous-langage Jvs de Java.</p>
>    * @param text Le source à reformate.
24c18
<     for(int i = 0; i < f.length;) {
---
>     for(int i = 0, j; i < f.length;) {
33d26
<           // Escapes // comments
34a28
>         // Escapes // comments
44,46c38
<         while(i < f.length && (f[i - 1] == '\\' || f[i] != '"')
<               && f[i] != '\n')
<         {
---
>         while(i < f.length && (f[i - 1] == '\\' || f[i] != '"') && f[i] != '\n') {
51d42
<           // Escapes @ pragma
52a44
>         // Escapes @ pragma
76,79c68,69
<         if(JvsBeautifier.isOperator(f[i])) {
<           if(!(Character.isWhitespace(c0) || JvsBeautifier
<                .isOperator(c0)))
<           {
---
>         if(isOperator(f[i])) {
>           if(!(Character.isWhitespace(c0) || isOperator(c0))) {
83,86c73
<           if((i < f.length - 1)
<              && !(Character.isWhitespace(f[i + 1]) || JvsBeautifier
<                   .isOperator(f[i + 1])))
<           {
---
>           if((i < f.length - 1) && !(Character.isWhitespace(f[i + 1]) || isOperator(f[i + 1]))) {
96d82
<             // Normalize spaces around punctuation
97a84
>           // Normalize spaces around punctuation
104,106c91
<             if((i < f.length - 1)
<                && !Character.isWhitespace(f[i + 1]))
<             {
---
>             if((i < f.length - 1) && !Character.isWhitespace(f[i + 1])) {
110,112c95
<           if((f[i] == ')') && (i < f.length - 1)
<              && (f[i + 1] == '{'))
<           {
---
>           if((f[i] == ')') && (i < f.length - 1) && (f[i + 1] == '{')) {
116,121c99
<           if((g.length() > 0)
<              && Character.isWhitespace(c0)
<              && (g.length() > 1)
<              && Character
<              .isLetterOrDigit(g.charAt(g.length() - 2)))
<           {
---
>           if((g.length() > 0) && Character.isWhitespace(c0) && (g.length() > 1) && Character.isLetterOrDigit(g.charAt(g.length() - 2))) {
130,133c108
<             if((g.length() > 0)
<                && Character
<                .isWhitespace(g.charAt(g.length() - 1)))
<             {
---
>             if((g.length() > 0) && Character.isWhitespace(g.charAt(g.length() - 1))) {
141,143c116
<         if((f[i] == '{') || (f[i] == '}')
<            || ((f[i] == ';') && (par == 0)))
<         {
---
>         if((f[i] == '{') || (f[i] == '}') || ((f[i] == ';') && (par == 0))) {
155,158c128
<           boolean nextIsNotImport = f[i] != ';'
<                                     || bra > 0
<                                     || !text.substring(i + 1).matches(
<             "\\s*(;\\s*)?import(.|\n)*");
---
>           boolean nextIsNotImport = f[i] != ';' || bra > 0 || !text.substring(i + 1).matches("\\s*(;\\s*)?import(.|\n)*");
171,174c141,143
<     return "\n"
<            + g.replaceAll("\\}\\s*else\\s*(\\{|if)", "} else $1")
<            .replaceAll("(while|if|for|return)\\s*([^a-z_0-9_])",
<                        "$1 $2");
---
>     return "\n" + g.
>            replaceAll("\\}\\s*else\\s*(\\{|if)", "} else $1").
>            replaceAll("(while|if|for|return)\\s*([^a-z_0-9_])", "$1 $2");

>>> ./src/org/javascool/core/Java2Class.java

5a6,7
> import java.net.URL;
> import java.net.URLClassLoader;
6a9
> import java.io.IOException;
10,11c13,15
< import java.net.URL;
< import java.net.URLClassLoader;
---
> import java.util.ArrayList;
> import java.util.List;
> import java.util.Locale;
12a17,22
> import javax.tools.Diagnostic;
> import javax.tools.DiagnosticCollector;
> import javax.tools.JavaCompiler;
> import javax.tools.JavaFileObject;
> import javax.tools.StandardJavaFileManager;
> import javax.tools.ToolProvider;
14,20c24,25
< /**
<  * Définit le mécanisme de compilation en ligne d'un code Java et du chargement
<  * de la classe obtenue.
<  * <p>
<  * Note: utilise un sous ensemble du <tt>tools.jar</tt> de la JDK appelé ici
<  * <tt>javac.jar</tt> qui doit être dans le CLASSPATH.
<  * </p>
---
> /** Définit le mécanisme de compilation en ligne d'un code Java et du chargement de la classe obtenue.
>  * <p>Note: utilise un sous ensemble du <tt>tools.jar</tt> de la JDK appelé ici <tt>javac.jar</tt> qui doit être dans le CLASSPATH.</p>
28,54c33,41
<   /**
<    * Compile dans le système de fichier local, un code source Java.
<    * <p>
<    * Les fichiers <tt>.class</tt> sont générés sur place.
<    * </p>
<    * <p>
<    * Les erreurs de compilation sont affichées dans la console.
<    * </p>
<    * <p>
<    * Les erreurs les plus courantes sont reformulées en français.
<    * </p>
<    * <p>
<    * Les portions de code de la forme <tt>/*<i>code-jvs</i> @&lt;nojavac*</tt>
<    * <tt>/<i>code-java-derive</ii>/*@nojavac>*</tt><tt>/</tt> issus de
<    * pseudo-code retraduit en Java par un <a
<    * href="Translator.html">Translator</a> sont traités pour que seul le
<    * <i>code-jvs</i> soit affiché en cas d'erreur de syntaxe.
<    * </p>
<    *
<    * @param javaFile
<    *            Le nom du fichier à compiler. Un tableau de noms de fichiers
<    *            peut être donné.
<    * @param allErrors
<    *            Renvoie toutes les erreur si true, sinon uniquement la
<    *            première erreur (par défaut).
<    * @return La valeur true en cas de succès, false si il y a des erreurs de
<    *         compilation.
---
> 
>   /** Compile dans le système de fichier local, un code source Java.
>    * <p>Les fichiers <tt>.class</tt> sont générés sur place.</p>
>    * <p>Les erreurs de compilation sont affichées dans la console.</p>
>    * <p>Les erreurs les plus courantes sont reformulées en français.</p>
>    * <p>Les portions de code de la forme <tt>/*<i>code-jvs</i> @&lt;nojavac*</tt><tt>/<i>code-java-derive</ii>/*@nojavac>*</tt><tt>/</tt> issus de pseudo-code retraduit en Java par un <a href="Translator.html">Translator</a> sont traités pour que seul le <i>code-jvs</i> soit affiché en cas d'erreur de syntaxe.</p>
>    * @param javaFile Le nom du fichier à compiler. Un tableau de noms de fichiers peut être donné.
>    * @param allErrors Renvoie toutes les erreur si true, sinon uniquement la première erreur (par défaut).
>    * @return La valeur true en cas de succès, false si il y a des erreurs de compilation.
56,58c43
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite lors de la
<    *             compilation.
---
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de la compilation.
62c47
<     return Java2Class.compile(javaFiles, allErrors);
---
>     return compile(javaFiles, allErrors);
68c53
<     return Java2Class.compile(javaFile, false);
---
>     return compile(javaFile, false);
74c59
<     return Java2Class.compile(javaFiles, false);
---
>     return compile(javaFiles, false);
83c68,123
<     return Java2Class.compile2(javaFiles, allErrors);
---
>     return compile2(javaFiles, allErrors);
>   }
>   // Implementation using the javac compiler api : il n'est plus utilisé (donc plus maintenu !) avec l'arrivée dela jre 76
>   // Attention ce code n'est plus à jour il est gardé ici uniquement en arcive !!!!!
>   private static boolean compile1(String javaFiles[], boolean allErrors) {
>     // Initialisation des objets dy compilateur// The compiler tool
>     JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); // The compiler tool
>     if(compiler == null) {
>       System.err.println("Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)"); throw new IllegalStateException("Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)");
>     }
>     DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<JavaFileObject>(); // The diagnostic colector
>     StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, Locale.FRENCH, null); // The file manager
>     // Mise en place des fichiers
>     List<File> sourceFileList = new ArrayList<File>();
>     for(String javaFile : javaFiles)
>       sourceFileList.add(new File(javaFile));
>     Iterable< ? extends JavaFileObject> compilationUnits = fileManager.getJavaFileObjectsFromFiles(sourceFileList);
>     // Lancement de la compilation
>     JavaCompiler.CompilationTask task = compiler.getTask(null, fileManager, diagnostics, null, null, compilationUnits);
>     task.call();
>     try {
>       fileManager.close();
>     } catch(IOException e) {
>       System.err.println("Erreur à la fermeture du file-manager du compilateur : " + e);
>     }
>     // Gestion des erreurs
>     for(Diagnostic diagnostic : diagnostics.getDiagnostics()) {
>       String javaDiagnostic = diagnostic.getMessage(Locale.FRENCH);
>       String jvsDiagnostic = javaFiles.length > 1 ? javaDiagnostic : javaDiagnostic.split(" ", 2)[1];
>       if(jvsDiagnostic.equals("not a statement")) {
>         jvsDiagnostic = "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)";
>       } else if(jvsDiagnostic.equals("';' expected")) {
>         jvsDiagnostic = "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)";
>       } else if(jvsDiagnostic.startsWith("cannot find symbol")) {
>         jvsDiagnostic = "Il y a un symbole non-défini à cette ligne: " +
>                         jvsDiagnostic.replaceFirst("cannot[^:]*:\\s*([^\\n]*)[^:]*:\\s*(.*)", "«$1»");
>       } else if(jvsDiagnostic.matches(".*\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)")) {
>         jvsDiagnostic = jvsDiagnostic.replaceAll("incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
>                                                  "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
>       } else if(jvsDiagnostic.matches("package org\\.javascool\\.proglets\\.[A-Za-z0-9_]+ does not exist")) {
>         jvsDiagnostic = jvsDiagnostic.replaceAll("package org\\.javascool\\.proglets\\.([A-Za-z0-9_]+) does not exist",
>                                                  "La proglet $1 n'existe pas");
>       } else {
>         jvsDiagnostic = "Erreur Java : «" + jvsDiagnostic + "»";
>       }
>       int line = (int) diagnostic.getLineNumber();
>       String source = new File(diagnostic.getSource().toString()).getParentFile().getName() + "/" + new File(diagnostic.getSource().toString()).getName();
>       String where = javaFiles.length == 1 ? "" : " de " + source + "";
>       System.out.println("-------------------\nErreur lors de la compilation à la ligne " + line + where + ".\n" + jvsDiagnostic + "\n-------------------");
>       System.err.println("Erreur à la compilation: fichier=" + source + " ligne =" + line + " erreur=" + javaDiagnostic);
>       // En fait ici on choisit d'arrêter à la 1ère erreur pour pas embrouiller l'apprennant
>       if(diagnostic.getKind().equals(Diagnostic.Kind.ERROR) && !allErrors) {
>         return false;
>       }
>     }
>     return true;
85,146d124
<   // Implementation using the javac compiler api : il n'est plus utilisé (donc
<   // plus maintenu !) avec l'arrivée dela jre 76
<   // Attention ce code n'est plus à jour il est gardé ici uniquement en arcive
<   // !!!!!
< 
<   /*
<    * private static boolean compile1(String javaFiles[], boolean allErrors) {
<    * // Initialisation des objets dy compilateur// The compiler tool
<    * JavaCompiler compiler = ToolProvider.getSystemJavaCompiler(); // The
<    * compiler tool if (compiler == null) { System.err.println(
<    * "Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)"
<    * ); throw new IllegalStateException(
<    * "Attention !!: le compilateur ne peut être chargé (il est absent du path ou sa version est incorrecte)"
<    * ); } DiagnosticCollector<JavaFileObject> diagnostics = new
<    * DiagnosticCollector<JavaFileObject>(); // The diagnostic colector
<    * StandardJavaFileManager fileManager =
<    * compiler.getStandardFileManager(null, Locale.FRENCH, null); // The file
<    * manager // Mise en place des fichiers List<File> sourceFileList = new
<    * ArrayList<File>(); for(String javaFile : javaFiles)
<    * sourceFileList.add(new File(javaFile)); Iterable< ? extends
<    * JavaFileObject> compilationUnits =
<    * fileManager.getJavaFileObjectsFromFiles(sourceFileList); // Lancement de
<    * la compilation JavaCompiler.CompilationTask task = compiler.getTask(null,
<    * fileManager, diagnostics, null, null, compilationUnits); task.call(); try
<    * { fileManager.close(); } catch(IOException e) {
<    * System.err.println("Erreur à la fermeture du file-manager du compilateur : "
<    * + e); } // Gestion des erreurs for(Diagnostic<?> diagnostic :
<    * diagnostics.getDiagnostics()) { String javaDiagnostic =
<    * diagnostic.getMessage(Locale.FRENCH); String jvsDiagnostic =
<    * javaFiles.length > 1 ? javaDiagnostic : javaDiagnostic.split(" ", 2)[1];
<    * if(jvsDiagnostic.equals("not a statement")) jvsDiagnostic =
<    * "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)"
<    * ; else if(jvsDiagnostic.equals("';' expected")) jvsDiagnostic =
<    * "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)"
<    * ; else if(jvsDiagnostic.startsWith("cannot find symbol")) jvsDiagnostic =
<    * "Il y a un symbole non-défini à cette ligne: " +
<    * jvsDiagnostic.replaceFirst("cannot[^:]*:\\s*([^\\n]*)[^:]*:\\s*(.*)",
<    * "«$1»"); else if(jvsDiagnostic.matches(
<    * ".*\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)"))
<    * jvsDiagnostic = jvsDiagnostic.replaceAll(
<    * "incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)"
<    * ,
<    * "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2"
<    * ); else if(jvsDiagnostic.matches(
<    * "package org\\.javascool\\.proglets\\.[A-Za-z0-9_]+ does not exist"))
<    * jvsDiagnostic = jvsDiagnostic.replaceAll(
<    * "package org\\.javascool\\.proglets\\.([A-Za-z0-9_]+) does not exist",
<    * "La proglet $1 n'existe pas"); else jvsDiagnostic = "Erreur Java : «" +
<    * jvsDiagnostic + "»"; int line = (int) diagnostic.getLineNumber(); String
<    * source = new
<    * File(diagnostic.getSource().toString()).getParentFile().getName() + "/" +
<    * new File(diagnostic.getSource().toString()).getName(); String where =
<    * javaFiles.length == 1 ? "" : " de " + source + ""; System.out.println(
<    * "-------------------\nErreur lors de la compilation à la ligne " + line +
<    * where + ".\n" + jvsDiagnostic + "\n-------------------");
<    * System.err.println
<    * ("Erreur à la compilation: fichier="+source+" ligne ="+line
<    * +" erreur="+javaDiagnostic); // En fait ici on choisit d'arrêter à la
<    * 1ère erreur pour pas embrouiller l'apprennant
<    * if(diagnostic.getKind().equals(Diagnostic.Kind.ERROR) && !allErrors)
<    * return false; } return true; }
<    */
157,162c135,137
<       javac = Class.forName("com.sun.tools.javac.Main")
<               .getDeclaredMethod("compile",
<                                  Class.forName("[Ljava.lang.String;"),
<                                  Class.forName("java.io.PrintWriter"));
<     } catch(Exception e) { throw new IllegalStateException(
<                                    "Impossible d'accéder au compilateur javac : " + e);
---
>       javac = Class.forName("com.sun.tools.javac.Main").
>               getDeclaredMethod("compile", Class.forName("[Ljava.lang.String;"), Class.forName("java.io.PrintWriter"));
>     } catch(Exception e) { throw new IllegalStateException("Impossible d'accéder au compilateur javac : " + e);
165,168c140,141
<       javac.invoke(null, args, new PrintWriter(out));
<     } catch(Exception e) { throw new IllegalStateException(
<                                    "Erreur système lors du lancement du compilateur javac : "
<                                    + e);
---
>       javac.invoke(null, (Object) args, new PrintWriter(out));
>     } catch(Exception e) { throw new IllegalStateException("Erreur système lors du lancement du compilateur javac : " + e);
180,183c153,154
<           sout = sout.replaceAll(
<             Pattern.quote(new File(javaFile).getParent()
<                           + File.separator), "\n");
<          // Explicitation du numéro de ligne
---
>           sout = sout.replaceAll(Pattern.quote(new File(javaFile).getParent() + File.separator), "\n");
>         // Explicitation du numéro de ligne
185,188c156
<           sout = sout.replaceAll(
<             "(" + Pattern.quote(new File(javaFile).getName())
<             + "):([0-9]+):",
<             "$1 : erreur de syntaxe ligne $2 :\n ");
---
>           sout = sout.replaceAll("(" + Pattern.quote(new File(javaFile).getName()) + "):([0-9]+):", "$1 : erreur de syntaxe ligne $2 :\n ");
190,195c158,159
<         sout = sout.replaceAll(
<           "(" + Pattern.quote(new File(javaFiles[0]).getPath())
<           + "):([0-9]+):",
<           "\n Erreur de syntaxe ligne $2 :\n ");
<         sout = sout.replaceAll(Pattern.quote(new File(javaFiles[0])
<                                              .getName().replaceFirst("java$", "")), "");
---
>         sout = sout.replaceAll("(" + Pattern.quote(new File(javaFiles[0]).getPath()) + "):([0-9]+):", "\n Erreur de syntaxe ligne $2 :\n ");
>         sout = sout.replaceAll(Pattern.quote(new File(javaFiles[0]).getName().replaceFirst("java$", "")), "");
200,224c164,177
<       sout = sout
<              .replaceAll(
<         "not a statement",
<         "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)");
<       sout = sout
<              .replaceAll("';' expected",
<                          "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)");
<       sout = sout
<              .replaceAll(
<         "cannot find symbol\\s*symbol\\s*:\\s*([^\\n]*)[^:]*:\\s*(.*)",
<         "Il y a un symbole non-défini à cette ligne : «$1» (utilisez-vous la bonne proglet ?)");
<       sout = sout
<              .replaceAll("illegal start of expression",
<                          "($0) L'instruction (ou la précédente) est tronquée ou mal écrite");
<       sout = sout
<              .replaceAll(
<         "class, interface, or enum expected",
<         "($0) Il y a probablement une erreur dans les accolades (peut-être trop de '}')");
<       sout = sout
<              .replaceAll("'.class' expected",
<                          "($0) Il manque des accolades ou des parenthèses pour définir l'instruction");
<       sout = sout
<              .replaceAll(
<         "incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
<         "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
---
>       sout = sout.replaceAll("not a statement",
>                              "L'instruction n'est pas valide.\n (Il se peut qu'une variable indiquée n'existe pas)");
>       sout = sout.replaceAll("';' expected",
>                              "Un ';' est attendu (il peut manquer, ou une parenthèse être incorrecte, ..)");
>       sout = sout.replaceAll("cannot find symbol\\s*symbol\\s*:\\s*([^\\n]*)[^:]*:\\s*(.*)",
>                              "Il y a un symbole non-défini à cette ligne : «$1» (utilisez-vous la bonne proglet ?)");
>       sout = sout.replaceAll("illegal start of expression",
>                              "($0) L'instruction (ou la précédente) est tronquée ou mal écrite");
>       sout = sout.replaceAll("class, interface, or enum expected",
>                              "($0) Il y a probablement une erreur dans les accolades (peut-être trop de '}')");
>       sout = sout.replaceAll("'.class' expected",
>                              "($0) Il manque des accolades ou des parenthèses pour définir l'instruction");
>       sout = sout.replaceAll("incompatible\\Wtypes\\W*found\\W*:\\W([A-Za-z\\.]*)\\Wrequired:\\W([A-Za-z\\.]*)",
>                              "Vous avez mis une valeur de type $1 alors qu'il faut une valeur de type $2");
236,242c189,190
<   /**
<    * Charge dynamiquement une classe Java qui implémente un Runnable, pour son
<    * e×écution au cours d'une session.
<    *
<    * @param path
<    *            Le chemin vers la classe Java à charger. La classe ne doit pas
<    *            appartenir à un package, c'est-à-dire au package "default".
---
>   /** Charge dynamiquement une classe Java qui implémente un Runnable, pour son e×écution au cours d'une session.
>    * @param path Le chemin vers la classe Java à charger. La classe ne doit pas appartenir à un package, c'est-à-dire au package "default".
245,249c193,194
<    * @throws IllegalArgumentException
<    *             Si la classe n'est pas un Runnable.
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite lors du
<    *             chargement.
---
>    * @throws IllegalArgumentException Si la classe n'est pas un Runnable.
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors du chargement.
254,257c199,200
<       URL[] urls = new URL[] { new URL("file:" + javaClass.getParent()
<                                        + File.separator) };
<       Class< ? > j_class = new URLClassLoader(urls).loadClass(javaClass
<                                                               .getName().replaceAll("\\.java", ""));
---
>       URL[] urls = new URL[] { new URL("file:" + javaClass.getParent() + File.separator) };
>       Class< ? > j_class = new URLClassLoader(urls).loadClass(javaClass.getName().replaceAll("\\.java", ""));
259,260c202
<       if(!(o instanceof Runnable)) { throw new IllegalArgumentException("Erreur: la classe de "
<                                                                         + javaClass + " n'est pas un Runnable");
---
>       if(!(o instanceof Runnable)) { throw new IllegalArgumentException("Erreur: la classe de " + javaClass + " n'est pas un Runnable");
263,264c205
<     } catch(Throwable e) { throw new RuntimeException(
<                                    "Erreur: impossible de charger la classe de : " + path);
---
>     } catch(Throwable e) { throw new RuntimeException("Erreur: impossible de charger la classe de : " + path);
267a209
> 

>>> ./src/org/javascool/core/Exec.java

7,9d6
< import java.io.BufferedInputStream;
< import java.io.File;
< import java.io.FileOutputStream;
12d8
< import java.net.URL;
13a10
> import java.io.File;
14a12,14
> import java.io.BufferedInputStream;
> import java.io.FileOutputStream;
> import java.net.URL;
16,18c16
< /**
<  * Exécute une commande du système d'exploitation.
<  *
---
> /** Exécute une commande du système d'exploitation.
25,40c23,28
<   /**
<    * Execute la commande et renvoie le résultat.
<    *
<    * @param command
<    *            La commande avec ses arguments séparés par des tabulations
<    *            (caractère "\t") ou, sans cela, des espaces (caractère " ").
<    * @param timeout
<    *            Temporisation maximale avant la fin de la commande. Valeur par
<    *            défaut 10.
<    *            <p>
<    *            Si 0, l'attente est indéfinie.
<    *            </p>
<    *            <p>
<    *            Si -1, la commande est lancée en arrière plan et la fonction
<    *            revient tout de suite, sans résultat.
<    *            </p>
---
> 
>   /** Execute la commande et renvoie le résultat.
>    * @param command La commande avec ses arguments séparés par des tabulations (caractère "\t") ou, sans cela, des espaces (caractère " ").
>    * @param timeout Temporisation maximale avant la fin de la commande.  Valeur par défaut 10.
>    * <p>Si 0, l'attente est indéfinie.</p>
>    * <p>Si -1, la commande est lancée en arrière plan et la fonction revient tout de suite, sans résultat.</p>
42,47c30,31
<    * @throws RuntimeException
<    *             Si une erreur d'entrée-sortie s'est produite lors de
<    *             l'exécution.
<    * @throws IllegalStateException
<    *             Si le statut de retour de la commande n'est pas 0 (donc a un
<    *             numéro d'erreur) ou si la temporisation est dépassée.
---
>    * @throws RuntimeException Si une erreur d'entrée-sortie s'est produite lors de l'exécution.
>    * @throws IllegalStateException Si le statut de retour de la commande n'est pas 0 (donc a un numéro d'erreur) ou si la temporisation est dépassée.
51c35
<       Process process = Exec.exec(command);
---
>       Process process = exec(command);
56,61c40,42
<       long time = timeout > 0 ? System.currentTimeMillis() + 1000
<                   * timeout : 0;
<       InputStreamReader stdout = new InputStreamReader(
<         process.getInputStream());
<       InputStreamReader stderr = new InputStreamReader(
<         process.getErrorStream());
---
>       long time = timeout > 0 ? System.currentTimeMillis() + 1000 * timeout : 0;
>       InputStreamReader stdout = new InputStreamReader(process.getInputStream());
>       InputStreamReader stderr = new InputStreamReader(process.getErrorStream());
83,85c64
<         if((time > 0) && (System.currentTimeMillis() > time)) { throw new IllegalStateException("Command {" + command
<                                                                                                 + "} timeout (>" + timeout + "s) output=[" + output
<                                                                                                 + "]\n");
---
>         if((time > 0) && (System.currentTimeMillis() > time)) { throw new IllegalStateException("Command {" + command + "} timeout (>" + timeout + "s) output=[" + output + "]\n");
96,98c75
<       if(process.exitValue() != 0) { throw new IllegalStateException("Command {" + command
<                                                                      + "} error #" + process.exitValue() + " output=[\n"
<                                                                      + output + "\n]\n");
---
>       if(process.exitValue() != 0) { throw new IllegalStateException("Command {" + command + "} error #" + process.exitValue() + " output=[\n" + output + "\n]\n");
108c85
<     return Exec.run(command, 10);
---
>     return run(command, 10);
111,114c88,89
<   private static Process exec(String command) throws IOException {
<     return Runtime.getRuntime().exec(
<              command.trim()
<              .split((command.indexOf('\t') == -1) ? " " : "\t"));
---
>   private static Process exec(String command) throws IOException  {
>     return Runtime.getRuntime().exec(command.trim().split((command.indexOf('\t') == -1) ? " " : "\t"));
116,123c91,93
<   /**
<    * Démarre un nouveau programme java en place de celui là.
<    *
<    * @param jar
<    *            La jarre contenant le programme Java à lancé à la place de
<    *            celui là.
<    * @return La valeur true si le programme a pu se lancer, sinon la valeur
<    *         false.
---
>   /** Démarre un nouveau programme java en place de celui là.
>    * @param jar La jarre contenant le programme Java à lancé à la place de celui là.
>    * @return La valeur true si le programme a pu se lancer, sinon la valeur false.
127,130c97,98
<       String command = System.getProperty("java.home") + File.separator
<                        + "bin" + File.separator + "java\t-jar\t"
<                        + Exec.getLocal(jar);
<       Exec.exec(command);
---
>       String command = System.getProperty("java.home") + File.separator + "bin" + File.separator + "java\t-jar\t" + getLocal(jar);
>       exec(command);
133,134c101
<       System.err.println("Impossible de lancer le jar '" + jar + "' :"
<                          + e);
---
>       System.err.println("Impossible de lancer le jar '" + jar + "' :" + e);
139c106
<   private static String getLocal(String location) throws IOException {
---
>   private static String getLocal(String location) throws IOException  {
141,142c108
<     File file = File.createTempFile(new File(url.getFile()).getName()
<                                     .replaceFirst("\\.jar$", "") + "-", ".jar");
---
>     File file = File.createTempFile(new File(url.getFile()).getName().replaceFirst("\\.jar$", "") + "-", ".jar");
144,145c110
<       BufferedInputStream i = new BufferedInputStream(url.openStream(),
<                                                       2048);
---
>       BufferedInputStream i = new BufferedInputStream(url.openStream(), 2048);

>>> ./src/org/javascool/core/ProgletEngine.java

8c8,10
< import java.io.File;
---
> import java.applet.Applet;
> import java.awt.Component;
> import java.awt.Dimension;
9a12,14
> import org.javascool.macros.Macros;
> 
> import java.io.File;
12c17
< 
---
> import javax.swing.JFrame;
14a20,22
> import org.javascool.tools.Pml;
> import org.javascool.tools.Invoke;
> import org.javascool.widgets.MainFrame;
16,17c24
< /**
<  * Définit les mécanismes de compilation, exécution, gestion de proglet.
---
> /** Définit les mécanismes de compilation, exécution, gestion de proglet.
28,32c35,36
<   /**
<    * Crée et/ou renvoie l'unique instance de l'engine.
<    * <p>
<    * Une application ne peut définir qu'un seul engine.
<    * </p>
---
>   /** Crée et/ou renvoie l'unique instance de l'engine.
>    * <p>Une application ne peut définir qu'un seul engine.</p>
35,36c39,40
<     if(ProgletEngine.engine == null) {
<       ProgletEngine.engine = new ProgletEngine();
---
>     if(engine == null) {
>       engine = new ProgletEngine();
38c42
<     return ProgletEngine.engine;
---
>     return engine;
47,51c51,52
<       for(String dir : FileManager.list(javascoolJar,
<                                         "org.javascool.proglets.[^\\.]+.proglet.pml"))
<       {
<         String name = dir.replaceFirst("jar:[^!]*!(.*)proglet.pml",
<                                        "$1");
---
>       for(String dir : FileManager.list(javascoolJar, "org.javascool.proglets.[^\\.]+.proglet.pml")) {
>         String name = dir.replaceFirst("jar:[^!]*!(.*)proglet.pml", "$1");
56,58c57
<           System.err
<           .println("Erreur lors de la détection dans le jar de la proglet "
<                    + name + " en " + dir + " (" + e + ")");
---
>           System.err.println("Erreur lors de la détection dans le jar de la proglet " + name + " en " + dir + " (" + e + ")");
62,64c61
<       System.err.println("Erreur lors de la détection des proglets ("
<                          + er + " avec " + javascoolJar
<                          + "\n . . vous pouvez quand même utiliser JavaScool");
---
>       System.err.println("Erreur lors de la détection des proglets (" + er + " avec " + javascoolJar + "\n . . vous pouvez quand même utiliser JavaScool");
71,74c68,69
<         p.pml.set("icon-location",
<                   "org/javascool/widgets/icons/scripts.png");
<         p.pml.set("help-location",
<                   "org/javascool/macros/memo-macros.htm");
---
>         p.pml.set("icon-location", "org/javascool/widgets/icons/scripts.png");
>         p.pml.set("help-location", "org/javascool/macros/memo-macros.htm");
91,94c86,87
<   /**
<    * Mécanisme de compilation du fichier Jvs.
<    *
<    * @param program Le code à compiler
---
>   /** Mécanisme de compilation du fichier Jvs.
>    * @param program Nom du programme à compiler.
99,100c92
<     // Traduction Jvs -> Java puis Java -> Class et chargement de la classe
<     // si succès
---
>     // Traduction Jvs -> Java puis Java -> Class et chargement de la classe si succès
104,106c96
<       jvs2java.setProgletPackageName(getProglet().hasFunctions() ? "org.javascool.proglets."
<                                      + getProglet().getName()
<                                      : null);
---
>       jvs2java.setProgletPackageName(getProglet().hasFunctions() ? "org.javascool.proglets." + getProglet().getName() : null);
113,114c103
<       javaFile = buildDir + File.separator + jvs2java.getClassName()
<                  + ".java";
---
>       javaFile = buildDir + File.separator + jvs2java.getClassName() + ".java";
116,117c105
<       // Si il y a un problème avec le répertoire temporaire on se rabat
<       // sur le répertoire local
---
>       // Si il y a un problème avec le répertoire temporaire on se rabat sur le répertoire local
120,123c108,109
<         javaFile = new File(jvs2java.getClassName() + ".java")
<                    .getAbsolutePath();
<         System.err
<         .println("Sauvegarde locale du fichier : " + javaFile);
---
>         javaFile = new File(jvs2java.getClassName() + ".java").getAbsolutePath();
>         System.err.println("Sauvegarde locale du fichier : " + javaFile);
127,130c113
<         System.out
<         .println("Attention ! le répertoire '"
<                  + System.getProperty("user.dir")
<                  + "' ne peut être utilisé pour sauver des fichiers, \n il faut re-lancer javascool dans un répertoire de travail approprié.");
---
>         System.out.println("Attention ! le répertoire '" + System.getProperty("user.dir") + "' ne peut être utilisé pour sauver des fichiers, \n il faut re-lancer javascool dans un répertoire de travail approprié.");
139,142c122
<         System.out
<         .println("Attention ! il y a eu une action externe de netoyyage de fichiers temporraires ou le répertoire '"
<                  + new File(javaFile).getParent()
<                  + "' ne peut être utilisé pour sauver des fichiers, \n il faut re-lancer javascool dans un répertoire de travail approprié.");
---
>         System.out.println("Attention ! il y a eu une action externe de netoyyage de fichiers temporraires ou le répertoire '" + new File(javaFile).getParent() + "' ne peut être utilisé pour sauver des fichiers, \n il faut re-lancer javascool dans un répertoire de travail approprié.");
169,174c149,150
<   /**
<    * Mécanisme d'arrêt du programme compilé.
<    *
<    * @param message
<    *            Message d'erreur affiché à la console. Si null (par défaut)
<    *            pas de message.
---
>   /** Mécanisme d'arrêt du programme compilé.
>    * @param message Message d'erreur affiché à la console. Si null (par défaut) pas de message.
198,202c174,175
<   /**
<    * Renvoie le runnable correspondant au programme utilisateur en cours.
<    *
<    * @return Le runnable correspondant au programme démarré par doRun() ou
<    *         null si il n'y en a pas.
---
>   /** Renvoie le runnable correspondant au programme utilisateur en cours.
>    * @return Le runnable correspondant au programme démarré par doRun() ou null si il n'y en a pas.
211,215c184,185
<   /**
<    * Mécanisme de chargement d'une proglet.
<    *
<    * @param proglet
<    *            Le nom de la proglet.
---
>   /** Mécanisme de chargement d'une proglet.
>    * @param proglet Le nom de la proglet.
217,218c187
<    * @throws IllegalArgumentException
<    *             Si il y a tentative d'utilisation d'une proglet indéfinie
---
>    * @throws IllegalArgumentException Si il y a tentative d'utilisation d'une proglet indéfinie
229,231c198
<     if(currentProglet == null) { throw new IllegalArgumentException(
<                                          "Tentative d'utilisation d'une proglet indéfinie : "
<                                          + proglet);
---
>     if(currentProglet == null) { throw new IllegalArgumentException("Tentative d'utilisation d'une proglet indéfinie : " + proglet);
236,238c203
<   /**
<    * Renvoie la proglet demandé.
<    *
---
>   /** Renvoie la proglet demandé.
248,249c213,214
<   /**
<    * Renvoie la proglet courante. * @return la proglet courante ou null sinon.
---
>   /** Renvoie la proglet courante.
>    * * @return la proglet courante ou null sinon.
256,260c221,222
<   /**
<    * Renvoie toutes les proglets actuellement disponibles.
<    *
<    * @return Un objet utilisable à travers la construction
<    *         <tt>for(Proglet proglet: getProglets()) { .. / .. }</tt>.
---
>   /** Renvoie toutes les proglets actuellement disponibles.
>    * @return Un objet utilisable à travers la construction <tt>for(Proglet proglet: getProglets()) { .. / .. }</tt>.
265,272c227,423
<   /**
<    * Compte le nombre de proglets dans le programme courant
<    *
<    * @return Le nombre de proglets, 0 si il n'y en a pas
<    */
<   public int count() {
<     if(this.proglets == null) {
<       return 0;
---
>   public class Proglet {
>     /** Méta-données de la proglet. */
>     public Pml pml = new Pml();
> 
>     /** Définit une proglet à partir d'un répertoire donné.
>      * @param location L'URL (Universal Resource Location) où se trouve la proglet.
>      * @throws IllegalArgumentException Si l'URL est mal formée.
>      * @return Cet objet, permettant de définir la construction <tt>new Proglet().load(..)</tt>.
>      */
>     public Proglet load(String location) {
>       // Définit les méta-données de la proglet.
>       pml.load(location + "proglet.pml", true);
>       pml.set("location", location);
>       try {
>         pml.set("name", new File(location).getName());
>       } catch(Exception e) { throw new IllegalArgumentException(e + " : " + location + " is a malformed URL");
>       }
>       if(FileManager.exists(Macros.getResourceURL(location + "completion.xml"))) {
>         pml.set("completion", location + "completion.xml");
>       }
>       if(pml.isDefined("icon")
>          && FileManager.exists(Macros.getResourceURL(location + pml.getString("icon"))))
>       {
>         pml.set("icon-location", location + pml.getString("icon"));
>       } else {
>         pml.set("icon-location", "org/javascool/widgets/icons/scripts.png");
>       }
>       try {
>         Class.forName("org.javascool.proglets." + pml.getString("name") + ".Functions");
>         pml.set("has-functions", true);
>       } catch(Throwable e) {
>         pml.set("has-functions", false);
>       }
>       if(!pml.isDefined("help-location")) {
>         pml.set("help-location", pml.getString("location") + "help.htm");
>       }
>       try {
>         pml.set("jvs-translator", (Translator) Class.forName("org.javascool.proglets." + pml.getString("name") + ".Translator").newInstance());
>       } catch(Throwable e) {}
>       return this;
>     }
>     @Override
>     public String toString() {
>       return pml.toString();
>     }
>     /** Renvoie le nom de la proglet.
>      * @return Le nom de la proglet.
>      */
>     public String getName() {
>       return pml.getString("name");
>     }
>     /** Renvoie le titre de la proglet.
>      * @return Le titre de la proglet.
>      */
>     public String getTitle() {
>       return pml.getString("title");
>     }
>     /** Renvoie l'icone de la proglet.
>      * @return Le nom de l'URL de l'icone de la proglet, ou l'icone par defaut sinon.
>      */
>     public String getIcon() {
>       return pml.getString("icon-location");
>     }
>     /** Renvoie la documentation de la proglet.
>      * @return L'URL de la documentation de la proglet.
>      */
>     public String getHelp() {
>       return pml.getString("help-location");
>     }
>     /** Renvoie l'url du fichier de completion de la proglet.
>      * @return L'URL de l'xml de completion de la proglet.
>      */
>     public String getCompletion() {
>       return pml.getString("completion", "");
>     }
>     /** Indique si la proglet définit des fonctions statiques pour l'utilisateur.
>      */
>     public boolean hasFunctions() {
>       return pml.getBoolean("has-functions");
>     }
>     /** Renvoie, si il existe, le panneau graphique à insérer dans javascool.
>      * @return Le panneau graphique de la proglet si il existe, sinon null.
>      */
>     public Component getPane() {
>       setPane();
>       return (Component) pml.getObject("java-pane");
>     }
>     /** Renvoie, si il existe, le panneau graphique de la proglet.
>      * @return Le panneau graphique de la proglet si il existe, sinon null.
>      */
>     public Component getProgletPane() {
>       setPane();
>       return (Component) pml.getObject("java-proglet-pane");
>     }
>     private void setPane() {
>       if(!pml.isDefined("pane-defined")) {
>         pml.set("pane-defined", true);
>         if(this.isProcessing()) {
>           boolean popup = true;
>           try {
>             int width = pml.getInteger("width", 500), height = pml.getInteger("height", 500);
>             Applet applet = (Applet) Class.forName("" + pml.getString("name") + "").newInstance();
>             applet.init();
>             applet.setMinimumSize(new Dimension(width, height));
>             applet.setMaximumSize(new Dimension(width, height));
>             if(popup) {
>               popupframe = (new MainFrame() {
>                               @Override
>                               public boolean isClosable() {
>                                 return false;
>                               }
>                             }
>                             ).asPopup().reset(getName(), getIcon(), width, height, applet);
>               pml.set("java-pane", null);
>             } else {
>               pml.set("java-pane", applet);
>             }
>             pml.set("java-proglet-pane", applet);
>           } catch(java.lang.ClassNotFoundException e0) {} catch(Throwable e) {
>             e.printStackTrace();
>             System.out.println("Upps erreur de chargement d'une proglet processing : " + e);
>           }
>         } else {
>           try {
>             Component pane = (Component) Class.forName("org.javascool.proglets." + pml.getString("name") + ".Panel").newInstance();
>             if(pane instanceof JFrame) {
>               ((JFrame) pane).setVisible(true);
>               pml.set("java-pane", null);
>             } else {
>               pml.set("java-pane", pane);
>             }
>             pml.set("java-proglet-pane", pane);
>           } catch(java.lang.ClassNotFoundException e0) {} catch(Throwable e) {
>             e.printStackTrace();
>             System.out.println("Upps erreur de chargement d'une proglet : " + e);
>           }
>         }
>       }
>     }
>     private MainFrame popupframe = null;
> 
>     /** Renvoie, si il existe, le translateur de code de la proglet.
>      * @return Le translateur de code de la proglet si il existe, sinon null.
>      */
>     public Translator getTranslator() {
>       return (Translator) pml.getObject("jvs-translator");
>     }
>     /** Indique si la proglet a une démo pour l'utilisateur.
>      */
>     public boolean hasDemo() {
>       return getPane() != null&& Invoke.run(getPane(), "start", false);
>     }
>     /** Lance la démo de la proglet.
>      * @throws RuntimeException si la méthode génère une exception lors de son appel.
>      */
>     public void doDemo() {
>       if(hasDemo()) {
>         (new Thread() {
>            @Override
>            public void run() {
>              Invoke.run(getPane(), "start");
>            }
>          }
>         ).start();
>       }
>     }
>     /**  Indique si la proglet est une proglet processing.
>      * @return La valeur true si cette applet est développée en processing.
>      */
>     public boolean isProcessing() {
>       return pml.getBoolean("processing");
>     }
>     /** Démarre la proglet. */
>     public void start() {
>       if(popupframe != null) {
>         popupframe.setVisible(true);
>       }
>       try {
>         if(getPane() != null&& getPane() instanceof Applet) {
>           ((Applet) getPane()).start();
>         }
>       } catch(Throwable e) {
>         System.err.println("Erreur au démarrage de l'applet/proglet");
>       }
>     }
>     /** Arrête la proglet. */
>     public void stop() {
>       try {
>         if(getPane() != null&& getPane() instanceof Applet) {
>           ((Applet) getPane()).stop();
>         }
>       } catch(Throwable e) {
>         System.err.println("Erreur à l'arrêt de l'applet/proglet");
>       }
>       if(popupframe != null) {
>         popupframe.setVisible(false);
>       }
274d424
<     return proglets.size();

>>> ./src/org/javascool/core/Jvs2Java.java

5a6,7
> import java.util.HashSet;
> 
8d9
< 
11,16c12,13
< /**
<  * Implémente le mécanisme de base de traduction d'un code Jvs en code Java
<  * standard.
<  * <p>
<  * Les erreurs de traduction sont affichées dans la console.
<  * </p>
---
> /** Implémente le mécanisme de base de traduction d'un code Jvs en code Java standard.
>  * <p>Les erreurs de traduction sont affichées dans la console.</p>
24,32c21,24
<   /**
<    * Définit un mécanisme spécifique de traduction en plus du mécanisme
<    * standard.
<    *
<    * @param progletTranslator
<    *            Le mécanisme de traduction spécifique d'une proglet donnée.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Jvs2Java translator = new Jvs2Java().setProgletTranslator(..)</tt>
<    *         .
---
> 
>   /** Définit un mécanisme spécifique de traduction en plus du mécanisme standard.
>    * @param progletTranslator Le mécanisme de traduction spécifique d'une proglet donnée.
>    * @return Cet objet, permettant de définir la construction <tt>Jvs2Java translator = new Jvs2Java().setProgletTranslator(..)</tt>.
41,49c33,35
<   /**
<    * Définit le nom complet du package de la proglet pour ce mécanismes de
<    * traduction.
<    *
<    * @param progletPackageName
<    *            Le nom complet du package de la proglet.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>Jvs2Java translator = new Jvs2Java().setProgletPackageName(..)</tt>
<    *         .
---
>   /** Définit le nom complet du package de la proglet pour ce mécanismes de traduction.
>    * @param progletPackageName Le nom complet du package de la proglet.
>    * @return Cet objet, permettant de définir la construction <tt>Jvs2Java translator = new Jvs2Java().setProgletPackageName(..)</tt>.
62,69c48,50
<     if(!text.replaceAll("[ \n\r\t]+", " ").matches(
<          ".*void[ ]+main[ ]*\\([ ]*\\).*"))
<     {
<       if(text.replaceAll("[ \n\r\t]+", " ").matches(
<            ".*main[ ]*\\([ ]*\\).*"))
<       {
<         System.out
<         .println("Attention: il faut mettre \"void\" devant \"main()\" pour que le programme puisque se compiler");
---
>     if(!text.replaceAll("[ \n\r\t]+", " ").matches(".*void[ ]+main[ ]*\\([ ]*\\).*")) {
>       if(text.replaceAll("[ \n\r\t]+", " ").matches(".*main[ ]*\\([ ]*\\).*")) {
>         System.out.println("Attention: il faut mettre \"void\" devant \"main()\" pour que le programme puisque se compiler");
72,73c53
<         System.out
<         .println("Attention: il faut un block \"void main()\" pour que le programme puisque se compiler");
---
>         System.out.println("Attention: il faut un block \"void main()\" pour que le programme puisque se compiler");
81a62
>       int i = 1;
88,89c69
<             System.out
<             .println("Attention: on ne peut normalement pas définir de package Java en JavaScool\n le programme risque de ne pas s'exécuter correctement");
---
>             System.out.println("Attention: on ne peut normalement pas définir de package Java en JavaScool\n le programme risque de ne pas s'exécuter correctement");
92,93c72
<           String name = line.replaceAll("^\\s*include([^;]*);\\s*$",
<                                         "$1").trim();
---
>           String name = line.replaceAll("^\\s*include([^;]*);\\s*$", "$1").trim();
100,102c79
<               } else if(!iline
<                         .matches("^\\s*package[^;]*;\\s*$"))
<               {
---
>               } else if(!iline.matches("^\\s*package[^;]*;\\s*$")) {
111a89
>         i++;
119,120c97
<         head.append("import static ").append(progletPackageName)
<         .append(".Functions.*;");
---
>         head.append("import static ").append(progletPackageName).append(".Functions.*;");
126,130c103,105
<       Jvs2Java.uid++;
<       head.append("public class JvsToJavaTranslated")
<       .append(Jvs2Java.uid).append(" implements Runnable{");
<       head.append("  private static final long serialVersionUID = ")
<       .append(Jvs2Java.uid).append("L;");
---
>       uid++;
>       head.append("public class JvsToJavaTranslated").append(uid).append(" implements Runnable{");
>       head.append("  private static final long serialVersionUID = ").append(uid).append("L;");
137,138c112,113
<     String finalBody = body.toString().replaceAll("(while.*\\{)",
<                                                   "$1 sleep(1);");
---
>     String finalBody = body.toString().
>                        replaceAll("(while.*\\{)", "$1 sleep(1);");
142,148c117,120
<     System.err
<     .println("\n-------------------\nCode java généré\n-------------------\n"
<              + head.toString().replaceAll("([{;])", "$1\n")
<              + "\n"
<              + finalBody
<              + "}"
<              + "\n----------------------------------------------------------\n");
---
>     System.err.println(
>       "\n-------------------\nCode java généré\n-------------------\n" +
>       head.toString().replaceAll("([{;])", "$1\n") + "\n" + finalBody + "}" +
>       "\n----------------------------------------------------------\n");
153c125
<     return "JvsToJavaTranslated" + Jvs2Java.uid;
---
>     return "JvsToJavaTranslated" + uid;
155,156c127
<   // Counter used to increment the serialVersionUID in order to reload the
<   // different versions of the class
---
>   // Counter used to increment the serialVersionUID in order to reload the different versions of the class
159,163c130,131
<   /**
<    * Rapporte une erreur survenue lors de l'exécution d'un prograamme Jvs.
<    *
<    * @param error
<    *            L'erreur ou exception à rapporter.
---
>   /** Rapporte une erreur survenue lors de l'exécution d'un prograamme Jvs.
>    * @param error L'erreur ou exception à rapporter.
168c136
<       return Jvs2Java.report(error.getCause());
---
>       return report(error.getCause());
179,183c147,148
<   /**
<    * Lanceur de la conversion Jvs en Java.
<    *
<    * @param usage
<    *            <tt>java org.javascool.core.Jvs2Java input-file [output-file]</tt>
---
>   /** Lanceur de la conversion Jvs en Java.
>    * @param usage <tt>java org.javascool.core.Jvs2Java input-file [output-file]</tt>
188,190c153
<       org.javascool.tools.FileManager.save(usage.length > 1 ? usage[1]
<                                            : "stdout:", new Jvs2Java()
<                                            .translate(org.javascool.tools.FileManager.load(usage[0])));
---
>       org.javascool.tools.FileManager.save(usage.length > 1 ? usage[1] : "stdout:", new Jvs2Java().translate(org.javascool.tools.FileManager.load(usage[0])));

>>> ./src/org/javascool/widgets/PanelApplet.java

7a8
> import javax.swing.JApplet;
10,11d10
< 
< import javax.swing.JApplet;
13,14d11
< import javax.swing.SwingConstants;
< 
17,26c14,19
< /**
<  * Définit une applet qui encapsule un objet graphique.
<  * <p>
<  * Permet de wrapper un objet graphique dans une page HTML avec une construction
<  * de la forme <div>
<  * <tt>&lt;applet code="org.javascool.widgets.PanelApplet" archive="les-classes-java.jar" width="560" height="720"></tt>
<  * </div> <div>
<  * <tt>&lt;param name="panel" value="nom-complet-qualifé-de-l-objet-graphique"/></tt>
<  * </div> <div><tt>&lt;param name="manual-start" value="true-ou-false"/></tt>
<  * </div> <div><tt>&lt;/applet></tt></div>
---
> /** Définit une applet qui encapsule un objet graphique.
>  * <p>Permet de wrapper un objet graphique dans une page HTML avec une construction de la forme
>  * <div><tt>&lt;applet code="org.javascool.widgets.PanelApplet" archive="les-classes-java.jar" width="560" height="720"></tt></div>
>  * <div><tt>&lt;param name="panel" value="nom-complet-qualifé-de-l-objet-graphique"/></tt></div>
>  * <div><tt>&lt;param name="manual-start" value="true-ou-false"/></tt></div>
>  * <div><tt>&lt;/applet></tt></div>
29,35c22,24
<  * <li>L'objet doit être un instance de <tt>java.awt.Component</tt> donc
<  * n'importe quel composant «swing» ou «awt».</li>
<  * <li>Si l'objet possède des méthodes <tt>init<tt>, , <tt>destroy</tt>,
<  * <tt>start</tt>, <tt>stop</tt> elles sont invoquées par les méthodes
<  * correspondandes de l'applet.</li>
<  * <li>Si l'option <tt>manual-start</tt> est activée les méthodes <tt>start</tt>, <tt>stop</tt> ne sont invoquées par l'applet mais par un bouton
<  * utilisateuer.</li>
---
>  * <li>L'objet doit être un instance de <tt>java.awt.Component</tt> donc n'importe quel composant «swing» ou «awt».</li>
>  * <li>Si l'objet possède des méthodes <tt>init<tt>, , <tt>destroy</tt>, <tt>start</tt>, <tt>stop</tt> elles sont invoquées par les méthodes correspondandes de l'applet.</li>
>  * <li>Si l'option <tt>manual-start</tt> est activée les méthodes <tt>start</tt>, <tt>stop</tt> ne sont invoquées par l'applet mais par un bouton utilisateuer.</li>
37d25
<  *
44,53c32,35
<   /**
<    * Definition programmatique des paramètres de l'applet.
<    *
<    * @param panel
<    *            Le nom de la classe Java de l'objet graphique à afficher.
<    * @param manualStart
<    *            Invocations manuelles si true des méthodes <tt>start/stop</tt>
<    *            (par défaut), sinon elles sont invoquées au lancement.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new PanelApplet().reset(..)</tt>.
---
>   /** Definition programmatique des paramètres de l'applet.
>    * @param panel Le nom de la classe Java de l'objet graphique à afficher.
>    * @param manualStart Invocations manuelles si true des méthodes <tt>start/stop</tt> (par défaut), sinon elles sont invoquées au lancement.
>    * @return Cet objet, permettant de définir la construction <tt>new PanelApplet().reset(..)</tt>.
68d49
< 
71,72c52
<     if(PanelApplet.pane != null) { throw new IllegalStateException(
<                                            "Impossible d'instancier deux PanelApplet dans une application");
---
>     if(pane != null) { throw new IllegalStateException("Impossible d'instancier deux PanelApplet dans une application");
77,79c57
<         manualStart = getParameter("manualStart") == null
<                       || getParameter("manualStart").toLowerCase().equals(
<           "true");
---
>         manualStart = getParameter("manualStart") == null || getParameter("manualStart").toLowerCase().equals("true");
83,85c61
<       getContentPane().add(
<         PanelApplet.pane = (Component) Class.forName(panel)
<                            .newInstance(), BorderLayout.CENTER);
---
>       getContentPane().add(pane = (Component) Class.forName(panel).newInstance(), BorderLayout.CENTER);
88,90c64
<       getContentPane()
<       .add(new JLabel("Pas d'applet à montrer.",
<                       SwingConstants.CENTER), BorderLayout.CENTER);
---
>       getContentPane().add(new JLabel("Pas d'applet à montrer.", JLabel.CENTER), BorderLayout.CENTER);
93,110c67,78
<     if(manualStart && Invoke.run(PanelApplet.pane, "start", false)) {
<       getContentPane().add(
<         new ToolBar().addTool("Démo de la proglet",
<                               "org/javascool/widgets/icons/play.png",
<                               new Runnable() {
<                                 @Override
<                                 public void run() {
<                                   (new Thread() {
<                                      @Override
<                                      public void run() {
<                                        Invoke.run(PanelApplet.pane,
<                                                   "start");
<                                      }
<                                    }
<                                   ).start();
<                                 }
<                               }
<                               ), BorderLayout.NORTH);
---
>     if(manualStart && Invoke.run(pane, "start", false)) {
>       getContentPane().add(new ToolBar().addTool("Démo de la proglet", "org/javascool/widgets/icons/play.png", new Runnable() {
>                                                    public void run() {
>                                                      (new Thread() {
>                                                         public void run() {
>                                                           Invoke.run(pane, "start");
>                                                         }
>                                                       }
>                                                      ).start();
>                                                    }
>                                                  }
>                                                  ), BorderLayout.NORTH);
112c80
<     Invoke.run(PanelApplet.pane, "init");
---
>     Invoke.run(pane, "init");
116c84
<     Invoke.run(PanelApplet.pane, "init");
---
>     Invoke.run(pane, "init");
121c89
<       Invoke.run(PanelApplet.pane, "start");
---
>       Invoke.run(pane, "start");
127c95
<       Invoke.run(PanelApplet.pane, "stop");
---
>       Invoke.run(pane, "stop");
130,134c98,99
<   /**
<    * Renvoie le panneau graphique de la proglet courante.
<    *
<    * @return Le panneau graphique de la proglet courante ou null si il n'est
<    *         pas défini.
---
>   /** Renvoie le panneau graphique de la proglet courante.
>    * @return Le panneau graphique de la proglet courante ou null si il n'est pas défini.
137c102
<     return PanelApplet.pane;
---
>     return pane;
144,149c109,110
<   /**
<    * Lanceur dans une fenêtre principale d'une objet graphique.
<    *
<    * @param usage
<    *            <tt>java org.javascool.widgets.PanelApplet nom-complet-qualifé-de-l-objet-graphique</tt>
<    *            .
---
>   /** Lanceur dans une fenêtre principale d'une objet graphique.
>    * @param usage <tt>java org.javascool.widgets.PanelApplet nom-complet-qualifé-de-l-objet-graphique</tt>.

>>> ./src/org/javascool/widgets/CurveOutput.java

7a8
> import javax.swing.JPanel;
10c11,12
< import java.awt.event.MouseEvent;
---
> 
> // Used to define a click
13c15
< import java.util.ArrayList;
---
> import java.awt.event.MouseEvent;
15c17,20
< import javax.swing.JPanel;
---
> // Used to define an icon/label
> 
> // Used to store labels
> import java.util.ArrayList;
17,18c22
< /**
<  * Panneau pour le tracé de courbes 2D.
---
> /** Panneau pour le tracé de courbes 2D.
31d34
< 
33d35
< 
38d39
< 
40d40
< 
45d44
< 
47d45
< 
53d50
< 
62,63c59
<   /**
<    * Routine interne de tracé, ne pas utiliser.
---
>   /** Routine interne de tracé, ne pas utiliser.
80c76
<         g.setColor(CurveOutput.colors[c]);
---
>         g.setColor(colors[c]);
148,149c144,145
<   private class ReticuleMouseListener implements MouseMotionListener,
<   MouseListener {
---
>   private class ReticuleMouseListener implements MouseMotionListener, MouseListener {
>     private static final long serialVersionUID = 1L;
176,190c172,177
<   /**
<    * Efface et initialize le tracé.
<    *
<    * @param Xoffset
<    *            Abscisse du point central. 0 par défaut.
<    * @param Yoffset
<    *            Ordonnée du point central. 0 par défaut.
<    * @param Xscale
<    *            Echelle horizontale, le tracé se fait dans
<    *            [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param Yscale
<    *            Echelle verticale, le tracé se fait dans
<    *            [-Yscale+Yoffset..Yscale+Yoffset].
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new CurveOutput().reset(..)</tt>.
---
>   /** Efface et initialize le tracé.
>    * @param Xoffset Abscisse du point central. 0 par défaut.
>    * @param Yoffset Ordonnée du point central. 0 par défaut.
>    * @param Xscale Echelle horizontale, le tracé se fait dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param Yscale Echelle verticale, le tracé se fait dans  [-Yscale+Yoffset..Yscale+Yoffset].
>    * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().reset(..)</tt>.
192,193c179
<   public CurveOutput reset(double Xoffset, double Yoffset, double Xscale,
<                            double Yscale) {
---
>   public CurveOutput reset(double Xoffset, double Yoffset, double Xscale, double Yscale) {
207,215c193,196
<   /**
<    * Efface et initialize le tracé.
<    *
<    * @param Xscale
<    *            Echelle horizontale.
<    * @param Yscale
<    *            Echelle verticale.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new CurveOutput().reset(..)</tt>.
---
>   /** Efface et initialize le tracé.
>    * @param Xscale Echelle horizontale.
>    * @param Yscale Echelle verticale.
>    * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().reset(..)</tt>.
229,264c210,217
<   /**
<    * Ajoute un point à une courbe.
<    *
<    * @param x
<    *            Abscisse du point dans [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param y
<    *            Ordonnée du point dans [-Yscale+Yoffset..Yscale+Yoffset].
<    * @param c
<    *            Couleur de la courbe, dans {0, 9}. Le code des couleurs est le
<    *            suivant: <div id="colors"><b>Code des couleurs</b>
<    *            <table>
<    *            <tr>
<    *            <td>0</td>
<    *            <td>1</td>
<    *            <td>2</td>
<    *            <td>3</td>
<    *            <td>4</td>
<    *            <td>5</td>
<    *            <td>6</td>
<    *            <td>7</td>
<    *            <td>8</td>
<    *            <td>9</td>
<    *            </tr>
<    *            <tr>
<    *            <td>noir</td>
<    *            <td>marron</td>
<    *            <td>rouge</td>
<    *            <td>orange</td>
<    *            <td>jaune</td>
<    *            <td>vert</td>
<    *            <td>bleu</td>
<    *            <td>violet</td>
<    *            <td>gris</td>
<    *            <td>blanc</td></td>
<    *            </table>
<    *            </div>
---
>   /** Ajoute un point à une courbe.
>    * @param x Abscisse du point dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param y Ordonnée du point dans [-Yscale+Yoffset..Yscale+Yoffset].
>    * @param c Couleur de la courbe, dans {0, 9}. Le code des couleurs est le suivant:
>    * <div id="colors"><b>Code des couleurs</b><table>
>    * <tr><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td><td>8</td><td>9</td></tr>
>    * <tr><td>noir</td><td>marron</td><td>rouge</td><td>orange</td><td>jaune</td><td>vert</td><td>bleu</td><td>violet</td><td>gris</td><td>blanc</td></td>
>    * </table></div>
275,291c228,234
<   /**
<    * Trace une ligne.
<    * <p>
<    * Pour tracer un point, tracer une ligne de longueur nulle (
<    * <tt>add(x, y, x, y, c);</tt>.
<    * </p>
<    *
<    * @param x1
<    *            Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param y1
<    *            Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
<    * @param x2
<    *            Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param y2
<    *            Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
<    * @param c
<    *            Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
---
>   /** Trace une ligne.
>    * <p>Pour tracer un point, tracer une ligne de longueur nulle (<tt>add(x, y, x, y, c);</tt>.</p>
>    * @param x1 Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param y1 Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
>    * @param x2 Abscisse du point, dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param y2 Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
>    * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
299c242
<     l.c = 0 <= c && c < 10 ? CurveOutput.colors[c] : Color.BLACK;
---
>     l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
303,313c246,250
<   /**
<    * Trace un cercle.
<    *
<    * @param x
<    *            Abscisse du centre, dans [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param y
<    *            Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
<    * @param r
<    *            Rayon du cercle.
<    * @param c
<    *            Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
---
>   /** Trace un cercle.
>    * @param x Abscisse du centre, dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param y Ordonnée du point, dans [-Yscale+Yoffset..Yscale+Yoffset].
>    * @param r Rayon du cercle.
>    * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
321c258
<     l.c = 0 <= c && c < 10 ? CurveOutput.colors[c] : Color.BLACK;
---
>     l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
325,337c262,266
<   /**
<    * Trace une chaîne de caractères.
<    *
<    * @param x
<    *            Abscisse du coin en haut à gauche du texte, dans
<    *            [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param y
<    *            Ordonnée du coin en haut à gauche du texte, dans
<    *            [-Yscale+Yoffset..Yscale+Yoffset].
<    * @param s
<    *            Texte à tracer.
<    * @param c
<    *            Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
---
>   /** Trace une chaîne de caractères.
>    * @param x Abscisse du coin en haut à gauche du texte, dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param y Ordonnée du coin en haut à gauche du texte, dans [-Yscale+Yoffset..Yscale+Yoffset].
>    * @param s Texte à tracer.
>    * @param c Couleur du tracé, <a href="#colors">dans {0, 9}</a>.
344c273
<     l.c = 0 <= c && c < 10 ? CurveOutput.colors[c] : Color.BLACK;
---
>     l.c = 0 <= c && c < 10 ? colors[c] : Color.BLACK;
356,362c285,287
<   /**
<    * Définit la position du réticule.
<    *
<    * @param x
<    *            Abscisse du réticule, dans [-Xscale+Xoffset..Xscale+Xoffset].
<    * @param y
<    *            Reticule ordinate, dans [-Yscale+Yoffset..Yscale+Yoffset].
---
>   /** Définit la position du réticule.
>    * @param x Abscisse du réticule, dans [-Xscale+Xoffset..Xscale+Xoffset].
>    * @param y Reticule ordinate, dans [-Yscale+Yoffset..Yscale+Yoffset].
375,377c300
<   private static Color colors[] = { Color.BLACK, new Color(150, 75, 0),
<                                     Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE,
<                                     Color.MAGENTA, Color.GRAY, Color.WHITE };
---
>   private static Color colors[] = { Color.BLACK, new Color(150, 75, 0), Color.RED, Color.ORANGE, Color.YELLOW, Color.GREEN, Color.BLUE, Color.MAGENTA, Color.GRAY, Color.WHITE };
379,385c302,304
<   /**
<    * Définit une portion de code appellée à chaque modification du réticule.
<    *
<    * @param runnable
<    *            La portion de code à appeler, ou null si il n'y en a pas.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new CurveOutput().setRunnable(..)</tt>.
---
>   /** Définit une portion de code appellée à chaque modification du réticule.
>    * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
>    * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().setRunnable(..)</tt>.

>>> ./src/org/javascool/widgets/TextEditor.java

2a3
> import javax.swing.JPanel;
3a5,7
> import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
> import org.fife.ui.rtextarea.RTextScrollPane;
> import org.fife.ui.rtextarea.Gutter;
6d9
< 
7a11
> import javax.swing.JPopupMenu;
10,11c14
< import javax.swing.JPanel;
< import javax.swing.JPopupMenu;
---
> import org.javascool.macros.Macros;
14d16
< import org.fife.ui.autocomplete.BasicCompletion;
17,21d18
< import org.fife.ui.autocomplete.ShorthandCompletion;
< import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
< import org.fife.ui.rtextarea.Gutter;
< import org.fife.ui.rtextarea.RTextScrollPane;
< import org.javascool.macros.Macros;
22a20,21
> import org.fife.ui.autocomplete.BasicCompletion;
> import org.fife.ui.autocomplete.ShorthandCompletion;
24,27c23
< /**
<  * Définit un panneau éditeur de texte qui intègre les fonctions de colorisation
<  * et de complétion automatique.
<  *
---
> /** Définit un panneau éditeur de texte qui intègre les fonctions de colorisation et de complétion automatique.
42,57c38,52
<   /**
<    * Tables des raccourcis de l'éditeur. - Il faut y ajouter des éléments de
<    * la forme:
<    * "&lt;tr>&lt;td>&lt;tt>Ctrl+<i>X</i>&lt;/tt>&lt;/td>&lt;td><i>description du raccourci</i>&lt;/td>&lt;/tr>\n"
<    * +
<    */
<   String helpText = "<tr><td><tt>Ctrl+a</tt></td><td>Sélectionne tout le texte</td></tr>\n"
<                     + "<tr><td><tt>Ctrl+c</tt></td><td>Copie du texte sous le curseur</td></tr>\n"
<                     + "<tr><td><tt>Ctrl+x</tt></td><td>Coupe du texte sous le curseur</td></tr>\n"
<                     + "<tr><td><tt>Ctrl+v</tt></td><td>Colle du texte précédemment copié ou collé</td></tr>\n"
<                     + "<tr><td></td><td></td></tr>\n"
<                     + "<tr><td><tt>Ctrl+z</tt></td><td>Annule la prédédente commande d'édition</td></tr>\n"
<                     + "<tr><td><tt>Ctrl+y</tt></td><td>Rétabli la prédédente commande d'édition</td></tr>\n"
<                     + "<tr><td></td><td></td></tr>\n"
<                     + "<tr><td><tt>Ctrl+Espace</tt></td><td>Lance l'auto-complétion</td></tr>\n"
<                     + "<tr><td></td><td></td></tr>\n";
---
>   /** Tables des raccourcis de l'éditeur.
>    * - Il faut y ajouter des éléments de la forme:
>    * "&lt;tr>&lt;td>&lt;tt>Ctrl+<i>X</i>&lt;/tt>&lt;/td>&lt;td><i>description du raccourci</i>&lt;/td>&lt;/tr>\n" +
>    */
>   String helpText =
>     "<tr><td><tt>Ctrl+a</tt></td><td>Sélectionne tout le texte</td></tr>\n" +
>     "<tr><td><tt>Ctrl+c</tt></td><td>Copie du texte sous le curseur</td></tr>\n" +
>     "<tr><td><tt>Ctrl+x</tt></td><td>Coupe du texte sous le curseur</td></tr>\n" +
>     "<tr><td><tt>Ctrl+v</tt></td><td>Colle du texte précédemment copié ou collé</td></tr>\n" +
>     "<tr><td></td><td></td></tr>\n" +
>     "<tr><td><tt>Ctrl+z</tt></td><td>Annule la prédédente commande d'édition</td></tr>\n" +
>     "<tr><td><tt>Ctrl+y</tt></td><td>Rétabli la prédédente commande d'édition</td></tr>\n" +
>     "<tr><td></td><td></td></tr>\n" +
>     "<tr><td><tt>Ctrl+Espace</tt></td><td>Lance l'auto-complétion</td></tr>\n" +
>     "<tr><td></td><td></td></tr>\n";
82,83c77
<       LanguageAwareCompletionProvider lacp = new LanguageAwareCompletionProvider(
<         completionsProvider);
---
>       LanguageAwareCompletionProvider lacp = new LanguageAwareCompletionProvider(completionsProvider);
101,102c95
<       j.add(new JLabel("<html>\n<b>Commandes d'édition</b><br><table>\n"
<                        + helpText + "</table>"));
---
>       j.add(new JLabel("<html>\n<b>Commandes d'édition</b><br><table>\n" + helpText + "</table>"));
109,115c102,104
<   /**
<    * Définit la colorisation de cet éditeur.
<    *
<    * @param syntax
<    *            Nom de la syntaxe : "Java", "Jvs", "None".
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new TextEditor().setProperty(..)</tt>.
---
>   /** Définit la colorisation de cet éditeur.
>    * @param syntax Nom de la syntaxe : "Java", "Jvs", "None".
>    * @return Cet objet, permettant de définir la construction <tt>new TextEditor().setProperty(..)</tt>.
132,137c121,124
<       addCompletions("org/javascool/macros/completion-langage.xml")
<       .addCompletions(
<         "org/javascool/macros/completion-stdout.xml")
<       .addCompletions("org/javascool/macros/completion-stdin.xml")
<       .addCompletions(
<         "org/javascool/macros/completion-macros.xml");
---
>       addCompletions("org/javascool/macros/completion-langage.xml").
>       addCompletions("org/javascool/macros/completion-stdout.xml").
>       addCompletions("org/javascool/macros/completion-stdin.xml").
>       addCompletions("org/javascool/macros/completion-macros.xml");
141,150c128,131
<   /**
<    * Ajoute à cet éditeur les complétions définies dans le fichier.
<    * <p>
<    * Les complétions sont déclenchées par Ctrl+Space.
<    * </p>
<    *
<    * @param completions
<    *            Le nom du fichier contenant la définition des complétions.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new TextEditor().addCompletions(..)</tt>.
---
>   /** Ajoute à cet éditeur les complétions définies dans le fichier.
>    * <p>Les complétions sont déclenchées par Ctrl+Space.</p>
>    * @param completions Le nom du fichier contenant la définition des complétions.
>    * @return Cet objet, permettant de définir la construction <tt>new TextEditor().addCompletions(..)</tt>.
169,173c150,151
<         if("code".equals(def.getChild(j).getTag())
<            && (def.getChild(j).getChild(0) != null&& code == null))
<         {
<           code = def.getChild(j).getChild(0).getTag()
<                  .replaceAll("\\\\\"", "\"");
---
>         if("code".equals(def.getChild(j).getTag()) && (def.getChild(j).getChild(0) != null&& code == null)) {
>           code = def.getChild(j).getChild(0).getTag().replaceAll("\\\\\"", "\"");
175,179c153,154
<         if("doc".equals(def.getChild(j).getTag())
<            && (def.getChild(j).getChild(0) != null&& doc == null))
<         {
<           doc = def.getChild(j).getChild(0).getTag()
<                 .replaceAll("\\\\\"", "\"");
---
>         if("doc".equals(def.getChild(j).getTag()) && (def.getChild(j).getChild(0) != null&& doc == null)) {
>           doc = def.getChild(j).getChild(0).getTag().replaceAll("\\\\\"", "\"");
185,187c160
<         BasicCompletion bc = code == null ? new BasicCompletion(
<           completionsProvider, name) : new ShorthandCompletion(
<           completionsProvider, name, code);
---
>         BasicCompletion bc = code == null ? new BasicCompletion(completionsProvider, name) : new ShorthandCompletion(completionsProvider, name, code);
197,198c170
<           insertions.add(new JMenuItem(new InsertAction(name, code,
<                                                         def.getInteger("offset", code.length()))));
---
>           insertions.add(new JMenuItem(new InsertAction(name, code, def.getInteger("offset", code.length()))));
207d178
< 
215d185
< 
225d194
< 
238,242c207,208
<   /**
<    * Initialise le texte à éditer.
<    *
<    * @param text
<    *            Le texte à éditer.
---
>   /** Initialise le texte à éditer.
>    * @param text Le texte à éditer.
247,251c213,214
<   /**
<    * Teste si le texte a été édité ou si il reste inchangé.
<    *
<    * @return Renvoie la valeur true si getText() et la dernière valeur donnée
<    *         à setText() ne sont pas les mêmes
---
>   /** Teste si le texte a été édité ou si il reste inchangé.
>    * @return Renvoie la valeur true si getText() et la dernière valeur donnée à setText() ne sont pas les mêmes
258,265c221,223
<   /**
<    * Marque une ligne du texte avec une icône.
<    *
<    * @param line
<    *            Numéro de la ligne du texte.
<    * @param icon
<    *            Nom de l'icône à utiliser (une icône indiquant une erreur par
<    *            défaut).
---
>   /** Marque une ligne du texte avec une icône.
>    * @param line Numéro de la ligne du texte.
>    * @param icon Nom de l'icône à utiliser (une icône indiquant une erreur par défaut).
272,277c230
<       scrollPane
<       .getGutter()
<       .addLineTrackingIcon(
<         line - 1,
<         Macros.getIcon(icon == null ? "org/javascool/widgets/icons/error.png"
<                        : icon));
---
>       scrollPane.getGutter().addLineTrackingIcon(line - 1, Macros.getIcon(icon == null ? "org/javascool/widgets/icons/error.png" : icon));

>>> ./src/org/javascool/widgets/Dialog.java

5d4
< 
8,9d6
< import javax.swing.WindowConstants;
< 
12,20c9,11
< /**
<  * Définit un dialogue en popup qui gère l'aspect modal/non-modal.
<  * <p>
<  * Si le dialog est appelé de l'AWT il est non-modal (donc ne bloque pas l'AWT)
<  * sinon il est modal (il blqieu jusqu'à complétion du dialogue).
<  * <p>
<  * Son utilisation typique se fait à travers une construction de la forme:
<  *
<  * <pre>
---
> /** Définit un dialogue en popup qui gère l'aspect modal/non-modal.
>  * <p>Si le dialog est appelé de l'AWT il est non-modal (donc ne bloque pas l'AWT) sinon il est modal (il blqieu jusqu'à complétion du dialogue).
>  * <p>Son utilisation typique se fait à travers une construction de la forme:<pre>
23,31c14,15
<  * dialog.open(true);
<  * </pre>
<  *
<  * </p>
<  * <p>
<  * Lorsque le composant du dialogue reçoit la réponse il ferme le dialogue, par
<  * exemple:
<  *
<  * <pre>
---
>  * dialog.open(true);</pre></p>
>  * <p>Lorsque le composant du dialogue reçoit la réponse il ferme le dialogue, par exemple:<pre>
35,38c19
<  * }
<  * </pre>
<  *
<  * </p>
---
>  * }</pre></p>
41,45d21
<   /**
<    *
<    */
<   private static final long serialVersionUID = -3508966264239125706L;
< 
57,68c33,35
<   /**
<    * Ouvre le dialogue et entre en attente d'un retour de l'utilisateur.
<    *
<    * @param modal
<    *            Si true le dialogue est bloquant et attend la réponse de
<    *            l'utilisateur, si false il est non-modal et renvoie la main
<    *            AVANT que le dialogue soit complété.
<    *            <p>
<    *            Il ne faut pas appelé le dialogue en mode modal directement
<    *            d'un gestionnaire d'événement (bouton, etc..) mais utiliser un
<    *            Thread.
<    *            </p>
---
>   /** Ouvre le dialogue et entre en attente d'un retour de l'utilisateur.
>    * @param modal Si true le dialogue est bloquant et attend la réponse de l'utilisateur, si false il est non-modal et renvoie la main AVANT que le dialogue soit complété.
>    * <p>Il ne faut pas appelé le dialogue en mode modal directement d'un gestionnaire d'événement (bouton, etc..) mais utiliser un Thread.</p>
71c38
<     setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);
---
>     setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
74,75c41
<       setLocation((MainFrame.getFrame().getWidth() - getWidth()) / 2,
<                   (MainFrame.getFrame().getHeight() - getHeight()) / 2);
---
>       setLocation((MainFrame.getFrame().getWidth() - getWidth()) / 2, (MainFrame.getFrame().getHeight() - getHeight()) / 2);
78,79c44
<     if(modal && SwingUtilities.isEventDispatchThread()) { throw new IllegalStateException(
<                                                                   "Impossible d'utiliser un dialogue modal directement d'un événement de l'interface: créer un thread");
---
>     if(modal && SwingUtilities.isEventDispatchThread()) { throw new IllegalStateException("Impossible d'utiliser un dialogue modal directement d'un événement de l'interface: créer un thread");
86,89c51
<   /**
<    * Routine à appeler quand le dialogue à été achevé pour continuer le
<    * programme.
<    */
---
>   /** Routine à appeler quand le dialogue à été achevé pour continuer le programme. */
94,96c56,57
<   /**
<    * Teste si le dialogue est en cours ou achevé. return La valeur true si le
<    * dialogue est en cours, sinon false.
---
>   /** Teste si le dialogue est en cours ou achevé.
>    * return La valeur true si le dialogue est en cours, sinon false.

>>> ./src/org/javascool/widgets/Console.java

6a7
> import javax.swing.JPanel;
10,13d10
< import java.io.IOException;
< import java.io.OutputStream;
< import java.io.PrintStream;
< 
15d11
< import javax.swing.JPanel;
18a15,18
> // redirectSystemStreams
> import java.io.OutputStream;
> import java.io.PrintStream;
> import java.io.IOException;
21,23c21
< /**
<  * Définit une zone d'affichage qui permet de recevoir les messages de la
<  * console.
---
> /** Définit une zone d'affichage qui permet de recevoir les messages de la console.
41,45c39,40
<   /**
<    * Crée et/ou renvoie l'unique instance de console.
<    * <p>
<    * Une application ne peut définir qu'une seule console.
<    * </p>
---
>   /** Crée et/ou renvoie l'unique instance de console.
>    * <p>Une application ne peut définir qu'une seule console.</p>
48,49c43,44
<     if(Console.console == null) {
<       Console.console = new Console();
---
>     if(console == null) {
>       console = new Console();
51c46
<     return Console.console;
---
>     return console;
55c50
<     return Console.console != null;
---
>     return console != null;
72,73c67
<     toolbar.addTool("Effacer", "org/javascool/widgets/icons/erase.png",
<                     new Runnable() {
---
>     toolbar.addTool("Effacer", "org/javascool/widgets/icons/erase.png", new Runnable() {
80,81c74
<     toolbar.addTool("Copier tout",
<                     "org/javascool/widgets/icons/copyAll.png", new Runnable() {
---
>     toolbar.addTool("Copier tout", "org/javascool/widgets/icons/copyAll.png", new Runnable() {
88,90c81
<     toolbar.addTool("Copier sélection",
<                     "org/javascool/widgets/icons/copySelection.png",
<                     new Runnable() {
---
>     toolbar.addTool("Copier sélection", "org/javascool/widgets/icons/copySelection.png", new Runnable() {
98,99c89
<     toolbar.addTool("status", status = new JLabel(
<                       "                                         "));
---
>     toolbar.addTool("status", status = new JLabel("                                         "));
139,143c129,130
<   /**
<    * Affiche une information dans la barre de statut.
<    *
<    * @param text
<    *            Texte à afficher.
---
>   /** Affiche une information dans la barre de statut.
>    * @param text Texte à afficher.
148,152c135,136
<   /**
<    * Affiche du texte dans la console.
<    *
<    * @param text
<    *            Le texte à afficher.
---
>   /** Affiche du texte dans la console.
>    * @param text Le texte à afficher.
155c139
<     for(String p : Console.prefixes)
---
>     for(String p : prefixes)
162,168c146,152
<   private static final String prefixes[] = { "=== Minim Error ===",
<                                              "=== Likely buffer underrun in AudioOutput.",
<                                              "==== JavaSound Minim Error ====" };
< 
<   /**
<    * Renvoie le contenu actuel de la console.
<    *
---
>   private static final String prefixes[] = {
>     "=== Minim Error ===",
>     "=== Likely buffer underrun in AudioOutput.",
>     "==== JavaSound Minim Error ===="
>   };
> 
>   /** Renvoie le contenu actuel de la console.
174,176c158
<   /**
<    * Renvoie la barre de menu de la console pour ajouter des éléments.
<    *
---
>   /** Renvoie la barre de menu de la console pour ajouter des éléments.
182,187c164,165
<   /**
<    * Sauve ce qui est présentement écrit dans la console dans un fichierL.
<    *
<    * @param location
<    *            La localisation (chemin du fichier ou localisation internet)
<    *            où sauver le texte.
---
>   /** Sauve ce qui est présentement écrit dans la console dans un fichierL.
>    * @param location La localisation (chemin du fichier ou localisation internet) où sauver le texte.

>>> ./src/org/javascool/widgets/StartStopButton.java

3,5d2
< import java.awt.event.ActionEvent;
< import java.awt.event.ActionListener;
< 
9a7,9
> import java.awt.event.ActionEvent;
> import java.awt.event.ActionListener;
> 
61,65c61,67
<     /*
<      * BUG FIX : Stop button not change immediately at program stop.
<      * SOLUTION : Use two separate Threads to check running speeder than the
<      * Timer which get up all seconds, the isRunningThread get up all 50
<      * milliseconds. AUTHOR : Philippe VIENNE <philoumailabo@gmail.com>
---
>     /* BUG FIX : Stop button not change immediately at program
>      * stop.
>      * SOLUTION :
>      * Use two separate Threads to check running speeder than
>      * the Timer which get up all seconds, the isRunningThread
>      * get up all 50 milliseconds.
>      * AUTHOR : Philippe VIENNE <philoumailabo@gmail.com>

>>> ./src/org/javascool/widgets/HtmlDisplay.java

8a9,10
> import java.net.MalformedURLException;
> import javax.swing.JPanel;
13,18d14
< import java.net.MalformedURLException;
< import java.net.URL;
< import java.net.URLDecoder;
< import java.net.URLEncoder;
< import java.util.ArrayList;
< 
20,21d15
< import javax.swing.JEditorPane;
< import javax.swing.JPanel;
23c17,19
< import javax.swing.ScrollPaneConstants;
---
> import javax.swing.JEditorPane;
> 
> // Used to manage links
25a22,24
> import java.net.URL;
> import java.net.URLEncoder;
> import java.net.URLDecoder;
27d25
< 
30,66c28,47
< /**
<  * Definit un visualisateur de pages HTML3.
<  * <p>
<  * <i>Note:</i> L'implémentation disponible ne rend utilisable que le "vieux"
<  * HTML-3.
<  * </p>
<  * <p>
<  * <i>Conseil:</i> Ecrire les pages en <a href=
<  * "http://javascool.gforge.inria.fr/v4/index.php?page=developers&action=doc-xml"
<  * >HML</a> (en XHTML simplifié), la maintenance et polyvalence des pages en
<  * sera renforcée.
<  * </p>
<  * <div id="URLs">
<  * <p>
<  * <b>Mécanismes d'affichage des contenus:</b>
<  * <ul>
<  * <li>Les pages locales d'extension <tt>*.htm</tt> sont réputées être du HTML3
<  * et sont affichées ici.</li>
<  * <li>Les autres pages <tt>http://</tt>, <tt>file://</tt>, etc.. sont
<  * visualiées dans le navigateur du système, extérieur à javascool.</li>
<  * <li>Il est possible d'ouvrir des pages dans une cible autre que ce
<  * visualisateur:
<  * <ul>
<  * <li>Les liens de la forme <tt>http://editor/<i>location</i></tt> ouvrent le
<  * document dans l'éditeur de JavaScool. <br>
<  * Il sont générés par un tag de la form <tt>&lt;l class="editor" ..</tt></li>
<  * <li>Les liens de la forme <tt>http://newtab/<i>location</i></tt> ouvrent le
<  * document dans un autre onglet de JavaScool.<br>
<  * Il sont générés par un tag de la form <tt>&lt;l class="newtab" ..</tt></li></li>
<  * </ul>
<  * Il sont produits par les tags <tt>&lt;a target="editor" . . </tt> du XML. En
<  * cas d'échec les contenus sont dirigés vers le navigateur du système,
<  * extérieur à javascool.</li>
<  * <li>Les liens de la forme <tt>string://?value="text"</tt> permettent
<  * d'afficher directement du texte HTML3.</li>
<  * <li>Les autres liens font l'objet d'un appel à la méthode <tt>doBrowse()</tt>
<  * ce qui permet de définir des URI dépendant de l'application.</li> </ul></div>
---
> // Used to manage keystroke
> import java.util.ArrayList;
> 
> /** Definit un visualisateur de pages HTML3.
>  * <p><i>Note:</i> L'implémentation disponible ne rend utilisable que le "vieux" HTML-3.</p>
>  * <p><i>Conseil:</i> Ecrire les pages en <a href="http://javascool.gforge.inria.fr/v4/index.php?page=developers&action=doc-xml">HML</a> (en XHTML simplifié),
>  * la maintenance et polyvalence des pages en sera renforcée.</p>
>  * <div id="URLs"><p><b>Mécanismes d'affichage des contenus:</b><ul>
>  * <li>Les pages locales d'extension <tt>*.htm</tt> sont réputées être du HTML3 et sont affichées ici.</li>
>  * <li>Les autres pages <tt>http://</tt>, <tt>file://</tt>, etc.. sont visualiées dans le navigateur du système, extérieur à javascool.</li>
>  * <li>Il est possible d'ouvrir des pages dans une cible autre que ce visualisateur: <ul>
>  *   <li>Les liens de la forme <tt>http://editor/<i>location</i></tt> ouvrent le document dans l'éditeur de JavaScool. <br>
>  *     Il sont générés par un tag de la form <tt>&lt;l class="editor" ..</tt></li>
>  *   <li>Les liens de la forme <tt>http://newtab/<i>location</i></tt> ouvrent le document dans un autre onglet de JavaScool.<br>
>  *     Il sont générés par un tag de la form <tt>&lt;l class="newtab" ..</tt></li> </li>
>  * </ul> Il sont produits par les tags <tt>&lt;a target="editor" . . </tt> du XML.
>  * En cas d'échec les contenus sont dirigés vers le navigateur du système, extérieur à javascool.</li>
>  * <li>Les liens de la forme <tt>string://?value="text"</tt> permettent d'afficher directement du texte HTML3.</li>
>  * <li>Les autres liens font l'objet d'un appel à la méthode <tt>doBrowse()</tt> ce qui permet de définir des URI dépendant de l'application.</li>
>  * </ul></div>
91,92c72
<       home = bar.addTool("Page initiale",
<                          "org/javascool/widgets/icons/refresh.png", new Runnable() {
---
>       home = bar.addTool("Page initiale", "org/javascool/widgets/icons/refresh.png", new Runnable() {
101,102c81
<       prev = bar.addTool("Page précédente",
<                          "org/javascool/widgets/icons/prev.png", new Runnable() {
---
>       prev = bar.addTool("Page précédente", "org/javascool/widgets/icons/prev.png", new Runnable() {
111,112c90
<       next = bar.addTool("Page suivante",
<                          "org/javascool/widgets/icons/next.png", new Runnable() {
---
>       next = bar.addTool("Page suivante", "org/javascool/widgets/icons/next.png", new Runnable() {
137,139c115
<       JScrollPane spane = new JScrollPane(pane,
<                                           ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS,
<                                           ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);
---
>       JScrollPane spane = new JScrollPane(pane, JScrollPane.VERTICAL_SCROLLBAR_ALWAYS, JScrollPane.HORIZONTAL_SCROLLBAR_AS_NEEDED);
143,149c119,121
<   /**
<    * Affiche une page de texte HTML3 dans le visualisateur.
<    *
<    * @param location
<    *            L'URL de la page à afficher.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new HtmlDisplay().setPage(..)</tt>.
---
>   /** Affiche une page de texte HTML3 dans le visualisateur.
>    * @param location L'URL de la page à afficher.
>    * @return Cet objet, permettant de définir la construction <tt>new HtmlDisplay().setPage(..)</tt>.
159,165c131,133
<   /**
<    * Affiche un texte HTML3 dans le visualisateur.
<    *
<    * @param text
<    *            Le texte à afficher.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new HtmlDisplay().setText(..)</tt>.
---
>   /** Affiche un texte HTML3 dans le visualisateur.
>    * @param text Le texte à afficher.
>    * @return Cet objet, permettant de définir la construction <tt>new HtmlDisplay().setText(..)</tt>.
169,172c137,138
<       return setPage(HtmlDisplay.stringPrefix
<                      + URLEncoder.encode(text, "utf-8"));
<     } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu: (" + e
<                                                                                       + ") c'est un bug Java !");
---
>       return setPage(stringPrefix + URLEncoder.encode(text, "utf-8"));
>     } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu: (" + e + ") c'est un bug Java !");
186d151
< 
233d197
< 
236,246c200,203
<   /**
<    * Implémentation du mécanisme de gestion des URL spécifiques.
<    * <p>
<    * Cette routine est appelée pour gérer des URL specifiques d'une
<    * application donnée.
<    * </p>
<    *
<    * @param location
<    *            L'URL à traiter.
<    * @return Cette méthode doit retourner true si l'URL à été traité et false
<    *         si l'URL n'a pas été reconnu ou traité.
---
>   /** Implémentation du mécanisme de gestion des URL spécifiques.
>    * <p>Cette routine est appelée pour gérer des URL specifiques d'une application donnée.</p>
>    * @param location L'URL à traiter.
>    * @return Cette méthode doit retourner true si l'URL à été traité et false si l'URL n'a pas été reconnu ou traité.
256,258c213
<       setText("Cette page est à l'adresse internet: <tt>«"
<               + location.replaceFirst("^(mailto):.*", "$1: ...")
<               + "»</tt> (non accessible ici).");
---
>       setText("Cette page est à l'adresse internet: <tt>«" + location.replaceFirst("^(mailto):.*", "$1: ...") + "»</tt> (non accessible ici).");
264,265c219
<     if(location.startsWith(HtmlDisplay.stringPrefix)) {  // Affichage de
<       // texte
---
>     if(location.startsWith(stringPrefix)) { // Affichage de texte
270,274c224,225
<         pane.setText(URLDecoder.decode(
<                        location.substring(HtmlDisplay.stringPrefix.length()),
<                        "utf-8"));
<       } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu : (" + e
<                                                                                         + ") c'est un bug Java !");
---
>         pane.setText(URLDecoder.decode(location.substring(stringPrefix.length()), "utf-8"));
>       } catch(java.io.UnsupportedEncodingException e) { throw new IllegalStateException("Encodage non reconnu : (" + e + ") c'est un bug Java !");
276,298c227,233
<     } else if(location.startsWith(HtmlDisplay.editorPrefix)) {  // Affichage
<       // dans
<       // editeur
<       // JavaScool
<       org.javascool.gui.Desktop.getInstance()
<       .openFile(
<         toURL(location.substring(HtmlDisplay.editorPrefix
<                                  .length())));
<     } else if(location.startsWith(HtmlDisplay.newtabPrefix)) {  // Affichage
<       // dans
<       // browser
<       // JavaScool
<       URL url = toURL(location.substring(HtmlDisplay.newtabPrefix
<                                          .length()));
<       String name = new File(url.getPath()).getName()
<                     .replaceFirst("\\.[^\\.]*$", "").replace('_', '.');
<       org.javascool.gui.Desktop.getInstance().openBrowserTab(
<         url.toString(),
<         name.substring(0, 1).toUpperCase() + name.substring(1));
<     } else if(location.matches("^(http|https|rtsp|mailto):.*$")) {  // Gestion
<       // des
<       // URL
<       // externes
---
>     } else if(location.startsWith(editorPrefix)) {  // Affichage dans editeur JavaScool
>       org.javascool.gui.Desktop.getInstance().openFile(toURL(location.substring(editorPrefix.length())));
>     } else if(location.startsWith(newtabPrefix)) {    // Affichage dans browser JavaScool
>       URL url = toURL(location.substring(newtabPrefix.length()));
>       String name = new File(url.getPath()).getName().replaceFirst("\\.[^\\.]*$", "").replace('_', '.');
>       org.javascool.gui.Desktop.getInstance().openBrowserTab(url.toString(), name.substring(0, 1).toUpperCase() + name.substring(1));
>     } else if(location.matches("^(http|https|rtsp|mailto):.*$")) {    // Gestion des URL externes
300,307c235
<     } else if(location.matches(".*\\.htm$") || location.matches("^#.*")) {  // Gestion
<       // des
<       // URLs
<       // en
<       // HTML3
<       // et
<       // des
<       // ancres
---
>     } else if(location.matches(".*\\.htm$") || location.matches("^#.*")) {   // Gestion des URLs en HTML3 et des ancres
309,311c237,238
<     } else if(!doBrowse(location)) {
<       setText("Le lien : <tt>«" + location
<               + "»</tt> n'a pas pu être affiché");
---
>     } else if(!doBrowse(location)) {   // Délégation au client
>       setText("Le lien : <tt>«" + location + "»</tt> n'a pas pu être affiché");
318,319c245
<     pane.getDocument()
<     .putProperty(Document.StreamDescriptionProperty, null);
---
>     pane.getDocument().putProperty(Document.StreamDescriptionProperty, null);
324,325c250
<       setText("Le lien : <tt>«" + url + "»</tt> génère une erreur \""
<               + e.toString() + "\"");
---
>       setText("Le lien : <tt>«" + url + "»</tt> génère une erreur \"" + e.toString() + "\"");
338,340c263,265
<       return urls.isEmpty() ? Macros.getResourceURL(location) : urls
<              .getCurrent() instanceof URL ? new URL(
<                (URL) urls.getCurrent(), location) : new URL(location);
---
>       return urls.isEmpty() ? Macros.getResourceURL(location) :
>              urls.getCurrent() instanceof URL ? new URL((URL) urls.getCurrent(), location) :
>              new URL(location);
343,344c268
<         return new URL(HtmlDisplay.stringPrefix + "Le lien : <tt>«"
<                        + location + "»</tt> est mal formé");
---
>         return new URL(stringPrefix + "Le lien : <tt>«" + location + "»</tt> est mal formé");
349a274
> 

>>> ./src/org/javascool/widgets/MainFrame.java

3a4,8
> import javax.swing.UIManager.LookAndFeelInfo;
> import javax.swing.UIManager;
> 
> import javax.swing.JFrame;
> import javax.swing.JRootPane;
6d10
< import java.awt.Frame;
9d12
< 
11,16d13
< import javax.swing.JFrame;
< import javax.swing.JRootPane;
< import javax.swing.UIManager;
< import javax.swing.UIManager.LookAndFeelInfo;
< import javax.swing.WindowConstants;
< 
21,24d17
<   /**
<    *
<    */
<   private static final long serialVersionUID = -928171438069261824L;
26d18
< 
28a21
> 
44,45c37
<           UIManager
<           .setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
---
>           UIManager.setLookAndFeel("com.sun.java.swing.plaf.windows.WindowsLookAndFeel");
49,50c41
<           UIManager.setLookAndFeel(UIManager
<                                    .getSystemLookAndFeelClassName());
---
>           UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
52,53c43
<           System.err
<           .println("Note: Utilisaton du thème Java (et non du système)");
---
>           System.err.println("Note: Utilisaton du thème Java (et non du système)");
59c49
<     MainFrame.setLookAndFeel();
---
>     setLookAndFeel();
62,69c52,54
<   /**
<    * Construit la fenêtre sans boutons de fermeture.
<    * <p>
<    * - Doit être appelé avant la méthode reset.
<    * </p>
<    *
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new MainFrame().asPopup().reset(..)</tt>.
---
>   /** Construit la fenêtre sans boutons de fermeture.
>    * <p>- Doit être appelé avant la méthode reset.</p>
>    * @return Cet objet, permettant de définir la construction <tt>new MainFrame().asPopup().reset(..)</tt>.
81,95c66,72
<   /**
<    * Construit et ouvre une fenêtre principale pour lancer une application.
<    *
<    * @param title
<    *            Le titre de la fenêtre.
<    * @param icon
<    *            L'icône de la fenêtre.
<    * @param width
<    *            Largeur de la fenêtre. Si 0 on prend tout l'écran.
<    * @param height
<    *            Hauteur de la fenêtre. Si 0 on prend tout l'écran.
<    * @param pane
<    *            Le composant graphique à afficher.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new MainFrame().reset(..)</tt>.
---
>   /** Construit et ouvre une fenêtre principale pour lancer une application.
>    * @param title Le titre de la fenêtre.
>    * @param icon L'icône de la fenêtre.
>    * @param width Largeur de la fenêtre. Si 0 on prend tout l'écran.
>    * @param height Hauteur de la fenêtre. Si 0 on prend tout l'écran.
>    * @param pane Le composant graphique à afficher.
>    * @return Cet objet, permettant de définir la construction <tt>new MainFrame().reset(..)</tt>.
97,98c74
<   public MainFrame reset(String title, String icon, int width, int height,
<                          Component pane) {
---
>   public MainFrame reset(String title, String icon, int width, int height, Component pane) {
104,106c80
<         System.setProperty(
<           "com.apple.mrj.application.apple.menu.about.name",
<           title);
---
>         System.setProperty("com.apple.mrj.application.apple.menu.about.name", title);
119c93
<     setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE);
---
>     setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
131c105
<       setExtendedState(Frame.MAXIMIZED_BOTH);
---
>       setExtendedState(JFrame.MAXIMIZED_BOTH);
137,138c111,112
<     if(MainFrame.firstFrame == null) {
<       MainFrame.firstFrame = this;
---
>     if(firstFrame == null) {
>       firstFrame = this;
140c114
<     MainFrame.frameCount++;
---
>     frameCount++;
173,177c147,148
<   /**
<    * Ferme la fenêtre principale à partir du programme.
<    *
<    * @param force
<    *            Si true ferme la fenêter même si isClosable() renvoie false.
---
>   /** Ferme la fenêtre principale à partir du programme.
>    * @param force Si true ferme la fenêter même si isClosable() renvoie false.
191,192c162,163
<       MainFrame.frameCount--;
<       if(MainFrame.frameCount == 0) {
---
>       frameCount--;
>       if(frameCount == 0) {
203,207c174,175
<   /**
<    * Détermine si la fenêtre principale peut-être fermée.
<    *
<    * @return La valeur true si la fenêtre principale peut-être fermée, sinon
<    *         false.
---
>   /** Détermine si la fenêtre principale peut-être fermée.
>    * @return La valeur true si la fenêtre principale peut-être fermée, sinon false.
212,214c180
<   /**
<    * Renvoie la frame principale ouverte.
<    *
---
>   /** Renvoie la frame principale ouverte.
218c184
<     return MainFrame.firstFrame;
---
>     return firstFrame;

>>> ./src/org/javascool/widgets/NumberInput.java

7a8
> import javax.swing.JPanel;
9c10,13
< import java.awt.Font;
---
> import javax.swing.BorderFactory;
> 
> // Used for the text field
> import javax.swing.JTextField;
12,13d15
< import java.awt.event.MouseEvent;
< import java.awt.event.MouseListener;
15,16c17
< import javax.swing.BorderFactory;
< import javax.swing.JPanel;
---
> // Used for the slider
18c19,21
< import javax.swing.JTextField;
---
> import java.awt.Font;
> import java.awt.event.MouseEvent;
> import java.awt.event.MouseListener;
20,22c23
< /**
<  * Panneau pour l'entrée de valeurs numériques.
<  *
---
> /** Panneau pour l'entrée de valeurs numériques.
28d28
< 
36,37c36
<                                 try {
<                                   set(new Double(field.getText()).doubleValue(), 'T');
---
>                                 try { set(new Double(field.getText()).doubleValue(), 'T');
48d46
< 
51d48
< 
54d50
< 
57d52
< 
60,61c55
<                                 set((NumberInput.this.max - NumberInput.this.min) / 100.0
<                                     * slider.getValue() + NumberInput.this.min, 'S');
---
>                                 set((NumberInput.this.max - NumberInput.this.min) / 100.0 * slider.getValue() + NumberInput.this.min, 'S');
72d65
< 
76,77c69
<     value = step <= 0 ? value : min + step
<             *Math.rint((value - min) / step);
---
>     value = step <= 0 ? value : min + step *Math.rint((value - min) / step);
80,81c72
<     field.setText(new Double(value).toString()
<                   .replaceFirst("(99999|00000).*$", "").replaceFirst(".0$", ""));
---
>     field.setText(new Double(value).toString().replaceFirst("(99999|00000).*$", "").replaceFirst(".0$", ""));
83,84c74
<       slider.setValue((int) ((max > min) ? 100.0 * (value - min)
<                              / (max - min) : value));
---
>       slider.setValue((int) ((max > min) ? 100.0 * (value - min) / (max - min) : value));
90,96c80,82
<   /**
<    * Définit le nom de la valeur numérique.
<    *
<    * @param name
<    *            Nom du paramètre.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new NumberInput().setScale(..)</tt>.
---
>   /** Définit le nom de la valeur numérique.
>    * @param name Nom du paramètre.
>    * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setScale(..)</tt>.
102,112c88,92
<   /**
<    * Définit le nom et les paramètres de la valeur numérique.
<    *
<    * @param min
<    *            Valeur minimale à entrer. 0 par défaut.
<    * @param max
<    *            Valeur maximale à entrer. 100 par défaut.
<    * @param step
<    *            Précision de la valeur à entrer. 1 par défaut.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new NumberInput().setScale(..)</tt>.
---
>   /** Définit le nom et les paramètres de la valeur numérique.
>    * @param min Valeur minimale à entrer. 0 par défaut.
>    * @param max Valeur maximale à entrer. 100 par défaut.
>    * @param step Précision de la valeur à entrer. 1 par défaut.
>    * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setScale(..)</tt>.
134,140c114,116
<   /**
<    * Définit une portion de code appellée à chaque modification de la valeur.
<    *
<    * @param runnable
<    *            La portion de code à appeler, ou null si il n'y en a pas.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new NumberInput().setRunnable(..)</tt>.
---
>   /** Définit une portion de code appellée à chaque modification de la valeur.
>    * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
>    * @return Cet objet, permettant de définir la construction <tt>new NumberInput().setRunnable(..)</tt>.

>>> ./src/org/javascool/widgets/IconOutput.java

7a8
> import javax.swing.JPanel;
9d9
< import java.awt.Dimension;
11,15d10
< import java.awt.Graphics2D;
< import java.awt.event.MouseEvent;
< import java.awt.event.MouseListener;
< import java.awt.image.BufferedImage;
< import java.io.IOException;
17a13,16
> // Used to manipulate the image
> import java.awt.image.BufferedImage;
> import java.awt.Graphics2D;
> import java.awt.Dimension;
19,20d17
< import javax.swing.JPanel;
< 
21a19
> import java.io.IOException;
23,24c21,26
< /**
<  * Panneau pour le tracé d'images pixeliques.
---
> // Used to define a click
> import java.awt.event.MouseListener;
> import java.awt.event.MouseMotionListener;
> import java.awt.event.MouseEvent;
> 
> /** Panneau pour le tracé d'images pixeliques.
31d32
< 
55,60c56,57
<   /**
<    * Cette routine est appellée à chaque tracé et permet de définir un tracé
<    * spécifique au dessus de l'image affichée. - Pour utiliser cette
<    * foncctionnalité, il faut définir:
<    *
<    * <pre>
---
>   /** Cette routine est appellée à chaque tracé et permet de définir un tracé spécifique au dessus de l'image affichée.
>    * - Pour utiliser cette foncctionnalité, il faut définir: <pre>
62,69c59,63
<    *  public void paint2D(Graphics2D g) {
<    *    // Ici ajouter les g.drawLine g.fillOval g.drawRect g.fillRect souhaité.
<    *  }
<    * }
<    * </pre>
<    *
<    * @param g2d
<    *            L'environnement graphique 2D à utiliser pour peindre.
---
>    *   public void paint2D(Graphics2D g) {
>    *     // Ici ajouter les g.drawLine g.fillOval g.drawRect g.fillRect souhaité.
>    *   }
>    * }</pre>
>    * @param g2d L'environnement graphique 2D à utiliser pour peindre.
73,76c67,68
<     int di = width > 0 && getWidth() >= width && zoom ? getWidth() / width
<              : 1;
<     int dj = height > 0 && getHeight() >= height && zoom ? getHeight()
<              / height : 1;
---
>     int di = width > 0 && getWidth() >= width && zoom ? getWidth() / width : 1;
>     int dj = height > 0 && getHeight() >= height && zoom ? getHeight() / height : 1;
81,93c73,77
<   /**
<    * Efface et initialize l'image.
<    *
<    * @param width
<    *            Taille horizontale de l'image.
<    * @param height
<    *            Taille verticale de l'image.
<    * @param zoom
<    *            Ajuste automatiquement la taille de l'image au display si true
<    *            (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de
<    *            l'affichage.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new IconOutput().reset(..)</tt>.
---
>   /**  Efface et initialize l'image.
>    * @param width Taille horizontale de l'image.
>    * @param height Taille verticale de l'image.
>    * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
>    * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
96,97c80
<     if((width > 550) || (height > 550) || (width * height > 550 * 550)) { throw new IllegalArgumentException("L'image est trop grande ("
<                                                                                                              + width + ", " + height + ") !");
---
>     if((width > 550) || (height > 550) || (width * height > 550 * 550)) { throw new IllegalArgumentException("L'image est trop grande (" + width + ", " + height + ") !");
102,103c85,92
<      * if (width <= 0) width = 300; if (height <= 0) height = 300; if(width
<      * % 2 == 0) width++; if(height % 2 == 0) height++;
---
>      *  if (width <= 0)
>      *  width = 300;
>      *  if (height <= 0)
>      *  height = 300;
>      *  if(width % 2 == 0)
>      *  width++;
>      *  if(height % 2 == 0)
>      *  height++;
117,127c106,109
<   /**
<    * Initialize l'image à partir d'un fichier.
<    *
<    * @param location
<    *            L'URL (Universal Resource Location) de l'image.
<    * @param zoom
<    *            Ajuste automatiquement la taille de l'image au display si true
<    *            (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de
<    *            l'affichage.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new IconOutput().reset(..)</tt>.
---
>   /** Initialize l'image à partir d'un fichier.
>    * @param location L'URL (Universal Resource Location) de l'image.
>    * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
>    * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
141c123
<   public final IconOutput reset(String location) throws IOException {
---
>   public final IconOutput reset(String location)  throws IOException {
144,154c126,129
<   /**
<    * Initialize l'image à partir d'une image en mémoire.
<    *
<    * @param img
<    *            L'image qui va initialiser le tracé.
<    * @param zoom
<    *            Ajuste automatiquement la taille de l'image au display si true
<    *            (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de
<    *            l'affichage.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new IconOutput().reset(..)</tt>.
---
>   /** Initialize l'image à partir d'une image en mémoire.
>    * @param img L'image qui va initialiser le tracé.
>    * @param zoom Ajuste automatiquement la taille de l'image au display si true (par défaut), sinon fixe 1 pixel de l'image à 1 pixel de l'affichage.
>    * @return Cet objet, permettant de définir la construction <tt>new IconOutput().reset(..)</tt>.
174,176c149
<   /**
<    * Renvoie une image dans laquelle le contenu de l'affichage est copié.
<    *
---
>   /** Renvoie une image dans laquelle le contenu de l'affichage est copié.
180,181c153
<     BufferedImage img = new BufferedImage(width, height,
<                                           BufferedImage.TYPE_INT_RGB);
---
>     BufferedImage img = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
187,198c159,163
<   /**
<    * Définit la valeur d'un pixel.
<    *
<    * @param x
<    *            Abscisse du pixel, dans {0, width{.
<    * @param y
<    *            Ordonnée du pixel, dans {0, height{.
<    * @param c
<    *            Couleur: "black" (default), "blue", "cyan", "gray", "green",
<    *            "magenta", "orange", "pink", "red", "white", "yellow".
<    * @return La valeur true si le pixel est dans les limites de l'image, false
<    *         sinon.
---
>   /** Définit la valeur d'un pixel.
>    * @param x Abscisse du pixel, dans {0, width{.
>    * @param y Ordonnée du pixel, dans {0, height{.
>    * @param  c Couleur: "black" (default), "blue", "cyan", "gray", "green", "magenta", "orange", "pink", "red", "white", "yellow".
>    * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
201c166
<     return set(x, y, IconOutput.getColor(c));
---
>     return set(x, y, getColor(c));
203,214c168,172
<   /**
<    * Définit la valeur d'un pixel.
<    *
<    * @param x
<    *            Abscisse du pixel, dans {0, width{.
<    * @param y
<    *            Ordonnée du pixel, dans {0, height{.
<    * @param v
<    *            L'intensité en niveau de gris du pixel de 0 (noir) à 255
<    *            (blanc).
<    * @return La valeur true si le pixel est dans les limites de l'image, false
<    *         sinon.
---
>   /** Définit la valeur d'un pixel.
>    * @param x Abscisse du pixel, dans {0, width{.
>    * @param y Ordonnée du pixel, dans {0, height{.
>    * @param v L'intensité en niveau de gris du pixel de 0 (noir) à 255 (blanc).
>    * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
220,230c178,182
<   /**
<    * Définit la valeur d'un pixel.
<    *
<    * @param x
<    *            Abscisse du pixel, dans {0, width{.
<    * @param y
<    *            Ordonnée du pixel, dans {0, height{.
<    * @param c
<    *            L'intensité en couleur du pixel.
<    * @return La valeur true si le pixel est dans les limites de l'image, false
<    *         sinon.
---
>   /** Définit la valeur d'un pixel.
>    * @param x Abscisse du pixel, dans {0, width{.
>    * @param y Ordonnée du pixel, dans {0, height{.
>    * @param c L'intensité en couleur du pixel.
>    * @return La valeur true si le pixel est dans les limites de l'image, false sinon.
243,251c195,198
<   /**
<    * Renvoie la valeur d'un pixel.
<    *
<    * @param x
<    *            Abscisse du pixel, dans {0, width{.
<    * @param y
<    *            Ordonnée du pixel, dans {0, height{.
<    * @return L'intensite du pixel entre 0 et 255 ou 0 si le pixel n'est pas
<    *         dans l'image.
---
>   /** Renvoie la valeur d'un pixel.
>    * @param x Abscisse du pixel, dans {0, width{.
>    * @param y Ordonnée du pixel, dans {0, height{.
>    * @return L'intensite du pixel entre 0 et 255 ou 0 si le pixel n'est pas dans l'image.
261,269c208,211
<   /**
<    * Renvoie la valeur d'un pixel.
<    *
<    * @param x
<    *            Abscisse du pixel, dans {0, width{.
<    * @param y
<    *            Ordonnée du pixel, dans {0, height{.
<    * @return La couleur du pixel ou "undefined" si le pixel n'est pas dans
<    *         l'image.
---
>   /**  Renvoie la valeur d'un pixel.
>    * @param x Abscisse du pixel, dans {0, width{.
>    * @param y Ordonnée du pixel, dans {0, height{.
>    * @return La couleur du pixel ou "undefined" si le pixel n'est pas dans l'image.
274,275c216
<       return IconOutput.colors.containsKey(c) ? IconOutput.colors.get(c)
<              : c.toString();
---
>       return colors.containsKey(c) ? colors.get(c) : c.toString();
280,286c221,223
<   /**
<    * Renvoie la valeur d'un pixel.
<    *
<    * @param x
<    *            Abscisse du pixel, dans {0, width{.
<    * @param y
<    *            Ordonnée du pixel, dans {0, height{.
---
>   /**  Renvoie la valeur d'un pixel.
>    * @param x Abscisse du pixel, dans {0, width{.
>    * @param y Ordonnée du pixel, dans {0, height{.
302d238
< 
304,306c240
<     try {
<       return (Color) Class.forName("java.awt.Color").getField(color)
<              .get(null);
---
>     try { return (Color) Class.forName("java.awt.Color").getField(color).get(null);
312c246
<     IconOutput.colors.put(IconOutput.getColor(color), color);
---
>     colors.put(getColor(color), color);
315,325c249,259
<     IconOutput.putColors("black");
<     IconOutput.putColors("blue");
<     IconOutput.putColors("cyan");
<     IconOutput.putColors("gray");
<     IconOutput.putColors("green");
<     IconOutput.putColors("magenta");
<     IconOutput.putColors("orange");
<     IconOutput.putColors("pink");
<     IconOutput.putColors("red");
<     IconOutput.putColors("white");
<     IconOutput.putColors("yellow");
---
>     putColors("black");
>     putColors("blue");
>     putColors("cyan");
>     putColors("gray");
>     putColors("green");
>     putColors("magenta");
>     putColors("orange");
>     putColors("pink");
>     putColors("red");
>     putColors("white");
>     putColors("yellow");
338a273
>                        private static final long serialVersionUID = 1L;
348d282
< 
351d284
< 
354d286
< 
357d288
< 
364,370c295,297
<   /**
<    * Définit une portion de code appellée à chaque clic de souris.
<    *
<    * @param runnable
<    *            La portion de code à appeler, ou null si il n'y en a pas.
<    * @return Cet objet, permettant de définir la construction
<    *         <tt>new CurveOutput().setRunnable(..)</tt>.
---
>   /** Définit une portion de code appellée à chaque clic de souris.
>    * @param runnable La portion de code à appeler, ou null si il n'y en a pas.
>    * @return Cet objet, permettant de définir la construction <tt>new CurveOutput().setRunnable(..)</tt>.

>>> ./src/org/javascool/widgets/ToolBar.java

2a3
> import javax.swing.JToolBar;
6,7d6
< 
< import javax.swing.AbstractButton;
9d7
< import javax.swing.JButton;
10a9,10
> import javax.swing.AbstractButton;
> import javax.swing.JButton;
12,13d11
< import javax.swing.JToolBar;
< 
16,17c14
< /**
<  * Définit une barre d'outils avec intégration de la gestion des actions.
---
> /** Définit une barre d'outils avec intégration de la gestion des actions.
25d21
< 
47,56c43,46
<   /**
<    * Ajoute un bouton à la barre d'outils.
<    *
<    * @param label
<    *            Nom du bouton. Chaque bouton/item/étiquette doit avoir un nom
<    *            différent.
<    * @param icon
<    *            Icone du bouton. Si null le bouton est montré sans icone.
<    * @param action
<    *            Action associée au bouton.
---
>   /** Ajoute un bouton à la barre d'outils.
>    * @param label Nom du bouton. Chaque bouton/item/étiquette doit avoir un nom différent.
>    * @param icon  Icone du bouton. Si null le bouton est montré sans icone.
>    * @param action Action associée au bouton.
68,77c58,61
<   /**
<    * Ajoute un pop-up à la barre d'outil.
<    *
<    * @param label
<    *            Nom du composant. Chaque bouton/item/étiquette doit avoir un
<    *            nom différent.
<    * @param icon
<    *            Icone du bouton. Si null le bouton est montré sans icone.
<    * @return Le popup ajouté. Il permet de définir un menu ou d'afficher un
<    *         composant etc...
---
>   /** Ajoute un pop-up à la barre d'outil.
>    * @param label Nom du composant. Chaque bouton/item/étiquette doit avoir un nom différent.
>    * @param icon  Icone du bouton. Si null le bouton est montré sans icone.
>    * @return Le popup ajouté. Il permet de définir un menu ou d'afficher un composant etc...
93d76
< 
100,102c83
<   /**
<    * Ajoute un bouton à une position précise de la barre d'outil
<    *
---
>   /** Ajoute un bouton à une position précise de la barre d'outil
105,108c86,87
<   private JButton addTool(String label, String icon, Runnable action,
<                           int where) {
<     JButton button = icon == null ? new JButton(label) : new JButton(label,
<                                                                      Macros.getIcon(icon));
---
>   private JButton addTool(String label, String icon, Runnable action, int where) {
>     JButton button = icon == null ? new JButton(label) : new JButton(label, Macros.getIcon(icon));
112c91
<                                  actions.get(e.getSource()).run();
---
>                                  actions.get((AbstractButton) e.getSource()).run();
117,119c96
<     if(buttons.containsKey(label)) { throw new IllegalArgumentException(
<                                              "Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «"
<                                              + label + "» est en doublon");
---
>     if(buttons.containsKey(label)) { throw new IllegalArgumentException("Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «" + label + "» est en doublon");
126,133c103,105
<   /**
<    * Ajoute un composant à la barre d'outils.
<    *
<    * @param label
<    *            Nom du composant (ce nom restera invisible). Chaque
<    *            bouton/item/étiquette doit avoir un nom différent.
<    * @param component
<    *            Le composant à ajouter.
---
>   /** Ajoute un composant à la barre d'outils.
>    * @param label Nom du composant (ce nom restera invisible). Chaque bouton/item/étiquette doit avoir un nom différent.
>    * @param component Le composant à ajouter.
137,139c109
<     if(buttons.containsKey(label)) { throw new IllegalArgumentException(
<                                              "Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «"
<                                              + label + "» est en doublon");
---
>     if(buttons.containsKey(label)) { throw new IllegalArgumentException("Chaque bouton/item/étiquette doit avoir un nom différent, mais le bouton «" + label + "» est en doublon");
150,151c120,121
<       if(c instanceof AbstractButton && actions.containsKey(c)) {
<         actions.remove(c);
---
>       if(c instanceof AbstractButton && actions.containsKey((AbstractButton) c)) {
>         actions.remove((AbstractButton) c);
163,178c133,135
<   /**
<    * @see #addRightTool(String, String, Runnable)
<    */
<   public JButton addRightTool(String label, Runnable action) {
<     return addRightTool(label, null, action);
<   }
<   /**
<    * Ajoute un composant à la droite de la barre d'outil.
<    *
<    * @param label
<    *            Nom du composant. Chaque bouton/item/étiquette doit avoir un
<    *            nom différent.
<    * @param icon
<    *            Icone du bouton. Si null le bouton est montré sans icone.
<    * @param action
<    *            Action associée au bouton.
---
>   /** Ajoute un composant à la droite de la barre d'outil.
>    * @param label Nom du composant. Chaque bouton/item/étiquette doit avoir un nom différent.
>    * @param action Action associée au bouton.
181c138
<   public JButton addRightTool(String label, String icon, Runnable action) {
---
>   public JButton addRightTool(String label, Runnable action) {
185c142
<     return addTool(label, icon, action, left + (++right));
---
>     return addTool(label, null, action, left + (++right));
187,192c144,145
<   /**
<    * Ajoute un pop-up à la droite de la barre d'outil.
<    *
<    * @param label
<    *            Nom du composant. Chaque bouton/item/étiquette doit avoir un
<    *            nom différent.
---
>   /** Ajoute un pop-up à la droite de la barre d'outil.
>    * @param label Nom du composant. Chaque bouton/item/étiquette doit avoir un nom différent.
201d153
<   // Non, il peut toujours servir
203,207c155,156
<   /**
<    * Ajoute en permanence un composant à la droite de la barre d'outils.
<    *
<    * @param component
<    *            Le composant à ajouter.
---
>   /** Ajoute en permanence un composant à la droite de la barre d'outils.
>    * @param component Le composant à ajouter.
214,223d162
<   }
<   /**
<    * Ajoute en permanence un composant à la gauche de la barre d'outils.
<    *
<    * @param component
<    *            Le composant à ajouter.
<    */
<   public void addLeftTool(JComponent component) {
<     add(component, 0);
<     left++;

>>> ./src/org/javascool/widgets/TabbedPane.java

5a6
> import java.awt.Cursor;
10c11
< import java.awt.Image;
---
> import java.awt.Rectangle;
16,17c17
< import java.awt.image.ImageObserver;
< import java.io.IOException;
---
> import java.awt.event.MouseMotionListener;
19d18
< import javax.imageio.ImageIO;
21a21
> import javax.swing.ImageIcon;
23a24
> import javax.swing.JComponent;
27d27
< import javax.swing.plaf.basic.BasicButtonUI;
29c29
< import org.javascool.Core;
---
> import javax.swing.plaf.basic.BasicButtonUI;
32,35c32
< /**
<  * Propose un container d'objets graphiques avec des onglets pouvant posséder
<  * une croix de fermeture.
<  *
---
> /** Propose un container d'objets graphiques avec des onglets pouvant posséder une croix de fermeture.
41,55c38,43
<   /**
<    * Ajoute un composant à ce panneau à onglet.
<    *
<    * @param title
<    *            Le nom du composant.
<    * @param icon
<    *            Le nom de l'icone de ce composant.
<    * @param component
<    *            Le composant à ajouter.
<    * @param tooltip
<    *            Un petit titre à afficher quand le curseur passe sur l'onglet
<    *            du composant.
<    * @param closable
<    *            Si true indique qu'il y a une croix de fermeture, sinon false
<    *            (valeur par défaut).
---
>   /** Ajoute un composant à ce panneau à onglet.
>    * @param title Le nom du composant.
>    * @param icon Le nom de l'icone de ce composant.
>    * @param component Le composant à ajouter.
>    * @param tooltip Un petit titre à afficher quand le curseur passe sur l'onglet du composant.
>    * @param closable Si true indique qu'il y a une croix de fermeture, sinon false (valeur par défaut).
57,58c45
<   public void addTab(String title, String icon, Component component,
<                      String tooltip, boolean closable) {
---
>   public void addTab(String title, String icon, Component component, String tooltip, boolean closable) {
64,65c51
<   public void addTab(String title, Icon icon, Component component,
<                      String tooltip, boolean closable) {
---
>   public void addTab(String title, Icon icon, Component component, String tooltip, boolean closable) {
75,76c61
<   public void addTab(String title, String icon, Component component,
<                      String tooltip) {
---
>   public void addTab(String title, String icon, Component component, String tooltip) {
83,84c68
<   public void addTab(String title, Icon icon, Component component,
<                      String tooltip) {
---
>   public void addTab(String title, Icon icon, Component component, String tooltip) {
103,104c87
<   public void addTab(String title, Component component, String tooltip,
<                      boolean closable) {
---
>   public void addTab(String title, Component component, String tooltip, boolean closable) {
126,137c109,112
<   /**
<    * Procède à la fermeture d'un composant du panneau.
<    * <p>
<    * Cette routine doit être surchargée pour (i) effectuer les opérations
<    * necéssaires à la fermeture et (ii) autoriser ou non cette fermeture.
<    * </p>
<    * <p>
<    * La fermeture est autorisée par défaut.
<    * </p>
<    *
<    * @param index
<    *            Index du composant dans le panneau.
---
>   /** Procède à la fermeture d'un composant du panneau.
>    * <p>Cette routine doit être surchargée pour (i) effectuer les opérations necéssaires à la fermeture et (ii) autoriser ou non cette fermeture. </p>
>    * <p>La fermeture est autorisée par défaut.</p>
>    * @param index Index du composant dans le panneau.
148,153d122
<   /** Affiche un onglet donné.
<    * @param name Le titre de l'onglet
<    */
<   public void switchToTab(String name) {
<     this.setSelectedIndex(this.indexOfTab(name));
<   }
209,220c178,181
<         try {
<           g2.drawImage(ImageIO.read(TabbedPane.class.getResourceAsStream("icons/close.png")), 3, 3, g2.getClipBounds().width - 3, g2.getClipBounds().height - 3, 0, 0, 24, 24, new ImageObserver() {
<                          @Override
<                          public boolean imageUpdate(Image img, int infoflags, int x, int y,
<                                                     int width, int height) {
<                            return false;
<                          }
<                        }
<                        );
<         } catch(IOException e) {
<           // TODO Auto-generated catch block
<           e.printStackTrace();
---
>         g2.setStroke(new BasicStroke(2));
>         g2.setColor(Color.BLACK);
>         if(getModel().isRollover()) {
>           g2.setColor(Color.WHITE);
222,231c183,185
<         /*g2.setStroke(new BasicStroke(2));
<          *  g2.setColor(Color.BLACK);
<          *  if (getModel().isRollover()) {
<          *  g2.setColor(Color.WHITE);
<          *  }
<          *  int delta = 6;
<          *  g2.drawLine(delta, delta, getWidth() - delta - 1, getHeight()
<          *   - delta - 1);
<          *  g2.drawLine(getWidth() - delta - 1, delta, delta, getHeight()
<          *   - delta - 1);*/
---
>         int delta = 6;
>         g2.drawLine(delta, delta, getWidth() - delta - 1, getHeight() - delta - 1);
>         g2.drawLine(getWidth() - delta - 1, delta, delta, getHeight() - delta - 1);

>>> ./src/org/javascool/Core.java

6a7,8
> import javax.swing.UIManager;
> import org.javascool.macros.Macros;
8d9
< import java.io.UnsupportedEncodingException;
11,13c12
< 
< import javax.swing.UIManager;
< 
---
> import java.io.UnsupportedEncodingException;
15d13
< import org.javascool.macros.Macros;
18,20c16
< /**
<  * Lanceur de l'application "apprenant" qui permet de manipuler des «proglets».
<  * *
---
> /** Lanceur de l'application "apprenant" qui permet de manipuler des «proglets».  *
28d23
< 
31,37c26,31
<     ErrorCatcher
<     .setUncaughtExceptionAlert(
<       "<h1>Détection d'une anomalie liée à Java:</h1>\n"
<       + "Il y a un problème de compatibilité avec votre système, nous allons vous aider:<ul>\n"
<       + "  <li>Copier/Coller tous les éléments de cette fenêtre et</li>\n"
<       + "  <li>Envoyez les par mail à <b>javascool@googlegroups.com</b> avec toute information utile.</li>"
<       + " </ul>", About.revision);
---
>     ErrorCatcher.setUncaughtExceptionAlert("<h1>Détection d'une anomalie liée à Java:</h1>\n" +
>                                            "Il y a un problème de compatibilité avec votre système, nous allons vous aider:<ul>\n" +
>                                            "  <li>Copier/Coller tous les éléments de cette fenêtre et</li>\n" +
>                                            "  <li>Envoyez les par mail à <b>javascool@googlegroups.com</b> avec toute information utile.</li>" +
>                                            " </ul>",
>                                            About.revision);
39,41c33
<   /**
<    * Retrouve le chemin du jar courant.
<    *
---
>   /** Retrouve le chemin du jar courant.
43,44c35
<    * @throws RuntimeException
<    *             lorsque l'application n'a pas été démarré depuis un jar
---
>    * @throws RuntimeException lorsque l'application n'a pas été démarré depuis un jar
47,48c38,39
<     if(Core.javascoolJar != null) {
<       return Core.javascoolJar;
---
>     if(javascoolJar != null) {
>       return javascoolJar;
50,51c41
<     String url = Macros.getResourceURL("org/javascool/Core.class")
<                  .toString().replaceFirst("jar:file:([^!]*)!.*", "$1");
---
>     String url = Macros.getResourceURL("org/javascool/Core.class").toString().replaceFirst("jar:file:([^!]*)!.*", "$1");
57c47
<           return Core.javascoolJar = jar;
---
>           return javascoolJar = jar;
59,60c49
<         // Ici on essaye tous les encodages possibles pour essayer de
<         // détecter javascool
---
>         // Ici on essaye tous les encodages possibles pour essayer de détecter javascool
62,63c51
<           jar = URLDecoder.decode(url, Charset.defaultCharset()
<                                   .name());
---
>           jar = URLDecoder.decode(url, Charset.defaultCharset().name());
65c53
<             Core.javascoolJarEnc = Charset.defaultCharset().name();
---
>             javascoolJarEnc = Charset.defaultCharset().name();
71,74c59,61
<               Core.javascoolJarEnc = enc;
<               System.err.println("Notice: javascool file " + jar
<                                  + " correct decoding as " + enc);
<               return Core.javascoolJar = jar;
---
>               javascoolJarEnc = enc;
>               System.err.println("Notice: javascool file " + jar + " correct decoding as " + enc);
>               return javascoolJar = jar;
76,77c63
<               System.err.println("Notice: javascool file " + jar
<                                  + " wrong decoding as " + enc);
---
>               System.err.println("Notice: javascool file " + jar + " wrong decoding as " + enc);
79,80c65
<           } throw new RuntimeException(
<                   "Il y a un bug d'encoding sur cette plate forme");
---
>           } throw new RuntimeException("Il y a un bug d'encoding sur cette plate forme");
82,83c67
<       } catch(UnsupportedEncodingException ex) { throw new RuntimeException(
<                                                          "Spurious defaultCharset: this is a caveat");
---
>       } catch(UnsupportedEncodingException ex) { throw new RuntimeException("Spurious defaultCharset: this is a caveat");
85,86c69
<     } else {
<       return "";
---
>     } else { return "";
87a71
>     // throw new RuntimeException("Java's cool n'a pas été démarré depuis un Jar");
90,91c74,75
<     Core.javascoolJar();
<     return Core.javascoolJarEnc;
---
>     javascoolJar();
>     return javascoolJarEnc;
95,99c79,80
<   /**
<    * Lanceur de l'application.
<    *
<    * @param usage
<    *            <tt>java -jar javascool.jar</tt>
---
>   /** Lanceur de l'application.
>    * @param usage <tt>java -jar javascool.jar</tt>
102,107c83,84
<     if((usage.length > 0)
<        && (usage[0].equals("-h") || usage[0].equals("-help") || usage[0]
<            .equals("--help")))
<     {
<       System.out
<       .println("Java's Cool Core - lance l'interface pour travailler avec les proglets");
---
>     if((usage.length > 0) && (usage[0].equals("-h") || usage[0].equals("-help") || usage[0].equals("--help"))) {
>       System.out.println("Java's Cool Core - lance l'interface pour travailler avec les proglets");
115c92
<     Core.setUncaughtExceptionAlert();
---
>     setUncaughtExceptionAlert();
